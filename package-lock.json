ouble);\\n  }\\n\\n  [data-nextjs-call-stack-frame] > h6 {\\n    margin-top: 0;\\n    margin-bottom: var(--size-gap);\\n    font-family: var(--font-stack-monospace);\\n    color: #222;\\n  }\\n  [data-nextjs-call-stack-frame] > h6[data-nextjs-frame-expanded='false'] {\\n    color: #666;\\n  }\\n  [data-nextjs-call-stack-frame] > div {\\n    display: flex;\\n    align-items: center;\\n    padding-left: calc(var(--size-gap) + var(--size-gap-half));\\n    font-size: var(--size-font-small);\\n    color: #999;\\n  }\\n  [data-nextjs-call-stack-frame] > div > svg {\\n    width: auto;\\n    height: var(--size-font-small);\\n    margin-left: var(--size-gap);\\n\\n    display: none;\\n  }\\n\\n  [data-nextjs-call-stack-frame] > div[data-has-source] {\\n    cursor: pointer;\\n  }\\n  [data-nextjs-call-stack-frame] > div[data-has-source]:hover {\\n    text-decoration: underline dotted;\\n  }\\n  [data-nextjs-call-stack-frame] > div[data-has-source] > svg {\\n    display: unset;\\n  }\\n\"])));var p},403:function(e,n,t){var r=this&&this.__awaiter||function(e,n,t,r){function adopt(e){return e instanceof t?e:new t((function(n){n(e)}))}return new(t||(t=Promise))((function(t,a){function fulfilled(e){try{step(r.next(e))}catch(e){a(e)}}function rejected(e){try{step(r[\"throw\"](e))}catch(e){a(e)}}function step(e){e.done?t(e.value):adopt(e.value).then(fulfilled,rejected)}step((r=r.apply(e,n||[])).next())}))};var a=this&&this.__generator||function(e,n){var t={label:0,sent:function(){if(o[0]&1)throw o[1];return o[1]},trys:[],ops:[]},r,a,o,i;return i={next:verb(0),throw:verb(1),return:verb(2)},typeof Symbol===\"function\"&&(i[Symbol.iterator]=function(){return this}),i;function verb(e){return function(n){return step([e,n])}}function step(i){if(r)throw new TypeError(\"Generator is already executing.\");while(t)try{if(r=1,a&&(o=i[0]&2?a[\"return\"]:i[0]?a[\"throw\"]||((o=a[\"return\"])&&o.call(a),0):a.next)&&!(o=o.call(a,i[1])).done)return o;if(a=0,o)i=[i[0]&2,o.value];switch(i[0]){case 0:case 1:o=i;break;case 4:t.label++;return{value:i[1],done:false};case 5:t.label++;a=i[1];i=[0];continue;case 7:i=t.ops.pop();t.trys.pop();continue;default:if(!(o=t.trys,o=o.length>0&&o[o.length-1])&&(i[0]===6||i[0]===2)){t=0;continue}if(i[0]===3&&(!o||i[1]>o[0]&&i[1]<o[3])){t.label=i[1];break}if(i[0]===6&&t.label<o[1]){t.label=o[1];o=i;break}if(o&&t.label<o[2]){t.label=o[2];t.ops.push(i);break}if(o[2])t.ops.pop();t.trys.pop();continue}i=n.call(e,t)}catch(e){i=[6,e];a=0}finally{r=o=0}if(i[0]&5)throw i[1];return{value:i[0]?i[1]:void 0,done:true}}};n.__esModule=true;n.getErrorByType=void 0;var o=t(851);var i=t(233);var l=t(504);function getErrorByType(e){return r(this,void 0,void 0,(function(){var n,t,r,s;var u;return a(this,(function(a){switch(a.label){case 0:n=e.id,t=e.event;r=t.type;switch(r){case o.TYPE_UNHANDLED_ERROR:return[3,1];case o.TYPE_UNHANDLED_REJECTION:return[3,1]}return[3,3];case 1:u={id:n,runtime:true,error:t.reason};return[4,(0,l.getOriginalStackFrames)(t.frames,(0,i.getErrorSource)(t.reason),t.reason.toString())];case 2:return[2,(u.frames=a.sent(),u)];case 3:{return[3,4]}a.label=4;case 4:s=t;throw new Error(\"type system invariant violation\")}}))}))}n.getErrorByType=getErrorByType},233:function(e,n,t){var r=this&&this.__assign||function(){r=Object.assign||function(e){for(var n,t=1,r=arguments.length;t<r;t++){n=arguments[t];for(var a in n)if(Object.prototype.hasOwnProperty.call(n,a))e[a]=n[a]}return e};return r.apply(this,arguments)};n.__esModule=true;n.getServerError=n.decorateServerError=n.getErrorSource=n.getFilesystemFrame=void 0;var a=t(974);function getFilesystemFrame(e){var n=r({},e);if(typeof n.file===\"string\"){if(n.file.startsWith(\"/\")||/^[a-z]:\\\\/i.test(n.file)||n.file.startsWith(\"\\\\\\\\\")){n.file=\"file://\".concat(n.file)}}return n}n.getFilesystemFrame=getFilesystemFrame;var o=Symbol(\"NextjsError\");function getErrorSource(e){return e[o]||null}n.getErrorSource=getErrorSource;function decorateServerError(e,n){Object.defineProperty(e,o,{writable:false,enumerable:false,configurable:false,value:n})}n.decorateServerError=decorateServerError;function getServerError(e,n){var t;try{throw new Error(e.message)}catch(e){t=e}t.name=e.name;try{t.stack=\"\".concat(t.toString(),\"\\n\").concat((0,a.parse)(e.stack).map(getFilesystemFrame).map((function(e){var n=\"    at \".concat(e.methodName);if(e.file){var t=e.file;if(e.lineNumber){t+=\":\".concat(e.lineNumber);if(e.column){t+=\":\".concat(e.column)}}n+=\" (\".concat(t,\")\")}return n})).join(\"\\n\"))}catch(n){t.stack=e.stack}decorateServerError(t,n);return t}n.getServerError=getServerError},910:function(e,n){n.__esModule=true;n.noop=void 0;function noop(e){var n=[];for(var t=1;t<arguments.length;t++){n[t-1]=arguments[t]}var r=e.length-1;return e.slice(0,r).reduce((function(e,t,r){return e+t+n[r]}),\"\")+e[r]}n.noop=noop},636:function(e,n,t){n.__esModule=true;n.parseStack=void 0;var r=t(974);var a=/\\/_next(\\/static\\/.+)/g;function parseStack(e){var n=(0,r.parse)(e);return n.map((function(e){var n,t;try{var r=new URL(e.file);var o=a.exec(r.pathname);if(o){var i=(t=(n=\"F:\\\\Git Projects\\\\gpt3-writer-starter\\\\.next\")===null||n===void 0?void 0:n.replace(/\\\\/g,\"/\"))===null||t===void 0?void 0:t.replace(/\\/$/,\"\");if(i){e.file=\"file://\"+i.concat(o.pop())}}}catch(e){}return e}))}n.parseStack=parseStack},504:function(e,n){var t=this&&this.__awaiter||function(e,n,t,r){function adopt(e){return e instanceof t?e:new t((function(n){n(e)}))}return new(t||(t=Promise))((function(t,a){function fulfilled(e){try{step(r.next(e))}catch(e){a(e)}}function rejected(e){try{step(r[\"throw\"](e))}catch(e){a(e)}}function step(e){e.done?t(e.value):adopt(e.value).then(fulfilled,rejected)}step((r=r.apply(e,n||[])).next())}))};var r=this&&this.__generator||function(e,n){var t={label:0,sent:function(){if(o[0]&1)throw o[1];return o[1]},trys:[],ops:[]},r,a,o,i;return i={next:verb(0),throw:verb(1),return:verb(2)},typeof Symbol===\"function\"&&(i[Symbol.iterator]=function(){return this}),i;function verb(e){return function(n){return step([e,n])}}function step(i){if(r)throw new TypeError(\"Generator is already executing.\");while(t)try{if(r=1,a&&(o=i[0]&2?a[\"return\"]:i[0]?a[\"throw\"]||((o=a[\"return\"])&&o.call(a),0):a.next)&&!(o=o.call(a,i[1])).done)return o;if(a=0,o)i=[i[0]&2,o.value];switch(i[0]){case 0:case 1:o=i;break;case 4:t.label++;return{value:i[1],done:false};case 5:t.label++;a=i[1];i=[0];continue;case 7:i=t.ops.pop();t.trys.pop();continue;default:if(!(o=t.trys,o=o.length>0&&o[o.length-1])&&(i[0]===6||i[0]===2)){t=0;continue}if(i[0]===3&&(!o||i[1]>o[0]&&i[1]<o[3])){t.label=i[1];break}if(i[0]===6&&t.label<o[1]){t.label=o[1];o=i;break}if(o&&t.label<o[2]){t.label=o[2];t.ops.push(i);break}if(o[2])t.ops.pop();t.trys.pop();continue}i=n.call(e,t)}catch(e){i=[6,e];a=0}finally{r=o=0}if(i[0]&5)throw i[1];return{value:i[0]?i[1]:void 0,done:true}}};n.__esModule=true;n.getFrameSource=n.getOriginalStackFrames=n.getOriginalStackFrame=void 0;function getOriginalStackFrame(e,n,a){var o,i;function _getOriginalStackFrame(){var o,i,l,s,u;return t(this,void 0,void 0,(function(){var t,c,f,d,v,p,m,b,g;return r(this,(function(r){switch(r.label){case 0:t=new URLSearchParams;t.append(\"isServer\",String(n===\"server\"));t.append(\"isEdgeServer\",String(n===\"edge-server\"));t.append(\"errorMessage\",a);for(c in e){t.append(c,((o=e[c])!==null&&o!==void 0?o:\"\").toString())}f=new AbortController;d=setTimeout((function(){return f.abort()}),3e3);return[4,self.fetch(\"\".concat( false||\"\",\"/__nextjs_original-stack-frame?\").concat(t.toString()),{signal:f.signal})[\"finally\"]((function(){clearTimeout(d)}))];case 1:v=r.sent();if(!(!v.ok||v.status===204))return[3,3];m=(p=Promise).reject;b=Error.bind;return[4,v.text()];case 2:return[2,m.apply(p,[new(b.apply(Error,[void 0,r.sent()]))])];case 3:return[4,v.json()];case 4:g=r.sent();return[2,{error:false,reason:null,external:false,expanded:!Boolean((u=((i=e.file)===null||i===void 0?void 0:i.includes(\"node_modules\"))||((s=(l=g.originalStackFrame)===null||l===void 0?void 0:l.file)===null||s===void 0?void 0:s.includes(\"node_modules\")))!==null&&u!==void 0?u:true),sourceStackFrame:e,originalStackFrame:g.originalStackFrame,originalCodeFrame:g.originalCodeFrame||null}]}}))}))}if(!(((o=e.file)===null||o===void 0?void 0:o.startsWith(\"webpack-internal:\"))||((i=e.file)===null||i===void 0?void 0:i.startsWith(\"file:\")))){return Promise.resolve({error:false,reason:null,external:true,expanded:false,sourceStackFrame:e,originalStackFrame:null,originalCodeFrame:null})}return _getOriginalStackFrame()[\"catch\"]((function(n){var t,r;return{error:true,reason:(r=(t=n===null||n===void 0?void 0:n.message)!==null&&t!==void 0?t:n===null||n===void 0?void 0:n.toString())!==null&&r!==void 0?r:\"Unknown Error\",external:false,expanded:false,sourceStackFrame:e,originalStackFrame:null,originalCodeFrame:null}}))}n.getOriginalStackFrame=getOriginalStackFrame;function getOriginalStackFrames(e,n,t){return Promise.all(e.map((function(e){return getOriginalStackFrame(e,n,t)})))}n.getOriginalStackFrames=getOriginalStackFrames;function getFrameSource(e){var n;var t=\"\";try{var r=new URL(e.file);if(typeof globalThis!==\"undefined\"&&((n=globalThis.location)===null||n===void 0?void 0:n.origin)!==r.origin){if(r.origin===\"null\"){t+=r.protocol}else{t+=r.origin}}t+=r.pathname;t+=\" \"}catch(n){t+=(e.file||\"(unknown)\")+\" \"}if(e.lineNumber!=null){if(e.column!=null){t+=\"(\".concat(e.lineNumber,\":\").concat(e.column,\") \")}else{t+=\"(\".concat(e.lineNumber,\") \")}}return t.slice(0,-1)}n.getFrameSource=getFrameSource},169:function(e,n,t){var r=this&&this.__createBinding||(Object.create?function(e,n,t,r){if(r===undefined)r=t;var a=Object.getOwnPropertyDescriptor(n,t);if(!a||(\"get\"in a?!n.__esModule:a.writable||a.configurable)){a={enumerable:true,get:function(){return n[t]}}}Object.defineProperty(e,r,a)}:function(e,n,t,r){if(r===undefined)r=t;e[r]=n[t]});var a=this&&this.__setModuleDefault||(Object.create?function(e,n){Object.defineProperty(e,\"default\",{enumerable:true,value:n})}:function(e,n){e[\"default\"]=n});var o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(e!=null)for(var t in e)if(t!==\"default\"&&Object.prototype.hasOwnProperty.call(e,t))r(n,e,t);a(n,e);return n};n.__esModule=true;n.useOnClickOutside=void 0;var i=o(t(522));function useOnClickOutside(e,n){i.useEffect((function(){if(e==null||n==null){return}var listener=function(t){if(!e||e.contains(t.target)){return}n(t)};var t=e.getRootNode();t.addEventListener(\"mousedown\",listener);t.addEventListener(\"touchstart\",listener);return function(){t.removeEventListener(\"mousedown\",listener);t.removeEventListener(\"touchstart\",listener)}}),[n,e])}n.useOnClickOutside=useOnClickOutside},865:function(e,n,t){var r=this&&this.__createBinding||(Object.create?function(e,n,t,r){if(r===undefined)r=t;var a=Object.getOwnPropertyDescriptor(n,t);if(!a||(\"get\"in a?!n.__esModule:a.writable||a.configurable)){a={enumerable:true,get:function(){return n[t]}}}Object.defineProperty(e,r,a)}:function(e,n,t,r){if(r===undefined)r=t;e[r]=n[t]});var a=this&&this.__setModuleDefault||(Object.create?function(e,n){Object.defineProperty(e,\"default\",{enumerable:true,value:n})}:function(e,n){e[\"default\"]=n});var o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(e!=null)for(var t in e)if(t!==\"default\"&&Object.prototype.hasOwnProperty.call(e,t))r(n,e,t);a(n,e);return n};n.__esModule=true;n.CloseIcon=void 0;var i=o(t(522));var CloseIcon=function(){return i.createElement(\"svg\",{width:\"24\",height:\"24\",viewBox:\"0 0 24 24\",fill:\"none\",xmlns:\"http://www.w3.org/2000/svg\"},i.createElement(\"path\",{d:\"M18 6L6 18\",stroke:\"currentColor\",strokeWidth:\"2\",strokeLinecap:\"round\",strokeLinejoin:\"round\"}),i.createElement(\"path\",{d:\"M6 6L18 18\",stroke:\"currentColor\",strokeWidth:\"2\",strokeLinecap:\"round\",strokeLinejoin:\"round\"}))};n.CloseIcon=CloseIcon},884:function(e,n,t){var r=this&&this.__makeTemplateObject||function(e,n){if(Object.defineProperty){Object.defineProperty(e,\"raw\",{value:n})}else{e.raw=n}return e};var a=this&&this.__createBinding||(Object.create?function(e,n,t,r){if(r===undefined)r=t;var a=Object.getOwnPropertyDescriptor(n,t);if(!a||(\"get\"in a?!n.__esModule:a.writable||a.configurable)){a={enumerable:true,get:function(){return n[t]}}}Object.defineProperty(e,r,a)}:function(e,n,t,r){if(r===undefined)r=t;e[r]=n[t]});var o=this&&this.__setModuleDefault||(Object.create?function(e,n){Object.defineProperty(e,\"default\",{enumerable:true,value:n})}:function(e,n){e[\"default\"]=n});var i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(e!=null)for(var t in e)if(t!==\"default\"&&Object.prototype.hasOwnProperty.call(e,t))a(n,e,t);o(n,e);return n};n.__esModule=true;n.Base=void 0;var l=i(t(522));var s=t(910);function Base(){return l.createElement(\"style\",null,(0,s.noop)(u||(u=r([\"\\n        :host {\\n          --size-gap-half: 4px;\\n          --size-gap: 8px;\\n          --size-gap-double: 16px;\\n          --size-gap-triple: 24px;\\n          --size-gap-quad: 32px;\\n\\n          --size-font-small: 14px;\\n          --size-font: 16px;\\n          --size-font-big: 20px;\\n          --size-font-bigger: 24px;\\n\\n          --color-accents-1: #808080;\\n          --color-accents-2: #222222;\\n          --color-accents-3: #404040;\\n\\n          --font-stack-monospace: 'SFMono-Regular', Consolas, 'Liberation Mono',\\n            Menlo, Courier, monospace;\\n\\n          --color-ansi-selection: rgba(95, 126, 151, 0.48);\\n          --color-ansi-bg: #111111;\\n          --color-ansi-fg: #cccccc;\\n\\n          --color-ansi-white: #777777;\\n          --color-ansi-black: #141414;\\n          --color-ansi-blue: #00aaff;\\n          --color-ansi-cyan: #88ddff;\\n          --color-ansi-green: #98ec65;\\n          --color-ansi-magenta: #aa88ff;\\n          --color-ansi-red: #ff5555;\\n          --color-ansi-yellow: #ffcc33;\\n          --color-ansi-bright-white: #ffffff;\\n          --color-ansi-bright-black: #777777;\\n          --color-ansi-bright-blue: #33bbff;\\n          --color-ansi-bright-cyan: #bbecff;\\n          --color-ansi-bright-green: #b6f292;\\n          --color-ansi-bright-magenta: #cebbff;\\n          --color-ansi-bright-red: #ff8888;\\n          --color-ansi-bright-yellow: #ffd966;\\n        }\\n\\n        .mono {\\n          font-family: var(--font-stack-monospace);\\n        }\\n\\n        h1,\\n        h2,\\n        h3,\\n        h4,\\n        h5,\\n        h6 {\\n          margin-bottom: var(--size-gap);\\n          font-weight: 500;\\n          line-height: 1.5;\\n        }\\n\\n        h1 {\\n          font-size: 40px;\\n        }\\n        h2 {\\n          font-size: 32px;\\n        }\\n        h3 {\\n          font-size: 28px;\\n        }\\n        h4 {\\n          font-size: 24px;\\n        }\\n        h5 {\\n          font-size: 20px;\\n        }\\n        h6 {\\n          font-size: 16px;\\n        }\\n      \"],[\"\\n        :host {\\n          --size-gap-half: 4px;\\n          --size-gap: 8px;\\n          --size-gap-double: 16px;\\n          --size-gap-triple: 24px;\\n          --size-gap-quad: 32px;\\n\\n          --size-font-small: 14px;\\n          --size-font: 16px;\\n          --size-font-big: 20px;\\n          --size-font-bigger: 24px;\\n\\n          --color-accents-1: #808080;\\n          --color-accents-2: #222222;\\n          --color-accents-3: #404040;\\n\\n          --font-stack-monospace: 'SFMono-Regular', Consolas, 'Liberation Mono',\\n            Menlo, Courier, monospace;\\n\\n          --color-ansi-selection: rgba(95, 126, 151, 0.48);\\n          --color-ansi-bg: #111111;\\n          --color-ansi-fg: #cccccc;\\n\\n          --color-ansi-white: #777777;\\n          --color-ansi-black: #141414;\\n          --color-ansi-blue: #00aaff;\\n          --color-ansi-cyan: #88ddff;\\n          --color-ansi-green: #98ec65;\\n          --color-ansi-magenta: #aa88ff;\\n          --color-ansi-red: #ff5555;\\n          --color-ansi-yellow: #ffcc33;\\n          --color-ansi-bright-white: #ffffff;\\n          --color-ansi-bright-black: #777777;\\n          --color-ansi-bright-blue: #33bbff;\\n          --color-ansi-bright-cyan: #bbecff;\\n          --color-ansi-bright-green: #b6f292;\\n          --color-ansi-bright-magenta: #cebbff;\\n          --color-ansi-bright-red: #ff8888;\\n          --color-ansi-bright-yellow: #ffd966;\\n        }\\n\\n        .mono {\\n          font-family: var(--font-stack-monospace);\\n        }\\n\\n        h1,\\n        h2,\\n        h3,\\n        h4,\\n        h5,\\n        h6 {\\n          margin-bottom: var(--size-gap);\\n          font-weight: 500;\\n          line-height: 1.5;\\n        }\\n\\n        h1 {\\n          font-size: 40px;\\n        }\\n        h2 {\\n          font-size: 32px;\\n        }\\n        h3 {\\n          font-size: 28px;\\n        }\\n        h4 {\\n          font-size: 24px;\\n        }\\n        h5 {\\n          font-size: 20px;\\n        }\\n        h6 {\\n          font-size: 16px;\\n        }\\n      \"]))))}n.Base=Base;var u},464:function(e,n,t){var r=this&&this.__makeTemplateObject||function(e,n){if(Object.defineProperty){Object.defineProperty(e,\"raw\",{value:n})}else{e.raw=n}return e};var a=this&&this.__createBinding||(Object.create?function(e,n,t,r){if(r===undefined)r=t;var a=Object.getOwnPropertyDescriptor(n,t);if(!a||(\"get\"in a?!n.__esModule:a.writable||a.configurable)){a={enumerable:true,get:function(){return n[t]}}}Object.defineProperty(e,r,a)}:function(e,n,t,r){if(r===undefined)r=t;e[r]=n[t]});var o=this&&this.__setModuleDefault||(Object.create?function(e,n){Object.defineProperty(e,\"default\",{enumerable:true,value:n})}:function(e,n){e[\"default\"]=n});var i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(e!=null)for(var t in e)if(t!==\"default\"&&Object.prototype.hasOwnProperty.call(e,t))a(n,e,t);o(n,e);return n};n.__esModule=true;n.ComponentStyles=void 0;var l=i(t(522));var s=t(399);var u=t(651);var c=t(543);var f=t(993);var d=t(488);var v=t(120);var p=t(936);var m=t(355);var b=t(484);var g=t(910);function ComponentStyles(){return l.createElement(\"style\",null,(0,g.noop)(h||(h=r([\"\\n        \",\"\\n        \",\"\\n        \",\"\\n        \",\"\\n        \",\"\\n        \",\"\\n        \\n        \",\"\\n        \",\"\\n        \",\"\\n      \"],[\"\\n        \",\"\\n        \",\"\\n        \",\"\\n        \",\"\\n        \",\"\\n        \",\"\\n        \\n        \",\"\\n        \",\"\\n        \",\"\\n      \"])),f.styles,v.styles,u.styles,c.styles,s.styles,d.styles,p.styles,m.styles,b.styles))}n.ComponentStyles=ComponentStyles;var h},495:function(e,n,t){var r=this&&this.__makeTemplateObject||function(e,n){if(Object.defineProperty){Object.defineProperty(e,\"raw\",{value:n})}else{e.raw=n}return e};var a=this&&this.__createBinding||(Object.create?function(e,n,t,r){if(r===undefined)r=t;var a=Object.getOwnPropertyDescriptor(n,t);if(!a||(\"get\"in a?!n.__esModule:a.writable||a.configurable)){a={enumerable:true,get:function(){return n[t]}}}Object.defineProperty(e,r,a)}:function(e,n,t,r){if(r===undefined)r=t;e[r]=n[t]});var o=this&&this.__setModuleDefault||(Object.create?function(e,n){Object.defineProperty(e,\"default\",{enumerable:true,value:n})}:function(e,n){e[\"default\"]=n});var i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(e!=null)for(var t in e)if(t!==\"default\"&&Object.prototype.hasOwnProperty.call(e,t))a(n,e,t);o(n,e);return n};n.__esModule=true;n.CssReset=void 0;var l=i(t(522));var s=t(910);function CssReset(){return l.createElement(\"style\",null,(0,s.noop)(u||(u=r([\"\\n        :host {\\n          all: initial;\\n\\n          /* the direction property is not reset by 'all' */\\n          direction: ltr;\\n        }\\n\\n        /*!\\n         * Bootstrap Reboot v4.4.1 (https://getbootstrap.com/)\\n         * Copyright 2011-2019 The Bootstrap Authors\\n         * Copyright 2011-2019 Twitter, Inc.\\n         * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n         * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md)\\n         */\\n        *,\\n        *::before,\\n        *::after {\\n          box-sizing: border-box;\\n        }\\n\\n        :host {\\n          font-family: sans-serif;\\n          line-height: 1.15;\\n          -webkit-text-size-adjust: 100%;\\n          -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\\n        }\\n\\n        article,\\n        aside,\\n        figcaption,\\n        figure,\\n        footer,\\n        header,\\n        hgroup,\\n        main,\\n        nav,\\n        section {\\n          display: block;\\n        }\\n\\n        :host {\\n          margin: 0;\\n          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,\\n            'Helvetica Neue', Arial, 'Noto Sans', sans-serif,\\n            'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',\\n            'Noto Color Emoji';\\n          font-size: 16px;\\n          font-weight: 400;\\n          line-height: 1.5;\\n          color: #212529;\\n          text-align: left;\\n          background-color: #fff;\\n        }\\n\\n        [tabindex='-1']:focus:not(:focus-visible) {\\n          outline: 0 !important;\\n        }\\n\\n        hr {\\n          box-sizing: content-box;\\n          height: 0;\\n          overflow: visible;\\n        }\\n\\n        h1,\\n        h2,\\n        h3,\\n        h4,\\n        h5,\\n        h6 {\\n          margin-top: 0;\\n          margin-bottom: 8px;\\n        }\\n\\n        p {\\n          margin-top: 0;\\n          margin-bottom: 16px;\\n        }\\n\\n        abbr[title],\\n        abbr[data-original-title] {\\n          text-decoration: underline;\\n          -webkit-text-decoration: underline dotted;\\n          text-decoration: underline dotted;\\n          cursor: help;\\n          border-bottom: 0;\\n          -webkit-text-decoration-skip-ink: none;\\n          text-decoration-skip-ink: none;\\n        }\\n\\n        address {\\n          margin-bottom: 16px;\\n          font-style: normal;\\n          line-height: inherit;\\n        }\\n\\n        ol,\\n        ul,\\n        dl {\\n          margin-top: 0;\\n          margin-bottom: 16px;\\n        }\\n\\n        ol ol,\\n        ul ul,\\n        ol ul,\\n        ul ol {\\n          margin-bottom: 0;\\n        }\\n\\n        dt {\\n          font-weight: 700;\\n        }\\n\\n        dd {\\n          margin-bottom: 8px;\\n          margin-left: 0;\\n        }\\n\\n        blockquote {\\n          margin: 0 0 16px;\\n        }\\n\\n        b,\\n        strong {\\n          font-weight: bolder;\\n        }\\n\\n        small {\\n          font-size: 80%;\\n        }\\n\\n        sub,\\n        sup {\\n          position: relative;\\n          font-size: 75%;\\n          line-height: 0;\\n          vertical-align: baseline;\\n        }\\n\\n        sub {\\n          bottom: -0.25em;\\n        }\\n\\n        sup {\\n          top: -0.5em;\\n        }\\n\\n        a {\\n          color: #007bff;\\n          text-decoration: none;\\n          background-color: transparent;\\n        }\\n\\n        a:hover {\\n          color: #0056b3;\\n          text-decoration: underline;\\n        }\\n\\n        a:not([href]) {\\n          color: inherit;\\n          text-decoration: none;\\n        }\\n\\n        a:not([href]):hover {\\n          color: inherit;\\n          text-decoration: none;\\n        }\\n\\n        pre,\\n        code,\\n        kbd,\\n        samp {\\n          font-family: SFMono-Regular, Menlo, Monaco, Consolas,\\n            'Liberation Mono', 'Courier New', monospace;\\n          font-size: 1em;\\n        }\\n\\n        pre {\\n          margin-top: 0;\\n          margin-bottom: 16px;\\n          overflow: auto;\\n        }\\n\\n        figure {\\n          margin: 0 0 16px;\\n        }\\n\\n        img {\\n          vertical-align: middle;\\n          border-style: none;\\n        }\\n\\n        svg {\\n          overflow: hidden;\\n          vertical-align: middle;\\n        }\\n\\n        table {\\n          border-collapse: collapse;\\n        }\\n\\n        caption {\\n          padding-top: 12px;\\n          padding-bottom: 12px;\\n          color: #6c757d;\\n          text-align: left;\\n          caption-side: bottom;\\n        }\\n\\n        th {\\n          text-align: inherit;\\n        }\\n\\n        label {\\n          display: inline-block;\\n          margin-bottom: 8px;\\n        }\\n\\n        button {\\n          border-radius: 0;\\n        }\\n\\n        button:focus {\\n          outline: 1px dotted;\\n          outline: 5px auto -webkit-focus-ring-color;\\n        }\\n\\n        input,\\n        button,\\n        select,\\n        optgroup,\\n        textarea {\\n          margin: 0;\\n          font-family: inherit;\\n          font-size: inherit;\\n          line-height: inherit;\\n        }\\n\\n        button,\\n        input {\\n          overflow: visible;\\n        }\\n\\n        button,\\n        select {\\n          text-transform: none;\\n        }\\n\\n        select {\\n          word-wrap: normal;\\n        }\\n\\n        button,\\n        [type='button'],\\n        [type='reset'],\\n        [type='submit'] {\\n          -webkit-appearance: button;\\n        }\\n\\n        button:not(:disabled),\\n        [type='button']:not(:disabled),\\n        [type='reset']:not(:disabled),\\n        [type='submit']:not(:disabled) {\\n          cursor: pointer;\\n        }\\n\\n        button::-moz-focus-inner,\\n        [type='button']::-moz-focus-inner,\\n        [type='reset']::-moz-focus-inner,\\n        [type='submit']::-moz-focus-inner {\\n          padding: 0;\\n          border-style: none;\\n        }\\n\\n        input[type='radio'],\\n        input[type='checkbox'] {\\n          box-sizing: border-box;\\n          padding: 0;\\n        }\\n\\n        input[type='date'],\\n        input[type='time'],\\n        input[type='datetime-local'],\\n        input[type='month'] {\\n          -webkit-appearance: listbox;\\n        }\\n\\n        textarea {\\n          overflow: auto;\\n          resize: vertical;\\n        }\\n\\n        fieldset {\\n          min-width: 0;\\n          padding: 0;\\n          margin: 0;\\n          border: 0;\\n        }\\n\\n        legend {\\n          display: block;\\n          width: 100%;\\n          max-width: 100%;\\n          padding: 0;\\n          margin-bottom: 8px;\\n          font-size: 24px;\\n          line-height: inherit;\\n          color: inherit;\\n          white-space: normal;\\n        }\\n\\n        progress {\\n          vertical-align: baseline;\\n        }\\n\\n        [type='number']::-webkit-inner-spin-button,\\n        [type='number']::-webkit-outer-spin-button {\\n          height: auto;\\n        }\\n\\n        [type='search'] {\\n          outline-offset: -2px;\\n          -webkit-appearance: none;\\n        }\\n\\n        [type='search']::-webkit-search-decoration {\\n          -webkit-appearance: none;\\n        }\\n\\n        ::-webkit-file-upload-button {\\n          font: inherit;\\n          -webkit-appearance: button;\\n        }\\n\\n        output {\\n          display: inline-block;\\n        }\\n\\n        summary {\\n          display: list-item;\\n          cursor: pointer;\\n        }\\n\\n        template {\\n          display: none;\\n        }\\n\\n        [hidden] {\\n          display: none !important;\\n        }\\n      \"],[\"\\n        :host {\\n          all: initial;\\n\\n          /* the direction property is not reset by 'all' */\\n          direction: ltr;\\n        }\\n\\n        /*!\\n         * Bootstrap Reboot v4.4.1 (https://getbootstrap.com/)\\n         * Copyright 2011-2019 The Bootstrap Authors\\n         * Copyright 2011-2019 Twitter, Inc.\\n         * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n         * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md)\\n         */\\n        *,\\n        *::before,\\n        *::after {\\n          box-sizing: border-box;\\n        }\\n\\n        :host {\\n          font-family: sans-serif;\\n          line-height: 1.15;\\n          -webkit-text-size-adjust: 100%;\\n          -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\\n        }\\n\\n        article,\\n        aside,\\n        figcaption,\\n        figure,\\n        footer,\\n        header,\\n        hgroup,\\n        main,\\n        nav,\\n        section {\\n          display: block;\\n        }\\n\\n        :host {\\n          margin: 0;\\n          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,\\n            'Helvetica Neue', Arial, 'Noto Sans', sans-serif,\\n            'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',\\n            'Noto Color Emoji';\\n          font-size: 16px;\\n          font-weight: 400;\\n          line-height: 1.5;\\n          color: #212529;\\n          text-align: left;\\n          background-color: #fff;\\n        }\\n\\n        [tabindex='-1']:focus:not(:focus-visible) {\\n          outline: 0 !important;\\n        }\\n\\n        hr {\\n          box-sizing: content-box;\\n          height: 0;\\n          overflow: visible;\\n        }\\n\\n        h1,\\n        h2,\\n        h3,\\n        h4,\\n        h5,\\n        h6 {\\n          margin-top: 0;\\n          margin-bottom: 8px;\\n        }\\n\\n        p {\\n          margin-top: 0;\\n          margin-bottom: 16px;\\n        }\\n\\n        abbr[title],\\n        abbr[data-original-title] {\\n          text-decoration: underline;\\n          -webkit-text-decoration: underline dotted;\\n          text-decoration: underline dotted;\\n          cursor: help;\\n          border-bottom: 0;\\n          -webkit-text-decoration-skip-ink: none;\\n          text-decoration-skip-ink: none;\\n        }\\n\\n        address {\\n          margin-bottom: 16px;\\n          font-style: normal;\\n          line-height: inherit;\\n        }\\n\\n        ol,\\n        ul,\\n        dl {\\n          margin-top: 0;\\n          margin-bottom: 16px;\\n        }\\n\\n        ol ol,\\n        ul ul,\\n        ol ul,\\n        ul ol {\\n          margin-bottom: 0;\\n        }\\n\\n        dt {\\n          font-weight: 700;\\n        }\\n\\n        dd {\\n          margin-bottom: 8px;\\n          margin-left: 0;\\n        }\\n\\n        blockquote {\\n          margin: 0 0 16px;\\n        }\\n\\n        b,\\n        strong {\\n          font-weight: bolder;\\n        }\\n\\n        small {\\n          font-size: 80%;\\n        }\\n\\n        sub,\\n        sup {\\n          position: relative;\\n          font-size: 75%;\\n          line-height: 0;\\n          vertical-align: baseline;\\n        }\\n\\n        sub {\\n          bottom: -0.25em;\\n        }\\n\\n        sup {\\n          top: -0.5em;\\n        }\\n\\n        a {\\n          color: #007bff;\\n          text-decoration: none;\\n          background-color: transparent;\\n        }\\n\\n        a:hover {\\n          color: #0056b3;\\n          text-decoration: underline;\\n        }\\n\\n        a:not([href]) {\\n          color: inherit;\\n          text-decoration: none;\\n        }\\n\\n        a:not([href]):hover {\\n          color: inherit;\\n          text-decoration: none;\\n        }\\n\\n        pre,\\n        code,\\n        kbd,\\n        samp {\\n          font-family: SFMono-Regular, Menlo, Monaco, Consolas,\\n            'Liberation Mono', 'Courier New', monospace;\\n          font-size: 1em;\\n        }\\n\\n        pre {\\n          margin-top: 0;\\n          margin-bottom: 16px;\\n          overflow: auto;\\n        }\\n\\n        figure {\\n          margin: 0 0 16px;\\n        }\\n\\n        img {\\n          vertical-align: middle;\\n          border-style: none;\\n        }\\n\\n        svg {\\n          overflow: hidden;\\n          vertical-align: middle;\\n        }\\n\\n        table {\\n          border-collapse: collapse;\\n        }\\n\\n        caption {\\n          padding-top: 12px;\\n          padding-bottom: 12px;\\n          color: #6c757d;\\n          text-align: left;\\n          caption-side: bottom;\\n        }\\n\\n        th {\\n          text-align: inherit;\\n        }\\n\\n        label {\\n          display: inline-block;\\n          margin-bottom: 8px;\\n        }\\n\\n        button {\\n          border-radius: 0;\\n        }\\n\\n        button:focus {\\n          outline: 1px dotted;\\n          outline: 5px auto -webkit-focus-ring-color;\\n        }\\n\\n        input,\\n        button,\\n        select,\\n        optgroup,\\n        textarea {\\n          margin: 0;\\n          font-family: inherit;\\n          font-size: inherit;\\n          line-height: inherit;\\n        }\\n\\n        button,\\n        input {\\n          overflow: visible;\\n        }\\n\\n        button,\\n        select {\\n          text-transform: none;\\n        }\\n\\n        select {\\n          word-wrap: normal;\\n        }\\n\\n        button,\\n        [type='button'],\\n        [type='reset'],\\n        [type='submit'] {\\n          -webkit-appearance: button;\\n        }\\n\\n        button:not(:disabled),\\n        [type='button']:not(:disabled),\\n        [type='reset']:not(:disabled),\\n        [type='submit']:not(:disabled) {\\n          cursor: pointer;\\n        }\\n\\n        button::-moz-focus-inner,\\n        [type='button']::-moz-focus-inner,\\n        [type='reset']::-moz-focus-inner,\\n        [type='submit']::-moz-focus-inner {\\n          padding: 0;\\n          border-style: none;\\n        }\\n\\n        input[type='radio'],\\n        input[type='checkbox'] {\\n          box-sizing: border-box;\\n          padding: 0;\\n        }\\n\\n        input[type='date'],\\n        input[type='time'],\\n        input[type='datetime-local'],\\n        input[type='month'] {\\n          -webkit-appearance: listbox;\\n        }\\n\\n        textarea {\\n          overflow: auto;\\n          resize: vertical;\\n        }\\n\\n        fieldset {\\n          min-width: 0;\\n          padding: 0;\\n          margin: 0;\\n          border: 0;\\n        }\\n\\n        legend {\\n          display: block;\\n          width: 100%;\\n          max-width: 100%;\\n          padding: 0;\\n          margin-bottom: 8px;\\n          font-size: 24px;\\n          line-height: inherit;\\n          color: inherit;\\n          white-space: normal;\\n        }\\n\\n        progress {\\n          vertical-align: baseline;\\n        }\\n\\n        [type='number']::-webkit-inner-spin-button,\\n        [type='number']::-webkit-outer-spin-button {\\n          height: auto;\\n        }\\n\\n        [type='search'] {\\n          outline-offset: -2px;\\n          -webkit-appearance: none;\\n        }\\n\\n        [type='search']::-webkit-search-decoration {\\n          -webkit-appearance: none;\\n        }\\n\\n        ::-webkit-file-upload-button {\\n          font: inherit;\\n          -webkit-appearance: button;\\n        }\\n\\n        output {\\n          display: inline-block;\\n        }\\n\\n        summary {\\n          display: list-item;\\n          cursor: pointer;\\n        }\\n\\n        template {\\n          display: none;\\n        }\\n\\n        [hidden] {\\n          display: none !important;\\n        }\\n      \"]))))}n.CssReset=CssReset;var u},997:function(e){e.exports=__webpack_require__(/*! next/dist/compiled/anser */ \"./node_modules/next/dist/compiled/anser/index.js\")},292:function(e){e.exports=__webpack_require__(/*! next/dist/compiled/css.escape */ \"./node_modules/next/dist/compiled/css.escape/css.escape.js\")},709:function(e){e.exports=__webpack_require__(/*! next/dist/compiled/platform */ \"./node_modules/next/dist/compiled/platform/platform.js\")},974:function(e){e.exports=__webpack_require__(/*! next/dist/compiled/stacktrace-parser */ \"./node_modules/next/dist/compiled/stacktrace-parser/stack-trace-parser.cjs.js\")},518:function(e){e.exports=__webpack_require__(/*! next/dist/compiled/strip-ansi */ \"./node_modules/next/dist/compiled/strip-ansi/index.js\")},522:function(e){e.exports=__webpack_require__(/*! react */ \"./node_modules/react/index.js\")},255:function(e){e.exports=__webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\")}};var n={};function __nccwpck_require__(t){var r=n[t];if(r!==undefined){return r.exports}var a=n[t]={exports:{}};var o=true;try{e[t].call(a.exports,a,a.exports,__nccwpck_require__);o=false}finally{if(o)delete n[t]}return a.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(204);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2Rpc3QvY2xpZW50LmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLGFBQWEsT0FBTyxvQkFBb0IsbUVBQW1FLHFCQUFxQiwyQ0FBMkMsNkRBQTZELEdBQUcsK0JBQStCLGNBQWMsNkJBQTZCLG1CQUFtQixxQkFBcUIsVUFBVSxFQUFFLGtFQUFrRSxtQ0FBbUMsd0JBQXdCLEVBQUUsZUFBZSxlQUFlLEVBQUUsMkNBQTJDLDRCQUE0QixTQUFTLCtGQUErRixPQUFPLFVBQVUsa0JBQWtCLDRJQUE0SSxnQkFBZ0IsYUFBYSxZQUFZLGdCQUFnQiw2QkFBNkIsMENBQTBDLHlEQUF5RCxPQUFPLHlFQUF5RSw0RkFBNEYsUUFBUSxRQUFRLHNFQUFzRSxFQUFFLGlDQUFpQywyQ0FBMkMseURBQXlELE9BQU8sUUFBUSxRQUFRLDBFQUEwRSxFQUFFLG9CQUFvQixNQUFNLE9BQU8sT0FBTyxJQUFJLDRCQUE0Qix5QkFBeUIsSUFBSSxVQUFVLGtEQUFrRCxtRUFBbUUsb0JBQW9CLHNCQUFzQixPQUFPLE9BQU8sUUFBUSxrQkFBa0IsSUFBSSx3QkFBd0IsVUFBVSxZQUFZLHFEQUFxRCxzRUFBc0Usd0JBQXdCLHFCQUFxQixRQUFRLHFCQUFxQixFQUFFLHNCQUFzQix5QkFBeUIsUUFBUSxrQ0FBa0MsRUFBRSw0QkFBNEIscUJBQXFCLFFBQVEsb0JBQW9CLEVBQUUsc0JBQXNCLDJCQUEyQixRQUFRLDJCQUEyQixFQUFFLGtDQUFrQyxhQUFhLHdCQUF3QixhQUFhLHdCQUF3QixhQUFhLG1DQUFtQyxxQkFBcUIsdUNBQXVDLGdDQUFnQyxzQ0FBc0MsYUFBYSxnQ0FBZ0MsY0FBYyxnQkFBZ0IsdUVBQXVFLDJCQUEyQixxQkFBcUIseUhBQXlILG1CQUFtQixjQUFjLG1CQUFtQix5RUFBeUUsR0FBRyw4Q0FBOEMsMEJBQTBCLFlBQVksa0JBQWtCLHVCQUF1QixnQkFBZ0Isa0JBQWtC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LFVBQVUsbUJBQU8sQ0FBQyw0RkFBK0IsRUFBRSxpQkFBaUIsVUFBVSxtQkFBTyxDQUFDLDRDQUFPLEVBQUUsaUJBQWlCLFVBQVUsbUJBQU8sQ0FBQyxvREFBVyxJQUFJLFNBQVMsZ0NBQWdDLFdBQVcsa0JBQWtCLGlCQUFpQixZQUFZLFlBQVksV0FBVyxJQUFJLHFEQUFxRCxRQUFRLFFBQVEsaUJBQWlCLGlCQUFpQixtRUFBbUUsU0FBUyxLQUFLLCtCQUErQixpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9kaXN0L2NsaWVudC5qcz80ZDMwIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3ZhciBlPXsyMDQ6ZnVuY3Rpb24oZSxuLHQpe3ZhciByPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLG4sdCxyKXtpZihyPT09dW5kZWZpbmVkKXI9dDt2YXIgYT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sdCk7aWYoIWF8fChcImdldFwiaW4gYT8hbi5fX2VzTW9kdWxlOmEud3JpdGFibGV8fGEuY29uZmlndXJhYmxlKSl7YT17ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBuW3RdfX19T2JqZWN0LmRlZmluZVByb3BlcnR5KGUscixhKX06ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7ZVtyXT1uW3RdfSk7dmFyIGE9dGhpcyYmdGhpcy5fX3NldE1vZHVsZURlZmF1bHR8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6dHJ1ZSx2YWx1ZTpufSl9OmZ1bmN0aW9uKGUsbil7ZVtcImRlZmF1bHRcIl09bn0pO3ZhciBvPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIG49e307aWYoZSE9bnVsbClmb3IodmFyIHQgaW4gZSlpZih0IT09XCJkZWZhdWx0XCImJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpKXIobixlLHQpO2EobixlKTtyZXR1cm4gbn07bi5fX2VzTW9kdWxlPXRydWU7bi5vblJlZnJlc2g9bi5vbkJlZm9yZVJlZnJlc2g9bi51bnJlZ2lzdGVyPW4ucmVnaXN0ZXI9bi5vbkJ1aWxkRXJyb3I9bi5vbkJ1aWxkT2s9bi5SZWFjdERldk92ZXJsYXk9bi5nZXRTZXJ2ZXJFcnJvcj1uLmdldEVycm9yQnlUeXBlPXZvaWQgMDt2YXIgaT1vKHQoODUxKSk7dmFyIGw9dCg2MzYpO3ZhciBzPWZhbHNlO3ZhciB1PXVuZGVmaW5lZDtmdW5jdGlvbiBvblVuaGFuZGxlZEVycm9yKGUpe3ZhciBuPWU9PT1udWxsfHxlPT09dm9pZCAwP3ZvaWQgMDplLmVycm9yO2lmKCFufHwhKG4gaW5zdGFuY2VvZiBFcnJvcil8fHR5cGVvZiBuLnN0YWNrIT09XCJzdHJpbmdcIil7cmV0dXJufWlmKG4ubWVzc2FnZS5tYXRjaCgvKGh5ZHJhdGlvbnxjb250ZW50IGRvZXMgbm90IG1hdGNofGRpZCBub3QgbWF0Y2gpL2kpKXtuLm1lc3NhZ2UrPVwiXFxuXFxuU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9yZWFjdC1oeWRyYXRpb24tZXJyb3JcIn12YXIgdD1uO2kuZW1pdCh7dHlwZTppLlRZUEVfVU5IQU5ETEVEX0VSUk9SLHJlYXNvbjpuLGZyYW1lczooMCxsLnBhcnNlU3RhY2spKHQuc3RhY2spfSl9ZnVuY3Rpb24gb25VbmhhbmRsZWRSZWplY3Rpb24oZSl7dmFyIG49ZT09PW51bGx8fGU9PT12b2lkIDA/dm9pZCAwOmUucmVhc29uO2lmKCFufHwhKG4gaW5zdGFuY2VvZiBFcnJvcil8fHR5cGVvZiBuLnN0YWNrIT09XCJzdHJpbmdcIil7cmV0dXJufXZhciB0PW47aS5lbWl0KHt0eXBlOmkuVFlQRV9VTkhBTkRMRURfUkVKRUNUSU9OLHJlYXNvbjpuLGZyYW1lczooMCxsLnBhcnNlU3RhY2spKHQuc3RhY2spfSl9ZnVuY3Rpb24gcmVnaXN0ZXIoKXtpZihzKXtyZXR1cm59cz10cnVlO3RyeXt2YXIgZT1FcnJvci5zdGFja1RyYWNlTGltaXQ7RXJyb3Iuc3RhY2tUcmFjZUxpbWl0PTUwO3U9ZX1jYXRjaChlKXt9d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLG9uVW5oYW5kbGVkRXJyb3IpO3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidW5oYW5kbGVkcmVqZWN0aW9uXCIsb25VbmhhbmRsZWRSZWplY3Rpb24pfW4ucmVnaXN0ZXI9cmVnaXN0ZXI7ZnVuY3Rpb24gdW5yZWdpc3Rlcigpe2lmKCFzKXtyZXR1cm59cz1mYWxzZTtpZih1IT09dW5kZWZpbmVkKXt0cnl7RXJyb3Iuc3RhY2tUcmFjZUxpbWl0PXV9Y2F0Y2goZSl7fXU9dW5kZWZpbmVkfXdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIixvblVuaGFuZGxlZEVycm9yKTt3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInVuaGFuZGxlZHJlamVjdGlvblwiLG9uVW5oYW5kbGVkUmVqZWN0aW9uKX1uLnVucmVnaXN0ZXI9dW5yZWdpc3RlcjtmdW5jdGlvbiBvbkJ1aWxkT2soKXtpLmVtaXQoe3R5cGU6aS5UWVBFX0JVSUxEX09LfSl9bi5vbkJ1aWxkT2s9b25CdWlsZE9rO2Z1bmN0aW9uIG9uQnVpbGRFcnJvcihlKXtpLmVtaXQoe3R5cGU6aS5UWVBFX0JVSUxEX0VSUk9SLG1lc3NhZ2U6ZX0pfW4ub25CdWlsZEVycm9yPW9uQnVpbGRFcnJvcjtmdW5jdGlvbiBvblJlZnJlc2goKXtpLmVtaXQoe3R5cGU6aS5UWVBFX1JFRlJFU0h9KX1uLm9uUmVmcmVzaD1vblJlZnJlc2g7ZnVuY3Rpb24gb25CZWZvcmVSZWZyZXNoKCl7aS5lbWl0KHt0eXBlOmkuVFlQRV9CRUZPUkVfUkVGUkVTSH0pfW4ub25CZWZvcmVSZWZyZXNoPW9uQmVmb3JlUmVmcmVzaDt2YXIgYz10KDQwMyk7cihuLGMsXCJnZXRFcnJvckJ5VHlwZVwiKTt2YXIgZj10KDIzMyk7cihuLGYsXCJnZXRTZXJ2ZXJFcnJvclwiKTt2YXIgZD10KDIyMik7cihuLGQsXCJkZWZhdWx0XCIsXCJSZWFjdERldk92ZXJsYXlcIil9LDc5MDpmdW5jdGlvbihlLG4sdCl7dmFyIHI9dGhpcyYmdGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKCl7dmFyIGV4dGVuZFN0YXRpY3M9ZnVuY3Rpb24oZSxuKXtleHRlbmRTdGF0aWNzPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihlLG4pe2UuX19wcm90b19fPW59fHxmdW5jdGlvbihlLG4pe2Zvcih2YXIgdCBpbiBuKWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLHQpKWVbdF09blt0XX07cmV0dXJuIGV4dGVuZFN0YXRpY3MoZSxuKX07cmV0dXJuIGZ1bmN0aW9uKGUsbil7aWYodHlwZW9mIG4hPT1cImZ1bmN0aW9uXCImJm4hPT1udWxsKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiK1N0cmluZyhuKStcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO2V4dGVuZFN0YXRpY3MoZSxuKTtmdW5jdGlvbiBfXygpe3RoaXMuY29uc3RydWN0b3I9ZX1lLnByb3RvdHlwZT1uPT09bnVsbD9PYmplY3QuY3JlYXRlKG4pOihfXy5wcm90b3R5cGU9bi5wcm90b3R5cGUsbmV3IF9fKX19KCk7dmFyIGE9dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX07bi5fX2VzTW9kdWxlPXRydWU7bi5FcnJvckJvdW5kYXJ5PXZvaWQgMDt2YXIgbz1hKHQoNTIyKSk7dmFyIGk9ZnVuY3Rpb24oZSl7cihFcnJvckJvdW5kYXJ5LGUpO2Z1bmN0aW9uIEVycm9yQm91bmRhcnkoKXt2YXIgbj1lIT09bnVsbCYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXM7bi5zdGF0ZT17ZXJyb3I6bnVsbH07cmV0dXJuIG59RXJyb3JCb3VuZGFyeS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I9ZnVuY3Rpb24oZSl7cmV0dXJue2Vycm9yOmV9fTtFcnJvckJvdW5kYXJ5LnByb3RvdHlwZS5jb21wb25lbnREaWRDYXRjaD1mdW5jdGlvbihlLG4pe3RoaXMucHJvcHMub25FcnJvcihlLChuPT09bnVsbHx8bj09PXZvaWQgMD92b2lkIDA6bi5jb21wb25lbnRTdGFjayl8fG51bGwpO2lmKCF0aGlzLnByb3BzLmdsb2JhbE92ZXJsYXkpe3RoaXMuc2V0U3RhdGUoe2Vycm9yOmV9KX19O0Vycm9yQm91bmRhcnkucHJvdG90eXBlLnJlbmRlcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXRlLmVycm9yfHx0aGlzLnByb3BzLmdsb2JhbE92ZXJsYXkmJnRoaXMucHJvcHMuaXNNb3VudGVkP3RoaXMucHJvcHMuZ2xvYmFsT3ZlcmxheT9vW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiaHRtbFwiLG51bGwsb1tcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImhlYWRcIixudWxsKSxvW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiYm9keVwiLG51bGwpKTpudWxsOnRoaXMucHJvcHMuY2hpbGRyZW59O3JldHVybiBFcnJvckJvdW5kYXJ5fShvW1wiZGVmYXVsdFwiXS5QdXJlQ29tcG9uZW50KTtuLkVycm9yQm91bmRhcnk9aX0sMjIyOmZ1bmN0aW9uKGUsbix0KXt2YXIgcj10aGlzJiZ0aGlzLl9fYXNzaWdufHxmdW5jdGlvbigpe3I9T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24oZSl7Zm9yKHZhciBuLHQ9MSxyPWFyZ3VtZW50cy5sZW5ndGg7dDxyO3QrKyl7bj1hcmd1bWVudHNbdF07Zm9yKHZhciBhIGluIG4paWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sYSkpZVthXT1uW2FdfXJldHVybiBlfTtyZXR1cm4gci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3ZhciBhPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLG4sdCxyKXtpZihyPT09dW5kZWZpbmVkKXI9dDt2YXIgYT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sdCk7aWYoIWF8fChcImdldFwiaW4gYT8hbi5fX2VzTW9kdWxlOmEud3JpdGFibGV8fGEuY29uZmlndXJhYmxlKSl7YT17ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBuW3RdfX19T2JqZWN0LmRlZmluZVByb3BlcnR5KGUscixhKX06ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7ZVtyXT1uW3RdfSk7dmFyIG89dGhpcyYmdGhpcy5fX3NldE1vZHVsZURlZmF1bHR8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6dHJ1ZSx2YWx1ZTpufSl9OmZ1bmN0aW9uKGUsbil7ZVtcImRlZmF1bHRcIl09bn0pO3ZhciBpPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIG49e307aWYoZSE9bnVsbClmb3IodmFyIHQgaW4gZSlpZih0IT09XCJkZWZhdWx0XCImJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpKWEobixlLHQpO28obixlKTtyZXR1cm4gbn07dmFyIGw9dGhpcyYmdGhpcy5fX3JlYWR8fGZ1bmN0aW9uKGUsbil7dmFyIHQ9dHlwZW9mIFN5bWJvbD09PVwiZnVuY3Rpb25cIiYmZVtTeW1ib2wuaXRlcmF0b3JdO2lmKCF0KXJldHVybiBlO3ZhciByPXQuY2FsbChlKSxhLG89W10saTt0cnl7d2hpbGUoKG49PT12b2lkIDB8fG4tLSA+MCkmJiEoYT1yLm5leHQoKSkuZG9uZSlvLnB1c2goYS52YWx1ZSl9Y2F0Y2goZSl7aT17ZXJyb3I6ZX19ZmluYWxseXt0cnl7aWYoYSYmIWEuZG9uZSYmKHQ9cltcInJldHVyblwiXSkpdC5jYWxsKHIpfWZpbmFsbHl7aWYoaSl0aHJvdyBpLmVycm9yfX1yZXR1cm4gb307dmFyIHM9dGhpcyYmdGhpcy5fX3NwcmVhZEFycmF5fHxmdW5jdGlvbihlLG4sdCl7aWYodHx8YXJndW1lbnRzLmxlbmd0aD09PTIpZm9yKHZhciByPTAsYT1uLmxlbmd0aCxvO3I8YTtyKyspe2lmKG98fCEociBpbiBuKSl7aWYoIW8pbz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChuLDAscik7b1tyXT1uW3JdfX1yZXR1cm4gZS5jb25jYXQob3x8QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobikpfTtuLl9fZXNNb2R1bGU9dHJ1ZTt2YXIgdT1pKHQoNTIyKSk7dmFyIGM9aSh0KDg1MSkpO3ZhciBmPXQoMzM4KTt2YXIgZD10KDkzNik7dmFyIHY9dCgzNTUpO3ZhciBwPXQoNzkwKTt2YXIgbT10KDg4NCk7dmFyIGI9dCg0NjQpO3ZhciBnPXQoNDk1KTtmdW5jdGlvbiBwdXNoRXJyb3JGaWx0ZXJEdXBsaWNhdGVzKGUsbil7cmV0dXJuIHMocyhbXSxsKGUuZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4gZS5ldmVudC5yZWFzb24hPT1uLmV2ZW50LnJlYXNvbn0pKSksZmFsc2UpLFtuXSxmYWxzZSl9ZnVuY3Rpb24gcmVkdWNlcihlLG4pe3N3aXRjaChuLnR5cGUpe2Nhc2UgYy5UWVBFX0JVSUxEX09LOntyZXR1cm4gcihyKHt9LGUpLHtidWlsZEVycm9yOm51bGx9KX1jYXNlIGMuVFlQRV9CVUlMRF9FUlJPUjp7cmV0dXJuIHIocih7fSxlKSx7YnVpbGRFcnJvcjpuLm1lc3NhZ2V9KX1jYXNlIGMuVFlQRV9CRUZPUkVfUkVGUkVTSDp7cmV0dXJuIHIocih7fSxlKSx7cmVmcmVzaFN0YXRlOnt0eXBlOlwicGVuZGluZ1wiLGVycm9yczpbXX19KX1jYXNlIGMuVFlQRV9SRUZSRVNIOntyZXR1cm4gcihyKHt9LGUpLHtidWlsZEVycm9yOm51bGwsZXJyb3JzOmUucmVmcmVzaFN0YXRlLnR5cGU9PT1cInBlbmRpbmdcIj9lLnJlZnJlc2hTdGF0ZS5lcnJvcnM6W10scmVmcmVzaFN0YXRlOnt0eXBlOlwiaWRsZVwifX0pfWNhc2UgYy5UWVBFX1VOSEFORExFRF9FUlJPUjpjYXNlIGMuVFlQRV9VTkhBTkRMRURfUkVKRUNUSU9OOntzd2l0Y2goZS5yZWZyZXNoU3RhdGUudHlwZSl7Y2FzZVwiaWRsZVwiOntyZXR1cm4gcihyKHt9LGUpLHtuZXh0SWQ6ZS5uZXh0SWQrMSxlcnJvcnM6cHVzaEVycm9yRmlsdGVyRHVwbGljYXRlcyhlLmVycm9ycyx7aWQ6ZS5uZXh0SWQsZXZlbnQ6bn0pfSl9Y2FzZVwicGVuZGluZ1wiOntyZXR1cm4gcihyKHt9LGUpLHtuZXh0SWQ6ZS5uZXh0SWQrMSxyZWZyZXNoU3RhdGU6cihyKHt9LGUucmVmcmVzaFN0YXRlKSx7ZXJyb3JzOnB1c2hFcnJvckZpbHRlckR1cGxpY2F0ZXMoZS5yZWZyZXNoU3RhdGUuZXJyb3JzLHtpZDplLm5leHRJZCxldmVudDpufSl9KX0pfWRlZmF1bHQ6dmFyIHQ9ZS5yZWZyZXNoU3RhdGU7cmV0dXJuIGV9fWRlZmF1bHQ6e3ZhciB0PW47cmV0dXJuIGV9fX12YXIgc2hvdWxkUHJldmVudERpc3BsYXk9ZnVuY3Rpb24oZSxuKXtpZighbnx8IWUpe3JldHVybiBmYWxzZX1yZXR1cm4gbi5pbmNsdWRlcyhlKX07dmFyIGg9ZnVuY3Rpb24gUmVhY3REZXZPdmVybGF5KGUpe3ZhciBuPWUuY2hpbGRyZW4sdD1lLnByZXZlbnREaXNwbGF5LHI9ZS5nbG9iYWxPdmVybGF5O3ZhciBhPWwodS51c2VSZWR1Y2VyKHJlZHVjZXIse25leHRJZDoxLGJ1aWxkRXJyb3I6bnVsbCxlcnJvcnM6W10scmVmcmVzaFN0YXRlOnt0eXBlOlwiaWRsZVwifX0pLDIpLG89YVswXSxpPWFbMV07dS51c2VFZmZlY3QoKGZ1bmN0aW9uKCl7Yy5vbihpKTtyZXR1cm4gZnVuY3Rpb24oKXtjLm9mZihpKX19KSxbaV0pO3ZhciBzPXUudXNlQ2FsbGJhY2soKGZ1bmN0aW9uKGUsbil7fSksW10pO3ZhciBoPW8uYnVpbGRFcnJvciE9bnVsbDt2YXIgeT1Cb29sZWFuKG8uZXJyb3JzLmxlbmd0aCk7dmFyIHg9aD9cImJ1aWxkXCI6eT9cInJ1bnRpbWVcIjpudWxsO3ZhciB3PXghPT1udWxsO3JldHVybiB1LmNyZWF0ZUVsZW1lbnQodS5GcmFnbWVudCxudWxsLHUuY3JlYXRlRWxlbWVudChwLkVycm9yQm91bmRhcnkse2dsb2JhbE92ZXJsYXk6cixpc01vdW50ZWQ6dyxvbkVycm9yOnN9LG4hPT1udWxsJiZuIT09dm9pZCAwP246bnVsbCksdz91LmNyZWF0ZUVsZW1lbnQoZi5TaGFkb3dQb3J0YWwse2dsb2JhbE92ZXJsYXk6cn0sdS5jcmVhdGVFbGVtZW50KGcuQ3NzUmVzZXQsbnVsbCksdS5jcmVhdGVFbGVtZW50KG0uQmFzZSxudWxsKSx1LmNyZWF0ZUVsZW1lbnQoYi5Db21wb25lbnRTdHlsZXMsbnVsbCksc2hvdWxkUHJldmVudERpc3BsYXkoeCx0KT9udWxsOmg/dS5jcmVhdGVFbGVtZW50KGQuQnVpbGRFcnJvcix7bWVzc2FnZTpvLmJ1aWxkRXJyb3J9KTp5P3UuY3JlYXRlRWxlbWVudCh2LkVycm9ycyx7ZXJyb3JzOm8uZXJyb3JzfSk6dW5kZWZpbmVkKTp1bmRlZmluZWQpfTtuW1wiZGVmYXVsdFwiXT1ofSw4NTE6ZnVuY3Rpb24oZSxuKXt2YXIgdD10aGlzJiZ0aGlzLl9fYXNzaWdufHxmdW5jdGlvbigpe3Q9T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24oZSl7Zm9yKHZhciBuLHQ9MSxyPWFyZ3VtZW50cy5sZW5ndGg7dDxyO3QrKyl7bj1hcmd1bWVudHNbdF07Zm9yKHZhciBhIGluIG4paWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sYSkpZVthXT1uW2FdfXJldHVybiBlfTtyZXR1cm4gdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O24uX19lc01vZHVsZT10cnVlO24ub2ZmPW4ub249bi5lbWl0PW4uVFlQRV9VTkhBTkRMRURfUkVKRUNUSU9OPW4uVFlQRV9VTkhBTkRMRURfRVJST1I9bi5UWVBFX0JFRk9SRV9SRUZSRVNIPW4uVFlQRV9SRUZSRVNIPW4uVFlQRV9CVUlMRF9FUlJPUj1uLlRZUEVfQlVJTERfT0s9dm9pZCAwO24uVFlQRV9CVUlMRF9PSz1cImJ1aWxkLW9rXCI7bi5UWVBFX0JVSUxEX0VSUk9SPVwiYnVpbGQtZXJyb3JcIjtuLlRZUEVfUkVGUkVTSD1cImZhc3QtcmVmcmVzaFwiO24uVFlQRV9CRUZPUkVfUkVGUkVTSD1cImJlZm9yZS1mYXN0LXJlZnJlc2hcIjtuLlRZUEVfVU5IQU5ETEVEX0VSUk9SPVwidW5oYW5kbGVkLWVycm9yXCI7bi5UWVBFX1VOSEFORExFRF9SRUpFQ1RJT049XCJ1bmhhbmRsZWQtcmVqZWN0aW9uXCI7dmFyIHI9bmV3IFNldDt2YXIgYT1bXTtmdW5jdGlvbiBkcmFpbigpe3NldFRpbWVvdXQoKGZ1bmN0aW9uKCl7dmFyIF9sb29wXzE9ZnVuY3Rpb24oKXt2YXIgZT1hLnNoaWZ0KCk7ci5mb3JFYWNoKChmdW5jdGlvbihuKXtyZXR1cm4gbihlKX0pKX07d2hpbGUoQm9vbGVhbihhLmxlbmd0aCkmJkJvb2xlYW4oci5zaXplKSl7X2xvb3BfMSgpfX0pLDEpfWZ1bmN0aW9uIGVtaXQoZSl7YS5wdXNoKE9iamVjdC5mcmVlemUodCh7fSxlKSkpO2RyYWluKCl9bi5lbWl0PWVtaXQ7ZnVuY3Rpb24gb24oZSl7aWYoci5oYXMoZSkpe3JldHVybiBmYWxzZX1yLmFkZChlKTtkcmFpbigpO3JldHVybiB0cnVlfW4ub249b247ZnVuY3Rpb24gb2ZmKGUpe2lmKHIuaGFzKGUpKXtyW1wiZGVsZXRlXCJdKGUpO3JldHVybiB0cnVlfXJldHVybiBmYWxzZX1uLm9mZj1vZmZ9LDk4NzpmdW5jdGlvbihlLG4sdCl7dmFyIHI9dGhpcyYmdGhpcy5fX2Fzc2lnbnx8ZnVuY3Rpb24oKXtyPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKGUpe2Zvcih2YXIgbix0PTEscj1hcmd1bWVudHMubGVuZ3RoO3Q8cjt0Kyspe249YXJndW1lbnRzW3RdO2Zvcih2YXIgYSBpbiBuKWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLGEpKWVbYV09blthXX1yZXR1cm4gZX07cmV0dXJuIHIuYXBwbHkodGhpcyxhcmd1bWVudHMpfTt2YXIgYT10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7dmFyIGE9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLHQpO2lmKCFhfHwoXCJnZXRcImluIGE/IW4uX19lc01vZHVsZTphLndyaXRhYmxlfHxhLmNvbmZpZ3VyYWJsZSkpe2E9e2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gblt0XX19fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIsYSl9OmZ1bmN0aW9uKGUsbix0LHIpe2lmKHI9PT11bmRlZmluZWQpcj10O2Vbcl09blt0XX0pO3ZhciBvPXRoaXMmJnRoaXMuX19zZXRNb2R1bGVEZWZhdWx0fHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOnRydWUsdmFsdWU6bn0pfTpmdW5jdGlvbihlLG4pe2VbXCJkZWZhdWx0XCJdPW59KTt2YXIgaT10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciBuPXt9O2lmKGUhPW51bGwpZm9yKHZhciB0IGluIGUpaWYodCE9PVwiZGVmYXVsdFwiJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KSlhKG4sZSx0KTtvKG4sZSk7cmV0dXJuIG59O3ZhciBsPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19O24uX19lc01vZHVsZT10cnVlO24uQ29kZUZyYW1lPXZvaWQgMDt2YXIgcz1sKHQoOTk3KSk7dmFyIHU9aSh0KDUyMikpO3ZhciBjPWwodCg1MTgpKTt2YXIgZj10KDUwNCk7dmFyIGQ9ZnVuY3Rpb24gQ29kZUZyYW1lKGUpe3ZhciBuPWUuc3RhY2tGcmFtZSx0PWUuY29kZUZyYW1lO3ZhciBhPXUudXNlTWVtbygoZnVuY3Rpb24oKXt2YXIgZT10LnNwbGl0KC9cXHI/XFxuL2cpO3ZhciBuPWUubWFwKChmdW5jdGlvbihlKXtyZXR1cm4vXj4/ICtcXGQrICtcXHwgWyBdKy8uZXhlYygoMCxjW1wiZGVmYXVsdFwiXSkoZSkpPT09bnVsbD9udWxsOi9ePj8gK1xcZCsgK1xcfCAoICopLy5leGVjKCgwLGNbXCJkZWZhdWx0XCJdKShlKSl9KSkuZmlsdGVyKEJvb2xlYW4pLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUucG9wKCl9KSkucmVkdWNlKChmdW5jdGlvbihlLG4pe3JldHVybiBpc05hTihlKT9uLmxlbmd0aDpNYXRoLm1pbihlLG4ubGVuZ3RoKX0pLE5hTik7aWYobj4xKXt2YXIgcj1cIiBcIi5yZXBlYXQobik7cmV0dXJuIGUubWFwKChmdW5jdGlvbihlLG4pe3JldHVybn4obj1lLmluZGV4T2YoXCJ8XCIpKT9lLnN1YnN0cmluZygwLG4pK2Uuc3Vic3RyaW5nKG4pLnJlcGxhY2UocixcIlwiKTplfSkpLmpvaW4oXCJcXG5cIil9cmV0dXJuIGUuam9pbihcIlxcblwiKX0pLFt0XSk7dmFyIG89dS51c2VNZW1vKChmdW5jdGlvbigpe3JldHVybiBzW1wiZGVmYXVsdFwiXS5hbnNpVG9Kc29uKGEse2pzb246dHJ1ZSx1c2VfY2xhc3Nlczp0cnVlLHJlbW92ZV9lbXB0eTp0cnVlfSl9KSxbYV0pO3ZhciBpPXUudXNlQ2FsbGJhY2soKGZ1bmN0aW9uKCl7dmFyIGU7dmFyIHQ9bmV3IFVSTFNlYXJjaFBhcmFtcztmb3IodmFyIHIgaW4gbil7dC5hcHBlbmQociwoKGU9bltyXSkhPT1udWxsJiZlIT09dm9pZCAwP2U6XCJcIikudG9TdHJpbmcoKSl9c2VsZi5mZXRjaChcIlwiLmNvbmNhdChwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIfHxcIlwiLFwiL19fbmV4dGpzX2xhdW5jaC1lZGl0b3I/XCIpLmNvbmNhdCh0LnRvU3RyaW5nKCkpKS50aGVuKChmdW5jdGlvbigpe30pLChmdW5jdGlvbigpe2NvbnNvbGUuZXJyb3IoXCJUaGVyZSB3YXMgYW4gaXNzdWUgb3BlbmluZyB0aGlzIGNvZGUgaW4geW91ciBlZGl0b3IuXCIpfSkpfSksW25dKTtyZXR1cm4gdS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse1wiZGF0YS1uZXh0anMtY29kZWZyYW1lXCI6dHJ1ZX0sdS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsbnVsbCx1LmNyZWF0ZUVsZW1lbnQoXCJwXCIse3JvbGU6XCJsaW5rXCIsb25DbGljazppLHRhYkluZGV4OjEsdGl0bGU6XCJDbGljayB0byBvcGVuIGluIHlvdXIgZWRpdG9yXCJ9LHUuY3JlYXRlRWxlbWVudChcInNwYW5cIixudWxsLCgwLGYuZ2V0RnJhbWVTb3VyY2UpKG4pLFwiIEAgXCIsbi5tZXRob2ROYW1lKSx1LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIix7eG1sbnM6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLHZpZXdCb3g6XCIwIDAgMjQgMjRcIixmaWxsOlwibm9uZVwiLHN0cm9rZTpcImN1cnJlbnRDb2xvclwiLHN0cm9rZVdpZHRoOlwiMlwiLHN0cm9rZUxpbmVjYXA6XCJyb3VuZFwiLHN0cm9rZUxpbmVqb2luOlwicm91bmRcIn0sdS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLHtkOlwiTTE4IDEzdjZhMiAyIDAgMCAxLTIgMkg1YTIgMiAwIDAgMS0yLTJWOGEyIDIgMCAwIDEgMi0yaDZcIn0pLHUuY3JlYXRlRWxlbWVudChcInBvbHlsaW5lXCIse3BvaW50czpcIjE1IDMgMjEgMyAyMSA5XCJ9KSx1LmNyZWF0ZUVsZW1lbnQoXCJsaW5lXCIse3gxOlwiMTBcIix5MTpcIjE0XCIseDI6XCIyMVwiLHkyOlwiM1wifSkpKSksdS5jcmVhdGVFbGVtZW50KFwicHJlXCIsbnVsbCxvLm1hcCgoZnVuY3Rpb24oZSxuKXtyZXR1cm4gdS5jcmVhdGVFbGVtZW50KFwic3BhblwiLHtrZXk6XCJmcmFtZS1cIi5jb25jYXQobiksc3R5bGU6cih7Y29sb3I6ZS5mZz9cInZhcigtLWNvbG9yLVwiLmNvbmNhdChlLmZnLFwiKVwiKTp1bmRlZmluZWR9LGUuZGVjb3JhdGlvbj09PVwiYm9sZFwiP3tmb250V2VpZ2h0OjgwMH06ZS5kZWNvcmF0aW9uPT09XCJpdGFsaWNcIj97Zm9udFN0eWxlOlwiaXRhbGljXCJ9OnVuZGVmaW5lZCl9LGUuY29udGVudCl9KSkpKX07bi5Db2RlRnJhbWU9ZH0sNDEzOmZ1bmN0aW9uKGUsbix0KXt2YXIgcj10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7dmFyIGE9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLHQpO2lmKCFhfHwoXCJnZXRcImluIGE/IW4uX19lc01vZHVsZTphLndyaXRhYmxlfHxhLmNvbmZpZ3VyYWJsZSkpe2E9e2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gblt0XX19fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIsYSl9OmZ1bmN0aW9uKGUsbix0LHIpe2lmKHI9PT11bmRlZmluZWQpcj10O2Vbcl09blt0XX0pO24uX19lc01vZHVsZT10cnVlO24uQ29kZUZyYW1lPXZvaWQgMDt2YXIgYT10KDk4Nyk7cihuLGEsXCJDb2RlRnJhbWVcIil9LDM5OTpmdW5jdGlvbihlLG4sdCl7dmFyIHI9dGhpcyYmdGhpcy5fX21ha2VUZW1wbGF0ZU9iamVjdHx8ZnVuY3Rpb24oZSxuKXtpZihPYmplY3QuZGVmaW5lUHJvcGVydHkpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwicmF3XCIse3ZhbHVlOm59KX1lbHNle2UucmF3PW59cmV0dXJuIGV9O24uX19lc01vZHVsZT10cnVlO24uc3R5bGVzPXZvaWQgMDt2YXIgYT10KDkxMCk7dmFyIG89KDAsYS5ub29wKShpfHwoaT1yKFtcIlxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0ge1xcbiAgICBvdmVyZmxvdzogYXV0bztcXG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktYmcpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1mZyk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXTo6c2VsZWN0aW9uLFxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gKjo6c2VsZWN0aW9uIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS1zZWxlY3Rpb24pO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gKiB7XFxuICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdID4gKiB7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgcGFkZGluZzogY2FsYyh2YXIoLS1zaXplLWdhcCkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSlcXG4gICAgICBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSA+IGRpdiB7XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgd2lkdGg6IGF1dG87XFxuICAgIG1pbi13aWR0aDogMTAwJTtcXG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHZhcigtLWNvbG9yLWFuc2ktYnJpZ2h0LWJsYWNrKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdID4gZGl2ID4gcCB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICBtYXJnaW46IDA7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSA+IGRpdiA+IHA6aG92ZXIge1xcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSBkaXYgPiBwID4gc3ZnIHtcXG4gICAgd2lkdGg6IGF1dG87XFxuICAgIGhlaWdodDogMWVtO1xcbiAgICBtYXJnaW4tbGVmdDogOHB4O1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gZGl2ID4gcHJlIHtcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgfVxcblwiXSxbXCJcXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdIHtcXG4gICAgb3ZlcmZsb3c6IGF1dG87XFxuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLWJnKTtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktZmcpO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV06OnNlbGVjdGlvbixcXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdICo6OnNlbGVjdGlvbiB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktc2VsZWN0aW9uKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdICoge1xcbiAgICBjb2xvcjogaW5oZXJpdDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LXN0YWNrLW1vbm9zcGFjZSk7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSA+ICoge1xcbiAgICBtYXJnaW46IDA7XFxuICAgIHBhZGRpbmc6IGNhbGModmFyKC0tc2l6ZS1nYXApICsgdmFyKC0tc2l6ZS1nYXAtaGFsZikpXFxuICAgICAgY2FsYyh2YXIoLS1zaXplLWdhcC1kb3VibGUpICsgdmFyKC0tc2l6ZS1nYXAtaGFsZikpO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gPiBkaXYge1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgIHdpZHRoOiBhdXRvO1xcbiAgICBtaW4td2lkdGg6IDEwMCU7XFxuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCB2YXIoLS1jb2xvci1hbnNpLWJyaWdodC1ibGFjayk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSA+IGRpdiA+IHAge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgbWFyZ2luOiAwO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gPiBkaXYgPiBwOmhvdmVyIHtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gZGl2ID4gcCA+IHN2ZyB7XFxuICAgIHdpZHRoOiBhdXRvO1xcbiAgICBoZWlnaHQ6IDFlbTtcXG4gICAgbWFyZ2luLWxlZnQ6IDhweDtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdIGRpdiA+IHByZSB7XFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIH1cXG5cIl0pKSk7bi5zdHlsZXM9bzt2YXIgaX0sNjE2OmZ1bmN0aW9uKGUsbix0KXt2YXIgcj10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7dmFyIGE9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLHQpO2lmKCFhfHwoXCJnZXRcImluIGE/IW4uX19lc01vZHVsZTphLndyaXRhYmxlfHxhLmNvbmZpZ3VyYWJsZSkpe2E9e2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gblt0XX19fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIsYSl9OmZ1bmN0aW9uKGUsbix0LHIpe2lmKHI9PT11bmRlZmluZWQpcj10O2Vbcl09blt0XX0pO3ZhciBhPXRoaXMmJnRoaXMuX19zZXRNb2R1bGVEZWZhdWx0fHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOnRydWUsdmFsdWU6bn0pfTpmdW5jdGlvbihlLG4pe2VbXCJkZWZhdWx0XCJdPW59KTt2YXIgbz10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciBuPXt9O2lmKGUhPW51bGwpZm9yKHZhciB0IGluIGUpaWYodCE9PVwiZGVmYXVsdFwiJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KSlyKG4sZSx0KTthKG4sZSk7cmV0dXJuIG59O3ZhciBpPXRoaXMmJnRoaXMuX19yZXN0fHxmdW5jdGlvbihlLG4pe3ZhciB0PXt9O2Zvcih2YXIgciBpbiBlKWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpJiZuLmluZGV4T2Yocik8MCl0W3JdPWVbcl07aWYoZSE9bnVsbCYmdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM9PT1cImZ1bmN0aW9uXCIpZm9yKHZhciBhPTAscj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO2E8ci5sZW5ndGg7YSsrKXtpZihuLmluZGV4T2YoclthXSk8MCYmT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGUsclthXSkpdFtyW2FdXT1lW3JbYV1dfXJldHVybiB0fTt2YXIgbD10aGlzJiZ0aGlzLl9fcmVhZHx8ZnVuY3Rpb24oZSxuKXt2YXIgdD10eXBlb2YgU3ltYm9sPT09XCJmdW5jdGlvblwiJiZlW1N5bWJvbC5pdGVyYXRvcl07aWYoIXQpcmV0dXJuIGU7dmFyIHI9dC5jYWxsKGUpLGEsbz1bXSxpO3RyeXt3aGlsZSgobj09PXZvaWQgMHx8bi0tID4wKSYmIShhPXIubmV4dCgpKS5kb25lKW8ucHVzaChhLnZhbHVlKX1jYXRjaChlKXtpPXtlcnJvcjplfX1maW5hbGx5e3RyeXtpZihhJiYhYS5kb25lJiYodD1yW1wicmV0dXJuXCJdKSl0LmNhbGwocil9ZmluYWxseXtpZihpKXRocm93IGkuZXJyb3J9fXJldHVybiBvfTtuLl9fZXNNb2R1bGU9dHJ1ZTtuLkRpYWxvZz12b2lkIDA7dmFyIHM9byh0KDUyMikpO3ZhciB1PXQoMTY5KTt2YXIgYz1mdW5jdGlvbiBEaWFsb2coZSl7dmFyIG49ZS5jaGlsZHJlbix0PWUudHlwZSxyPWUub25DbG9zZSxhPWkoZSxbXCJjaGlsZHJlblwiLFwidHlwZVwiLFwib25DbG9zZVwiXSk7dmFyIG89bChzLnVzZVN0YXRlKG51bGwpLDIpLGM9b1swXSxmPW9bMV07dmFyIGQ9cy51c2VDYWxsYmFjaygoZnVuY3Rpb24oZSl7ZihlKX0pLFtdKTsoMCx1LnVzZU9uQ2xpY2tPdXRzaWRlKShjLHIpO3MudXNlRWZmZWN0KChmdW5jdGlvbigpe2lmKGM9PW51bGwpe3JldHVybn12YXIgZT1jLmdldFJvb3ROb2RlKCk7aWYoIShlIGluc3RhbmNlb2YgU2hhZG93Um9vdCkpe3JldHVybn12YXIgbj1lO2Z1bmN0aW9uIGhhbmRsZXIoZSl7dmFyIHQ9bi5hY3RpdmVFbGVtZW50O2lmKGUua2V5PT09XCJFbnRlclwiJiZ0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQmJnQuZ2V0QXR0cmlidXRlKFwicm9sZVwiKT09PVwibGlua1wiKXtlLnByZXZlbnREZWZhdWx0KCk7ZS5zdG9wUHJvcGFnYXRpb24oKTt0LmNsaWNrKCl9fW4uYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIixoYW5kbGVyKTtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbi5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLGhhbmRsZXIpfX0pLFtjXSk7cmV0dXJuIHMuY3JlYXRlRWxlbWVudChcImRpdlwiLHtyZWY6ZCxcImRhdGEtbmV4dGpzLWRpYWxvZ1wiOnRydWUsdGFiSW5kZXg6LTEscm9sZTpcImRpYWxvZ1wiLFwiYXJpYS1sYWJlbGxlZGJ5XCI6YVtcImFyaWEtbGFiZWxsZWRieVwiXSxcImFyaWEtZGVzY3JpYmVkYnlcIjphW1wiYXJpYS1kZXNjcmliZWRieVwiXSxcImFyaWEtbW9kYWxcIjpcInRydWVcIn0scy5jcmVhdGVFbGVtZW50KFwiZGl2XCIse1wiZGF0YS1uZXh0anMtZGlhbG9nLWJhbm5lclwiOnRydWUsY2xhc3NOYW1lOlwiYmFubmVyLVwiLmNvbmNhdCh0KX0pLG4pfTtuLkRpYWxvZz1jfSwxMTpmdW5jdGlvbihlLG4sdCl7dmFyIHI9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsbix0LHIpe2lmKHI9PT11bmRlZmluZWQpcj10O3ZhciBhPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobix0KTtpZighYXx8KFwiZ2V0XCJpbiBhPyFuLl9fZXNNb2R1bGU6YS53cml0YWJsZXx8YS5jb25maWd1cmFibGUpKXthPXtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG5bdF19fX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLGEpfTpmdW5jdGlvbihlLG4sdCxyKXtpZihyPT09dW5kZWZpbmVkKXI9dDtlW3JdPW5bdF19KTt2YXIgYT10aGlzJiZ0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdHx8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImRlZmF1bHRcIix7ZW51bWVyYWJsZTp0cnVlLHZhbHVlOm59KX06ZnVuY3Rpb24oZSxuKXtlW1wiZGVmYXVsdFwiXT1ufSk7dmFyIG89dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgbj17fTtpZihlIT1udWxsKWZvcih2YXIgdCBpbiBlKWlmKHQhPT1cImRlZmF1bHRcIiYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCkpcihuLGUsdCk7YShuLGUpO3JldHVybiBufTtuLl9fZXNNb2R1bGU9dHJ1ZTtuLkRpYWxvZ0JvZHk9dm9pZCAwO3ZhciBpPW8odCg1MjIpKTt2YXIgbD1mdW5jdGlvbiBEaWFsb2dCb2R5KGUpe3ZhciBuPWUuY2hpbGRyZW4sdD1lLmNsYXNzTmFtZTtyZXR1cm4gaS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse1wiZGF0YS1uZXh0anMtZGlhbG9nLWJvZHlcIjp0cnVlLGNsYXNzTmFtZTp0fSxuKX07bi5EaWFsb2dCb2R5PWx9LDk5MTpmdW5jdGlvbihlLG4sdCl7dmFyIHI9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsbix0LHIpe2lmKHI9PT11bmRlZmluZWQpcj10O3ZhciBhPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobix0KTtpZighYXx8KFwiZ2V0XCJpbiBhPyFuLl9fZXNNb2R1bGU6YS53cml0YWJsZXx8YS5jb25maWd1cmFibGUpKXthPXtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG5bdF19fX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLGEpfTpmdW5jdGlvbihlLG4sdCxyKXtpZihyPT09dW5kZWZpbmVkKXI9dDtlW3JdPW5bdF19KTt2YXIgYT10aGlzJiZ0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdHx8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImRlZmF1bHRcIix7ZW51bWVyYWJsZTp0cnVlLHZhbHVlOm59KX06ZnVuY3Rpb24oZSxuKXtlW1wiZGVmYXVsdFwiXT1ufSk7dmFyIG89dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgbj17fTtpZihlIT1udWxsKWZvcih2YXIgdCBpbiBlKWlmKHQhPT1cImRlZmF1bHRcIiYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCkpcihuLGUsdCk7YShuLGUpO3JldHVybiBufTtuLl9fZXNNb2R1bGU9dHJ1ZTtuLkRpYWxvZ0NvbnRlbnQ9dm9pZCAwO3ZhciBpPW8odCg1MjIpKTt2YXIgbD1mdW5jdGlvbiBEaWFsb2dDb250ZW50KGUpe3ZhciBuPWUuY2hpbGRyZW4sdD1lLmNsYXNzTmFtZTtyZXR1cm4gaS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse1wiZGF0YS1uZXh0anMtZGlhbG9nLWNvbnRlbnRcIjp0cnVlLGNsYXNzTmFtZTp0fSxuKX07bi5EaWFsb2dDb250ZW50PWx9LDM0MjpmdW5jdGlvbihlLG4sdCl7dmFyIHI9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsbix0LHIpe2lmKHI9PT11bmRlZmluZWQpcj10O3ZhciBhPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobix0KTtpZighYXx8KFwiZ2V0XCJpbiBhPyFuLl9fZXNNb2R1bGU6YS53cml0YWJsZXx8YS5jb25maWd1cmFibGUpKXthPXtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG5bdF19fX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLGEpfTpmdW5jdGlvbihlLG4sdCxyKXtpZihyPT09dW5kZWZpbmVkKXI9dDtlW3JdPW5bdF19KTt2YXIgYT10aGlzJiZ0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdHx8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImRlZmF1bHRcIix7ZW51bWVyYWJsZTp0cnVlLHZhbHVlOm59KX06ZnVuY3Rpb24oZSxuKXtlW1wiZGVmYXVsdFwiXT1ufSk7dmFyIG89dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgbj17fTtpZihlIT1udWxsKWZvcih2YXIgdCBpbiBlKWlmKHQhPT1cImRlZmF1bHRcIiYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCkpcihuLGUsdCk7YShuLGUpO3JldHVybiBufTtuLl9fZXNNb2R1bGU9dHJ1ZTtuLkRpYWxvZ0hlYWRlcj12b2lkIDA7dmFyIGk9byh0KDUyMikpO3ZhciBsPWZ1bmN0aW9uIERpYWxvZ0hlYWRlcihlKXt2YXIgbj1lLmNoaWxkcmVuLHQ9ZS5jbGFzc05hbWU7cmV0dXJuIGkuY3JlYXRlRWxlbWVudChcImRpdlwiLHtcImRhdGEtbmV4dGpzLWRpYWxvZy1oZWFkZXJcIjp0cnVlLGNsYXNzTmFtZTp0fSxuKX07bi5EaWFsb2dIZWFkZXI9bH0sNjUxOmZ1bmN0aW9uKGUsbix0KXt2YXIgcj10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7dmFyIGE9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLHQpO2lmKCFhfHwoXCJnZXRcImluIGE/IW4uX19lc01vZHVsZTphLndyaXRhYmxlfHxhLmNvbmZpZ3VyYWJsZSkpe2E9e2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gblt0XX19fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIsYSl9OmZ1bmN0aW9uKGUsbix0LHIpe2lmKHI9PT11bmRlZmluZWQpcj10O2Vbcl09blt0XX0pO24uX19lc01vZHVsZT10cnVlO24uc3R5bGVzPW4uRGlhbG9nSGVhZGVyPW4uRGlhbG9nQ29udGVudD1uLkRpYWxvZ0JvZHk9bi5EaWFsb2c9dm9pZCAwO3ZhciBhPXQoNjE2KTtyKG4sYSxcIkRpYWxvZ1wiKTt2YXIgbz10KDExKTtyKG4sbyxcIkRpYWxvZ0JvZHlcIik7dmFyIGk9dCg5OTEpO3IobixpLFwiRGlhbG9nQ29udGVudFwiKTt2YXIgbD10KDM0Mik7cihuLGwsXCJEaWFsb2dIZWFkZXJcIik7dmFyIHM9dCgyMTMpO3IobixzLFwic3R5bGVzXCIpfSwyMTM6ZnVuY3Rpb24oZSxuLHQpe3ZhciByPXRoaXMmJnRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3R8fGZ1bmN0aW9uKGUsbil7aWYoT2JqZWN0LmRlZmluZVByb3BlcnR5KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcInJhd1wiLHt2YWx1ZTpufSl9ZWxzZXtlLnJhdz1ufXJldHVybiBlfTtuLl9fZXNNb2R1bGU9dHJ1ZTtuLnN0eWxlcz12b2lkIDA7dmFyIGE9dCg5MTApO3ZhciBvPSgwLGEubm9vcCkoaXx8KGk9cihbXCJcXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ddIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIG1hcmdpbi1yaWdodDogYXV0bztcXG4gICAgbWFyZ2luLWxlZnQ6IGF1dG87XFxuICAgIG91dGxpbmU6IG5vbmU7XFxuICAgIGJhY2tncm91bmQ6IHdoaXRlO1xcbiAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1zaXplLWdhcCk7XFxuICAgIGJveC1zaGFkb3c6IDAgdmFyKC0tc2l6ZS1nYXAtaGFsZikgdmFyKC0tc2l6ZS1nYXAtZG91YmxlKVxcbiAgICAgIHJnYmEoMCwgMCwgMCwgMC4yNSk7XFxuICAgIG1heC1oZWlnaHQ6IGNhbGMoMTAwJSAtIDU2cHgpO1xcbiAgICBvdmVyZmxvdy15OiBoaWRkZW47XFxuICB9XFxuXFxuICBAbWVkaWEgKG1heC1oZWlnaHQ6IDgxMnB4KSB7XFxuICAgIFtkYXRhLW5leHRqcy1kaWFsb2ctb3ZlcmxheV0ge1xcbiAgICAgIG1heC1oZWlnaHQ6IGNhbGMoMTAwJSAtIDE1cHgpO1xcbiAgICB9XFxuICB9XFxuXFxuICBAbWVkaWEgKG1pbi13aWR0aDogNTc2cHgpIHtcXG4gICAgW2RhdGEtbmV4dGpzLWRpYWxvZ10ge1xcbiAgICAgIG1heC13aWR0aDogNTQwcHg7XFxuICAgICAgYm94LXNoYWRvdzogMCB2YXIoLS1zaXplLWdhcCkgdmFyKC0tc2l6ZS1nYXAtcXVhZCkgcmdiYSgwLCAwLCAwLCAwLjI1KTtcXG4gICAgfVxcbiAgfVxcblxcbiAgQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSB7XFxuICAgIFtkYXRhLW5leHRqcy1kaWFsb2ddIHtcXG4gICAgICBtYXgtd2lkdGg6IDcyMHB4O1xcbiAgICB9XFxuICB9XFxuXFxuICBAbWVkaWEgKG1pbi13aWR0aDogOTkycHgpIHtcXG4gICAgW2RhdGEtbmV4dGpzLWRpYWxvZ10ge1xcbiAgICAgIG1heC13aWR0aDogOTYwcHg7XFxuICAgIH1cXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctYmFubmVyXSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctYmFubmVyXS5iYW5uZXItd2FybmluZyB7XFxuICAgIGJvcmRlci1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS15ZWxsb3cpO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYW5uZXJdLmJhbm5lci1lcnJvciB7XFxuICAgIGJvcmRlci1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS1yZWQpO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYW5uZXJdOjphZnRlciB7XFxuICAgIHotaW5kZXg6IDI7XFxuICAgIGNvbnRlbnQ6ICcnO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICAvKiBiYW5uZXIgd2lkdGg6ICovXFxuICAgIGJvcmRlci10b3Atd2lkdGg6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBib3JkZXItYm90dG9tLXdpZHRoOiAwO1xcbiAgICBib3JkZXItdG9wLXN0eWxlOiBzb2xpZDtcXG4gICAgYm9yZGVyLWJvdHRvbS1zdHlsZTogc29saWQ7XFxuICAgIGJvcmRlci10b3AtY29sb3I6IGluaGVyaXQ7XFxuICAgIGJvcmRlci1ib3R0b20tY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1jb250ZW50XSB7XFxuICAgIG92ZXJmbG93LXk6IGF1dG87XFxuICAgIGJvcmRlcjogbm9uZTtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICAvKiBjYWxjKHBhZGRpbmcgKyBiYW5uZXIgd2lkdGggb2Zmc2V0KSAqL1xcbiAgICBwYWRkaW5nOiBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSlcXG4gICAgICB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWNvbnRlbnRdID4gW2RhdGEtbmV4dGpzLWRpYWxvZy1oZWFkZXJdIHtcXG4gICAgZmxleC1zaHJpbms6IDA7XFxuICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNpemUtZ2FwLWRvdWJsZSk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWNvbnRlbnRdID4gW2RhdGEtbmV4dGpzLWRpYWxvZy1ib2R5XSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgZmxleDogMSAxIGF1dG87XFxuICB9XFxuXCJdLFtcIlxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZ10ge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgbWFyZ2luLXJpZ2h0OiBhdXRvO1xcbiAgICBtYXJnaW4tbGVmdDogYXV0bztcXG4gICAgb3V0bGluZTogbm9uZTtcXG4gICAgYmFja2dyb3VuZDogd2hpdGU7XFxuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLXNpemUtZ2FwKTtcXG4gICAgYm94LXNoYWRvdzogMCB2YXIoLS1zaXplLWdhcC1oYWxmKSB2YXIoLS1zaXplLWdhcC1kb3VibGUpXFxuICAgICAgcmdiYSgwLCAwLCAwLCAwLjI1KTtcXG4gICAgbWF4LWhlaWdodDogY2FsYygxMDAlIC0gNTZweCk7XFxuICAgIG92ZXJmbG93LXk6IGhpZGRlbjtcXG4gIH1cXG5cXG4gIEBtZWRpYSAobWF4LWhlaWdodDogODEycHgpIHtcXG4gICAgW2RhdGEtbmV4dGpzLWRpYWxvZy1vdmVybGF5XSB7XFxuICAgICAgbWF4LWhlaWdodDogY2FsYygxMDAlIC0gMTVweCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIEBtZWRpYSAobWluLXdpZHRoOiA1NzZweCkge1xcbiAgICBbZGF0YS1uZXh0anMtZGlhbG9nXSB7XFxuICAgICAgbWF4LXdpZHRoOiA1NDBweDtcXG4gICAgICBib3gtc2hhZG93OiAwIHZhcigtLXNpemUtZ2FwKSB2YXIoLS1zaXplLWdhcC1xdWFkKSByZ2JhKDAsIDAsIDAsIDAuMjUpO1xcbiAgICB9XFxuICB9XFxuXFxuICBAbWVkaWEgKG1pbi13aWR0aDogNzY4cHgpIHtcXG4gICAgW2RhdGEtbmV4dGpzLWRpYWxvZ10ge1xcbiAgICAgIG1heC13aWR0aDogNzIwcHg7XFxuICAgIH1cXG4gIH1cXG5cXG4gIEBtZWRpYSAobWluLXdpZHRoOiA5OTJweCkge1xcbiAgICBbZGF0YS1uZXh0anMtZGlhbG9nXSB7XFxuICAgICAgbWF4LXdpZHRoOiA5NjBweDtcXG4gICAgfVxcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYW5uZXJdIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYW5uZXJdLmJhbm5lci13YXJuaW5nIHtcXG4gICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXllbGxvdyk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWJhbm5lcl0uYmFubmVyLWVycm9yIHtcXG4gICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXJlZCk7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWJhbm5lcl06OmFmdGVyIHtcXG4gICAgei1pbmRleDogMjtcXG4gICAgY29udGVudDogJyc7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAwO1xcbiAgICByaWdodDogMDtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIC8qIGJhbm5lciB3aWR0aDogKi9cXG4gICAgYm9yZGVyLXRvcC13aWR0aDogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICAgIGJvcmRlci1ib3R0b20td2lkdGg6IDA7XFxuICAgIGJvcmRlci10b3Atc3R5bGU6IHNvbGlkO1xcbiAgICBib3JkZXItYm90dG9tLXN0eWxlOiBzb2xpZDtcXG4gICAgYm9yZGVyLXRvcC1jb2xvcjogaW5oZXJpdDtcXG4gICAgYm9yZGVyLWJvdHRvbS1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWNvbnRlbnRdIHtcXG4gICAgb3ZlcmZsb3cteTogYXV0bztcXG4gICAgYm9yZGVyOiBub25lO1xcbiAgICBtYXJnaW46IDA7XFxuICAgIC8qIGNhbGMocGFkZGluZyArIGJhbm5lciB3aWR0aCBvZmZzZXQpICovXFxuICAgIHBhZGRpbmc6IGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKVxcbiAgICAgIHZhcigtLXNpemUtZ2FwLWRvdWJsZSk7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctY29udGVudF0gPiBbZGF0YS1uZXh0anMtZGlhbG9nLWhlYWRlcl0ge1xcbiAgICBmbGV4LXNocmluazogMDtcXG4gICAgbWFyZ2luLWJvdHRvbTogdmFyKC0tc2l6ZS1nYXAtZG91YmxlKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctY29udGVudF0gPiBbZGF0YS1uZXh0anMtZGlhbG9nLWJvZHldIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBmbGV4OiAxIDEgYXV0bztcXG4gIH1cXG5cIl0pKSk7bi5zdHlsZXM9bzt2YXIgaX0sODMxOmZ1bmN0aW9uKGUsbix0KXt2YXIgcj10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7dmFyIGE9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLHQpO2lmKCFhfHwoXCJnZXRcImluIGE/IW4uX19lc01vZHVsZTphLndyaXRhYmxlfHxhLmNvbmZpZ3VyYWJsZSkpe2E9e2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gblt0XX19fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIsYSl9OmZ1bmN0aW9uKGUsbix0LHIpe2lmKHI9PT11bmRlZmluZWQpcj10O2Vbcl09blt0XX0pO3ZhciBhPXRoaXMmJnRoaXMuX19zZXRNb2R1bGVEZWZhdWx0fHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOnRydWUsdmFsdWU6bn0pfTpmdW5jdGlvbihlLG4pe2VbXCJkZWZhdWx0XCJdPW59KTt2YXIgbz10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciBuPXt9O2lmKGUhPW51bGwpZm9yKHZhciB0IGluIGUpaWYodCE9PVwiZGVmYXVsdFwiJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KSlyKG4sZSx0KTthKG4sZSk7cmV0dXJuIG59O3ZhciBpPXRoaXMmJnRoaXMuX19yZWFkfHxmdW5jdGlvbihlLG4pe3ZhciB0PXR5cGVvZiBTeW1ib2w9PT1cImZ1bmN0aW9uXCImJmVbU3ltYm9sLml0ZXJhdG9yXTtpZighdClyZXR1cm4gZTt2YXIgcj10LmNhbGwoZSksYSxvPVtdLGk7dHJ5e3doaWxlKChuPT09dm9pZCAwfHxuLS0gPjApJiYhKGE9ci5uZXh0KCkpLmRvbmUpby5wdXNoKGEudmFsdWUpfWNhdGNoKGUpe2k9e2Vycm9yOmV9fWZpbmFsbHl7dHJ5e2lmKGEmJiFhLmRvbmUmJih0PXJbXCJyZXR1cm5cIl0pKXQuY2FsbChyKX1maW5hbGx5e2lmKGkpdGhyb3cgaS5lcnJvcn19cmV0dXJuIG99O24uX19lc01vZHVsZT10cnVlO24uTGVmdFJpZ2h0RGlhbG9nSGVhZGVyPXZvaWQgMDt2YXIgbD1vKHQoNTIyKSk7dmFyIHM9dCg4NjUpO3ZhciB1PWZ1bmN0aW9uIExlZnRSaWdodERpYWxvZ0hlYWRlcihlKXt2YXIgbj1lLmNoaWxkcmVuLHQ9ZS5jbGFzc05hbWUscj1lLnByZXZpb3VzLGE9ZS5uZXh0LG89ZS5jbG9zZTt2YXIgdT1sLnVzZVJlZihudWxsKTt2YXIgYz1sLnVzZVJlZihudWxsKTt2YXIgZj1sLnVzZVJlZihudWxsKTt2YXIgZD1pKGwudXNlU3RhdGUobnVsbCksMiksdj1kWzBdLHA9ZFsxXTt2YXIgbT1sLnVzZUNhbGxiYWNrKChmdW5jdGlvbihlKXtwKGUpfSksW10pO2wudXNlRWZmZWN0KChmdW5jdGlvbigpe2lmKHY9PW51bGwpe3JldHVybn12YXIgZT12LmdldFJvb3ROb2RlKCk7dmFyIG49c2VsZi5kb2N1bWVudDtmdW5jdGlvbiBoYW5kbGVyKG4pe2lmKG4ua2V5PT09XCJBcnJvd0xlZnRcIil7bi5zdG9wUHJvcGFnYXRpb24oKTtpZih1LmN1cnJlbnQpe3UuY3VycmVudC5mb2N1cygpfXImJnIoKX1lbHNlIGlmKG4ua2V5PT09XCJBcnJvd1JpZ2h0XCIpe24uc3RvcFByb3BhZ2F0aW9uKCk7aWYoYy5jdXJyZW50KXtjLmN1cnJlbnQuZm9jdXMoKX1hJiZhKCl9ZWxzZSBpZihuLmtleT09PVwiRXNjYXBlXCIpe24uc3RvcFByb3BhZ2F0aW9uKCk7aWYoZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3Qpe3ZhciB0PWUuYWN0aXZlRWxlbWVudDtpZih0JiZ0IT09Zi5jdXJyZW50JiZ0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpe3QuYmx1cigpO3JldHVybn19aWYobyl7bygpfX19ZS5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLGhhbmRsZXIpO2lmKGUhPT1uKXtuLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsaGFuZGxlcil9cmV0dXJuIGZ1bmN0aW9uKCl7ZS5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLGhhbmRsZXIpO2lmKGUhPT1uKXtuLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsaGFuZGxlcil9fX0pLFtvLHYsYSxyXSk7bC51c2VFZmZlY3QoKGZ1bmN0aW9uKCl7aWYodj09bnVsbCl7cmV0dXJufXZhciBlPXYuZ2V0Um9vdE5vZGUoKTtpZihlIGluc3RhbmNlb2YgU2hhZG93Um9vdCl7dmFyIG49ZS5hY3RpdmVFbGVtZW50O2lmKHI9PW51bGwpe2lmKHUuY3VycmVudCYmbj09PXUuY3VycmVudCl7dS5jdXJyZW50LmJsdXIoKX19ZWxzZSBpZihhPT1udWxsKXtpZihjLmN1cnJlbnQmJm49PT1jLmN1cnJlbnQpe2MuY3VycmVudC5ibHVyKCl9fX19KSxbdixhLHJdKTtyZXR1cm4gbC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse1wiZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRcIjp0cnVlLGNsYXNzTmFtZTp0fSxsLmNyZWF0ZUVsZW1lbnQoXCJuYXZcIix7cmVmOm19LGwuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLHtyZWY6dSx0eXBlOlwiYnV0dG9uXCIsZGlzYWJsZWQ6cj09bnVsbD90cnVlOnVuZGVmaW5lZCxcImFyaWEtZGlzYWJsZWRcIjpyPT1udWxsP3RydWU6dW5kZWZpbmVkLG9uQ2xpY2s6ciE9PW51bGwmJnIhPT12b2lkIDA/cjp1bmRlZmluZWR9LGwuY3JlYXRlRWxlbWVudChcInN2Z1wiLHt2aWV3Qm94OlwiMCAwIDE0IDE0XCIsZmlsbDpcIm5vbmVcIix4bWxuczpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJ9LGwuY3JlYXRlRWxlbWVudChcInBhdGhcIix7ZDpcIk02Ljk5OTk2IDEuMTY2NjZMMS4xNjY2MyA2Ljk5OTk5TDYuOTk5OTYgMTIuODMzM00xMi44MzMzIDYuOTk5OTlIMS45OTk5NkgxMi44MzMzWlwiLHN0cm9rZTpcImN1cnJlbnRDb2xvclwiLHN0cm9rZVdpZHRoOlwiMlwiLHN0cm9rZUxpbmVjYXA6XCJyb3VuZFwiLHN0cm9rZUxpbmVqb2luOlwicm91bmRcIn0pKSksbC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIse3JlZjpjLHR5cGU6XCJidXR0b25cIixkaXNhYmxlZDphPT1udWxsP3RydWU6dW5kZWZpbmVkLFwiYXJpYS1kaXNhYmxlZFwiOmE9PW51bGw/dHJ1ZTp1bmRlZmluZWQsb25DbGljazphIT09bnVsbCYmYSE9PXZvaWQgMD9hOnVuZGVmaW5lZH0sbC5jcmVhdGVFbGVtZW50KFwic3ZnXCIse3ZpZXdCb3g6XCIwIDAgMTQgMTRcIixmaWxsOlwibm9uZVwiLHhtbG5zOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIn0sbC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLHtkOlwiTTYuOTk5OTYgMS4xNjY2NkwxMi44MzMzIDYuOTk5OTlMNi45OTk5NiAxMi44MzMzTTEuMTY2NjMgNi45OTk5OUgxMkgxLjE2NjYzWlwiLHN0cm9rZTpcImN1cnJlbnRDb2xvclwiLHN0cm9rZVdpZHRoOlwiMlwiLHN0cm9rZUxpbmVjYXA6XCJyb3VuZFwiLHN0cm9rZUxpbmVqb2luOlwicm91bmRcIn0pKSksXCLCoFwiLG4pLG8/bC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIse1wiZGF0YS1uZXh0anMtZXJyb3JzLWRpYWxvZy1sZWZ0LXJpZ2h0LWNsb3NlLWJ1dHRvblwiOnRydWUscmVmOmYsdHlwZTpcImJ1dHRvblwiLG9uQ2xpY2s6byxcImFyaWEtbGFiZWxcIjpcIkNsb3NlXCJ9LGwuY3JlYXRlRWxlbWVudChcInNwYW5cIix7XCJhcmlhLWhpZGRlblwiOlwidHJ1ZVwifSxsLmNyZWF0ZUVsZW1lbnQocy5DbG9zZUljb24sbnVsbCkpKTpudWxsKX07bi5MZWZ0UmlnaHREaWFsb2dIZWFkZXI9dX0sNzMyOmZ1bmN0aW9uKGUsbix0KXt2YXIgcj10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7dmFyIGE9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLHQpO2lmKCFhfHwoXCJnZXRcImluIGE/IW4uX19lc01vZHVsZTphLndyaXRhYmxlfHxhLmNvbmZpZ3VyYWJsZSkpe2E9e2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gblt0XX19fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIsYSl9OmZ1bmN0aW9uKGUsbix0LHIpe2lmKHI9PT11bmRlZmluZWQpcj10O2Vbcl09blt0XX0pO24uX19lc01vZHVsZT10cnVlO24uc3R5bGVzPW4uTGVmdFJpZ2h0RGlhbG9nSGVhZGVyPXZvaWQgMDt2YXIgYT10KDgzMSk7cihuLGEsXCJMZWZ0UmlnaHREaWFsb2dIZWFkZXJcIik7dmFyIG89dCg1NDMpO3IobixvLFwic3R5bGVzXCIpfSw1NDM6ZnVuY3Rpb24oZSxuLHQpe3ZhciByPXRoaXMmJnRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3R8fGZ1bmN0aW9uKGUsbil7aWYoT2JqZWN0LmRlZmluZVByb3BlcnR5KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcInJhd1wiLHt2YWx1ZTpufSl9ZWxzZXtlLnJhdz1ufXJldHVybiBlfTtuLl9fZXNNb2R1bGU9dHJ1ZTtuLnN0eWxlcz12b2lkIDA7dmFyIGE9dCg5MTApO3ZhciBvPSgwLGEubm9vcCkoaXx8KGk9cihbXCJcXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0ge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgICBhbGlnbi1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b24ge1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuXFxuICAgIHdpZHRoOiBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcCkpO1xcbiAgICBoZWlnaHQ6IGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwKSk7XFxuICAgIGZvbnQtc2l6ZTogMDtcXG4gICAgYm9yZGVyOiBub25lO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgODUsIDg1LCAwLjEpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1yZWQpO1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMC4yNXMgZWFzZTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b24gPiBzdmcge1xcbiAgICB3aWR0aDogYXV0bztcXG4gICAgaGVpZ2h0OiBjYWxjKHZhcigtLXNpemUtZ2FwKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b246aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgODUsIDg1LCAwLjIpO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IG5hdiA+IGJ1dHRvbjpkaXNhYmxlZCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCA4NSwgODUsIDAuMSk7XFxuICAgIGNvbG9yOiByZ2JhKDI1NSwgODUsIDg1LCAwLjQpO1xcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IG5hdiA+IGJ1dHRvbjpmaXJzdC1vZi10eXBlIHtcXG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXAtaGFsZikgMCAwIHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBtYXJnaW4tcmlnaHQ6IDFweDtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b246bGFzdC1vZi10eXBlIHtcXG4gICAgYm9yZGVyLXJhZGl1czogMCB2YXIoLS1zaXplLWdhcC1oYWxmKSB2YXIoLS1zaXplLWdhcC1oYWxmKSAwO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IGJ1dHRvbjpsYXN0LW9mLXR5cGUge1xcbiAgICBib3JkZXI6IDA7XFxuICAgIHBhZGRpbmc6IDA7XFxuXFxuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICBhcHBlYXJhbmNlOiBub25lO1xcblxcbiAgICBvcGFjaXR5OiAwLjQ7XFxuICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4yNXMgZWFzZTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBidXR0b246bGFzdC1vZi10eXBlOmhvdmVyIHtcXG4gICAgb3BhY2l0eTogMC43O1xcbiAgfVxcblwiXSxbXCJcXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0ge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgICBhbGlnbi1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b24ge1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuXFxuICAgIHdpZHRoOiBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcCkpO1xcbiAgICBoZWlnaHQ6IGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwKSk7XFxuICAgIGZvbnQtc2l6ZTogMDtcXG4gICAgYm9yZGVyOiBub25lO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgODUsIDg1LCAwLjEpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1yZWQpO1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMC4yNXMgZWFzZTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b24gPiBzdmcge1xcbiAgICB3aWR0aDogYXV0bztcXG4gICAgaGVpZ2h0OiBjYWxjKHZhcigtLXNpemUtZ2FwKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b246aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgODUsIDg1LCAwLjIpO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IG5hdiA+IGJ1dHRvbjpkaXNhYmxlZCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCA4NSwgODUsIDAuMSk7XFxuICAgIGNvbG9yOiByZ2JhKDI1NSwgODUsIDg1LCAwLjQpO1xcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IG5hdiA+IGJ1dHRvbjpmaXJzdC1vZi10eXBlIHtcXG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXAtaGFsZikgMCAwIHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBtYXJnaW4tcmlnaHQ6IDFweDtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b246bGFzdC1vZi10eXBlIHtcXG4gICAgYm9yZGVyLXJhZGl1czogMCB2YXIoLS1zaXplLWdhcC1oYWxmKSB2YXIoLS1zaXplLWdhcC1oYWxmKSAwO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IGJ1dHRvbjpsYXN0LW9mLXR5cGUge1xcbiAgICBib3JkZXI6IDA7XFxuICAgIHBhZGRpbmc6IDA7XFxuXFxuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICBhcHBlYXJhbmNlOiBub25lO1xcblxcbiAgICBvcGFjaXR5OiAwLjQ7XFxuICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4yNXMgZWFzZTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBidXR0b246bGFzdC1vZi10eXBlOmhvdmVyIHtcXG4gICAgb3BhY2l0eTogMC43O1xcbiAgfVxcblwiXSkpKTtuLnN0eWxlcz1vO3ZhciBpfSwxNzpmdW5jdGlvbihlLG4sdCl7dmFyIHI9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsbix0LHIpe2lmKHI9PT11bmRlZmluZWQpcj10O3ZhciBhPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobix0KTtpZighYXx8KFwiZ2V0XCJpbiBhPyFuLl9fZXNNb2R1bGU6YS53cml0YWJsZXx8YS5jb25maWd1cmFibGUpKXthPXtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG5bdF19fX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLGEpfTpmdW5jdGlvbihlLG4sdCxyKXtpZihyPT09dW5kZWZpbmVkKXI9dDtlW3JdPW5bdF19KTt2YXIgYT10aGlzJiZ0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdHx8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImRlZmF1bHRcIix7ZW51bWVyYWJsZTp0cnVlLHZhbHVlOm59KX06ZnVuY3Rpb24oZSxuKXtlW1wiZGVmYXVsdFwiXT1ufSk7dmFyIG89dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgbj17fTtpZihlIT1udWxsKWZvcih2YXIgdCBpbiBlKWlmKHQhPT1cImRlZmF1bHRcIiYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCkpcihuLGUsdCk7YShuLGUpO3JldHVybiBufTt2YXIgaT10aGlzJiZ0aGlzLl9fcmVhZHx8ZnVuY3Rpb24oZSxuKXt2YXIgdD10eXBlb2YgU3ltYm9sPT09XCJmdW5jdGlvblwiJiZlW1N5bWJvbC5pdGVyYXRvcl07aWYoIXQpcmV0dXJuIGU7dmFyIHI9dC5jYWxsKGUpLGEsbz1bXSxpO3RyeXt3aGlsZSgobj09PXZvaWQgMHx8bi0tID4wKSYmIShhPXIubmV4dCgpKS5kb25lKW8ucHVzaChhLnZhbHVlKX1jYXRjaChlKXtpPXtlcnJvcjplfX1maW5hbGx5e3RyeXtpZihhJiYhYS5kb25lJiYodD1yW1wicmV0dXJuXCJdKSl0LmNhbGwocil9ZmluYWxseXtpZihpKXRocm93IGkuZXJyb3J9fXJldHVybiBvfTt2YXIgbD10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fTtuLl9fZXNNb2R1bGU9dHJ1ZTtuLk92ZXJsYXk9dm9pZCAwO3ZhciBzPWwodCg5NzUpKTt2YXIgdT1vKHQoNTIyKSk7dmFyIGM9dCg4MDApO3ZhciBmPWZ1bmN0aW9uIE92ZXJsYXkoZSl7dmFyIG49ZS5jbGFzc05hbWUsdD1lLmNoaWxkcmVuLHI9ZS5maXhlZDt1LnVzZUVmZmVjdCgoZnVuY3Rpb24oKXsoMCxjLmxvY2spKCk7cmV0dXJuIGZ1bmN0aW9uKCl7KDAsYy51bmxvY2spKCl9fSksW10pO3ZhciBhPWkodS51c2VTdGF0ZShudWxsKSwyKSxvPWFbMF0sbD1hWzFdO3ZhciBmPXUudXNlQ2FsbGJhY2soKGZ1bmN0aW9uKGUpe2woZSl9KSxbXSk7dS51c2VFZmZlY3QoKGZ1bmN0aW9uKCl7aWYobz09bnVsbCl7cmV0dXJufXZhciBlPSgwLHNbXCJkZWZhdWx0XCJdKSh7Y29udGV4dDpvfSk7cmV0dXJuIGZ1bmN0aW9uKCl7ZS5kaXNlbmdhZ2UoKX19KSxbb10pO3JldHVybiB1LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7XCJkYXRhLW5leHRqcy1kaWFsb2ctb3ZlcmxheVwiOnRydWUsY2xhc3NOYW1lOm4scmVmOmZ9LHUuY3JlYXRlRWxlbWVudChcImRpdlwiLHtcImRhdGEtbmV4dGpzLWRpYWxvZy1iYWNrZHJvcFwiOnRydWUsXCJkYXRhLW5leHRqcy1kaWFsb2ctYmFja2Ryb3AtZml4ZWRcIjpyP3RydWU6dW5kZWZpbmVkfSksdCl9O24uT3ZlcmxheT1mfSw4MDA6ZnVuY3Rpb24oZSxuKXtuLl9fZXNNb2R1bGU9dHJ1ZTtuLnVubG9jaz1uLmxvY2s9dm9pZCAwO3ZhciB0O3ZhciByO3ZhciBhPTA7ZnVuY3Rpb24gbG9jaygpe3NldFRpbWVvdXQoKGZ1bmN0aW9uKCl7aWYoYSsrPjApe3JldHVybn12YXIgZT13aW5kb3cuaW5uZXJXaWR0aC1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7aWYoZT4wKXt0PWRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0O2RvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0PVwiXCIuY29uY2F0KGUsXCJweFwiKX1yPWRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3c7ZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdz1cImhpZGRlblwifSkpfW4ubG9jaz1sb2NrO2Z1bmN0aW9uIHVubG9jaygpe3NldFRpbWVvdXQoKGZ1bmN0aW9uKCl7aWYoYT09PTB8fC0tYSE9PTApe3JldHVybn1pZih0IT09dW5kZWZpbmVkKXtkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodD10O3Q9dW5kZWZpbmVkfWlmKHIhPT11bmRlZmluZWQpe2RvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3c9cjtyPXVuZGVmaW5lZH19KSl9bi51bmxvY2s9dW5sb2NrfSwyNzg6ZnVuY3Rpb24oZSxuLHQpe3ZhciByPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLG4sdCxyKXtpZihyPT09dW5kZWZpbmVkKXI9dDt2YXIgYT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sdCk7aWYoIWF8fChcImdldFwiaW4gYT8hbi5fX2VzTW9kdWxlOmEud3JpdGFibGV8fGEuY29uZmlndXJhYmxlKSl7YT17ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBuW3RdfX19T2JqZWN0LmRlZmluZVByb3BlcnR5KGUscixhKX06ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7ZVtyXT1uW3RdfSk7bi5fX2VzTW9kdWxlPXRydWU7bi5PdmVybGF5PXZvaWQgMDt2YXIgYT10KDE3KTtyKG4sYSxcIk92ZXJsYXlcIil9LDk3NTpmdW5jdGlvbihlLG4sdCl7dmFyIHI9dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX07bi5fX2VzTW9kdWxlPXRydWU7dmFyIGE9cih0KDcwOSkpO3ZhciBvPXIodCgyOTIpKTtmdW5jdGlvbiBub2RlQXJyYXkoZSl7aWYoIWUpe3JldHVybltdfWlmKEFycmF5LmlzQXJyYXkoZSkpe3JldHVybiBlfWlmKGUubm9kZVR5cGUhPT11bmRlZmluZWQpe3JldHVybltlXX1pZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe2U9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChlKX1pZihlLmxlbmd0aCE9PXVuZGVmaW5lZCl7cmV0dXJuW10uc2xpY2UuY2FsbChlLDApfXRocm93IG5ldyBUeXBlRXJyb3IoXCJ1bmV4cGVjdGVkIGlucHV0IFwiK1N0cmluZyhlKSl9ZnVuY3Rpb24gY29udGV4dFRvRWxlbWVudChlKXt2YXIgbj1lLmNvbnRleHQsdD1lLmxhYmVsLHI9dD09PXVuZGVmaW5lZD9cImNvbnRleHQtdG8tZWxlbWVudFwiOnQsYT1lLnJlc29sdmVEb2N1bWVudCxvPWUuZGVmYXVsdFRvRG9jdW1lbnQ7dmFyIGk9bm9kZUFycmF5KG4pWzBdO2lmKGEmJmkmJmkubm9kZVR5cGU9PT1Ob2RlLkRPQ1VNRU5UX05PREUpe2k9aS5kb2N1bWVudEVsZW1lbnR9aWYoIWkmJm8pe3JldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnR9aWYoIWkpe3Rocm93IG5ldyBUeXBlRXJyb3IocitcIiByZXF1aXJlcyB2YWxpZCBvcHRpb25zLmNvbnRleHRcIil9aWYoaS5ub2RlVHlwZSE9PU5vZGUuRUxFTUVOVF9OT0RFJiZpLm5vZGVUeXBlIT09Tm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKXt0aHJvdyBuZXcgVHlwZUVycm9yKHIrXCIgcmVxdWlyZXMgb3B0aW9ucy5jb250ZXh0IHRvIGJlIGFuIEVsZW1lbnRcIil9cmV0dXJuIGl9ZnVuY3Rpb24gZ2V0U2hhZG93SG9zdCgpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1swXTp7fSxuPWUuY29udGV4dDt2YXIgdD1jb250ZXh0VG9FbGVtZW50KHtsYWJlbDpcImdldC9zaGFkb3ctaG9zdFwiLGNvbnRleHQ6bn0pO3ZhciByPW51bGw7d2hpbGUodCl7cj10O3Q9dC5wYXJlbnROb2RlfWlmKHIubm9kZVR5cGU9PT1yLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUmJnIuaG9zdCl7cmV0dXJuIHIuaG9zdH1yZXR1cm4gbnVsbH1mdW5jdGlvbiBnZXREb2N1bWVudChlKXtpZighZSl7cmV0dXJuIGRvY3VtZW50fWlmKGUubm9kZVR5cGU9PT1Ob2RlLkRPQ1VNRU5UX05PREUpe3JldHVybiBlfXJldHVybiBlLm93bmVyRG9jdW1lbnR8fGRvY3VtZW50fWZ1bmN0aW9uIGlzQWN0aXZlRWxlbWVudChlKXt2YXIgbj1jb250ZXh0VG9FbGVtZW50KHtsYWJlbDpcImlzL2FjdGl2ZS1lbGVtZW50XCIscmVzb2x2ZURvY3VtZW50OnRydWUsY29udGV4dDplfSk7dmFyIHQ9Z2V0RG9jdW1lbnQobik7aWYodC5hY3RpdmVFbGVtZW50PT09bil7cmV0dXJuIHRydWV9dmFyIHI9Z2V0U2hhZG93SG9zdCh7Y29udGV4dDpufSk7aWYociYmci5zaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQ9PT1uKXtyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2V9ZnVuY3Rpb24gZ2V0UGFyZW50cygpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1swXTp7fSxuPWUuY29udGV4dDt2YXIgdD1bXTt2YXIgcj1jb250ZXh0VG9FbGVtZW50KHtsYWJlbDpcImdldC9wYXJlbnRzXCIsY29udGV4dDpufSk7d2hpbGUocil7dC5wdXNoKHIpO3I9ci5wYXJlbnROb2RlO2lmKHImJnIubm9kZVR5cGUhPT1Ob2RlLkVMRU1FTlRfTk9ERSl7cj1udWxsfX1yZXR1cm4gdH12YXIgaT1bXCJtYXRjaGVzXCIsXCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3JcIixcIm1vek1hdGNoZXNTZWxlY3RvclwiLFwibXNNYXRjaGVzU2VsZWN0b3JcIl07dmFyIGw9bnVsbDtmdW5jdGlvbiBmaW5kTWV0aG9kTmFtZShlKXtpLnNvbWUoKGZ1bmN0aW9uKG4pe2lmKCFlW25dKXtyZXR1cm4gZmFsc2V9bD1uO3JldHVybiB0cnVlfSkpfWZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVzKGUsbil7aWYoIWwpe2ZpbmRNZXRob2ROYW1lKGUpfXJldHVybiBlW2xdKG4pfXZhciBzPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYVtcImRlZmF1bHRcIl0pKTt2YXIgdT1zLm9zLmZhbWlseXx8XCJcIjt2YXIgYz11PT09XCJBbmRyb2lkXCI7dmFyIGY9dS5zbGljZSgwLDcpPT09XCJXaW5kb3dzXCI7dmFyIGQ9dT09PVwiT1MgWFwiO3ZhciB2PXU9PT1cImlPU1wiO3ZhciBwPXMubGF5b3V0PT09XCJCbGlua1wiO3ZhciBtPXMubGF5b3V0PT09XCJHZWNrb1wiO3ZhciBiPXMubGF5b3V0PT09XCJUcmlkZW50XCI7dmFyIGc9cy5sYXlvdXQ9PT1cIkVkZ2VIVE1MXCI7dmFyIGg9cy5sYXlvdXQ9PT1cIldlYktpdFwiO3ZhciB5PXBhcnNlRmxvYXQocy52ZXJzaW9uKTt2YXIgeD1NYXRoLmZsb29yKHkpO3MubWFqb3JWZXJzaW9uPXg7cy5pcz17QU5EUk9JRDpjLFdJTkRPV1M6ZixPU1g6ZCxJT1M6dixCTElOSzpwLEdFQ0tPOm0sVFJJREVOVDpiLEVER0U6ZyxXRUJLSVQ6aCxJRTk6YiYmeD09PTksSUUxMDpiJiZ4PT09MTAsSUUxMTpiJiZ4PT09MTF9O2Z1bmN0aW9uIGJlZm9yZSgpe3ZhciBlPXthY3RpdmVFbGVtZW50OmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQsd2luZG93U2Nyb2xsVG9wOndpbmRvdy5zY3JvbGxUb3Asd2luZG93U2Nyb2xsTGVmdDp3aW5kb3cuc2Nyb2xsTGVmdCxib2R5U2Nyb2xsVG9wOmRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wLGJvZHlTY3JvbGxMZWZ0OmRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdH07dmFyIG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtuLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsXCJwb3NpdGlvbjphYnNvbHV0ZTsgcG9zaXRpb246Zml4ZWQ7IHRvcDowOyBsZWZ0Oi0ycHg7IHdpZHRoOjFweDsgaGVpZ2h0OjFweDsgb3ZlcmZsb3c6aGlkZGVuO1wiKTtuLnNldEF0dHJpYnV0ZShcImFyaWEtbGl2ZVwiLFwib2ZmXCIpO24uc2V0QXR0cmlidXRlKFwiYXJpYS1idXN5XCIsXCJ0cnVlXCIpO24uc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIixcInRydWVcIik7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChuKTt2YXIgdD1uLmNvbnRlbnRXaW5kb3c7dmFyIHI9dC5kb2N1bWVudDtyLm9wZW4oKTtyLmNsb3NlKCk7dmFyIGE9ci5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO3IuYm9keS5hcHBlbmRDaGlsZChhKTtlLmlmcmFtZT1uO2Uud3JhcHBlcj1hO2Uud2luZG93PXQ7ZS5kb2N1bWVudD1yO3JldHVybiBlfWZ1bmN0aW9uIHRlc3QoZSxuKXtlLndyYXBwZXIuaW5uZXJIVE1MPVwiXCI7dmFyIHQ9dHlwZW9mIG4uZWxlbWVudD09PVwic3RyaW5nXCI/ZS5kb2N1bWVudC5jcmVhdGVFbGVtZW50KG4uZWxlbWVudCk6bi5lbGVtZW50KGUud3JhcHBlcixlLmRvY3VtZW50KTt2YXIgcj1uLm11dGF0ZSYmbi5tdXRhdGUodCxlLndyYXBwZXIsZS5kb2N1bWVudCk7aWYoIXImJnIhPT1mYWxzZSl7cj10fSF0LnBhcmVudE5vZGUmJmUud3JhcHBlci5hcHBlbmRDaGlsZCh0KTtyJiZyLmZvY3VzJiZyLmZvY3VzKCk7cmV0dXJuIG4udmFsaWRhdGU/bi52YWxpZGF0ZSh0LHIsZS5kb2N1bWVudCk6ZS5kb2N1bWVudC5hY3RpdmVFbGVtZW50PT09cn1mdW5jdGlvbiBhZnRlcihlKXtpZihlLmFjdGl2ZUVsZW1lbnQ9PT1kb2N1bWVudC5ib2R5KXtkb2N1bWVudC5hY3RpdmVFbGVtZW50JiZkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXImJmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO2lmKHMuaXMuSUUxMCl7ZG9jdW1lbnQuYm9keS5mb2N1cygpfX1lbHNle2UuYWN0aXZlRWxlbWVudCYmZS5hY3RpdmVFbGVtZW50LmZvY3VzJiZlLmFjdGl2ZUVsZW1lbnQuZm9jdXMoKX1kb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGUuaWZyYW1lKTt3aW5kb3cuc2Nyb2xsVG9wPWUud2luZG93U2Nyb2xsVG9wO3dpbmRvdy5zY3JvbGxMZWZ0PWUud2luZG93U2Nyb2xsTGVmdDtkb2N1bWVudC5ib2R5LnNjcm9sbFRvcD1lLmJvZHlTY3JvbGxUb3A7ZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0PWUuYm9keVNjcm9sbExlZnR9ZnVuY3Rpb24gZGV0ZWN0Rm9jdXMoZSl7dmFyIG49YmVmb3JlKCk7dmFyIHQ9e307T2JqZWN0LmtleXMoZSkubWFwKChmdW5jdGlvbihyKXt0W3JdPXRlc3QobixlW3JdKX0pKTthZnRlcihuKTtyZXR1cm4gdH12YXIgdz1cIjEuNC4xXCI7ZnVuY3Rpb24gcmVhZExvY2FsU3RvcmFnZShlKXt2YXIgbj12b2lkIDA7dHJ5e249d2luZG93LmxvY2FsU3RvcmFnZSYmd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKGUpO249bj9KU09OLnBhcnNlKG4pOnt9fWNhdGNoKGUpe249e319cmV0dXJuIG59ZnVuY3Rpb24gd3JpdGVMb2NhbFN0b3JhZ2UoZSxuKXtpZighZG9jdW1lbnQuaGFzRm9jdXMoKSl7dHJ5e3dpbmRvdy5sb2NhbFN0b3JhZ2UmJndpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShlKX1jYXRjaChlKXt9cmV0dXJufXRyeXt3aW5kb3cubG9jYWxTdG9yYWdlJiZ3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oZSxKU09OLnN0cmluZ2lmeShuKSl9Y2F0Y2goZSl7fX12YXIgXz10eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIiYmd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnR8fFwiXCI7dmFyIEU9XCJhbGx5LXN1cHBvcnRzLWNhY2hlXCI7dmFyIGo9cmVhZExvY2FsU3RvcmFnZShFKTtpZihqLnVzZXJBZ2VudCE9PV98fGoudmVyc2lvbiE9PXcpe2o9e319ai51c2VyQWdlbnQ9XztqLnZlcnNpb249dzt2YXIgTz17Z2V0OmZ1bmN0aW9uIGdldCgpe3JldHVybiBqfSxzZXQ6ZnVuY3Rpb24gc2V0KGUpe09iamVjdC5rZXlzKGUpLmZvckVhY2goKGZ1bmN0aW9uKG4pe2pbbl09ZVtuXX0pKTtqLnRpbWU9KG5ldyBEYXRlKS50b0lTT1N0cmluZygpO3dyaXRlTG9jYWxTdG9yYWdlKEUsail9fTtmdW5jdGlvbiBjc3NTaGFkb3dQaWVyY2luZ0RlZXBDb21iaW5hdG9yKCl7dmFyIGU9dm9pZCAwO3RyeXtkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiaHRtbCA+Pj4gOmZpcnN0LWNoaWxkXCIpO2U9XCI+Pj5cIn1jYXRjaChuKXt0cnl7ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImh0bWwgL2RlZXAvIDpmaXJzdC1jaGlsZFwiKTtlPVwiL2RlZXAvXCJ9Y2F0Y2gobil7ZT1cIlwifX1yZXR1cm4gZX12YXIgaz1cImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFBQUFBQUFQLy8veUg1QkFFQUFBQUFMQUFBQUFBQkFBRUFBQUlCUkFBN1wiO3ZhciBTPXtlbGVtZW50OlwiZGl2XCIsbXV0YXRlOmZ1bmN0aW9uIG11dGF0ZShlKXtlLmlubmVySFRNTD0nPG1hcCBuYW1lPVwiaW1hZ2UtbWFwLXRhYmluZGV4LXRlc3RcIj4nKyc8YXJlYSBzaGFwZT1cInJlY3RcIiBjb29yZHM9XCI2MywxOSwxNDQsNDVcIj48L21hcD4nKyc8aW1nIHVzZW1hcD1cIiNpbWFnZS1tYXAtdGFiaW5kZXgtdGVzdFwiIHRhYmluZGV4PVwiLTFcIiBhbHQ9XCJcIiBzcmM9XCInK2srJ1wiPic7cmV0dXJuIGUucXVlcnlTZWxlY3RvcihcImFyZWFcIil9fTt2YXIgVD17ZWxlbWVudDpcImRpdlwiLG11dGF0ZTpmdW5jdGlvbiBtdXRhdGUoZSl7ZS5pbm5lckhUTUw9JzxtYXAgbmFtZT1cImltYWdlLW1hcC10YWJpbmRleC10ZXN0XCI+JysnPGFyZWEgaHJlZj1cIiN2b2lkXCIgdGFiaW5kZXg9XCItMVwiIHNoYXBlPVwicmVjdFwiIGNvb3Jkcz1cIjYzLDE5LDE0NCw0NVwiPjwvbWFwPicrJzxpbWcgdXNlbWFwPVwiI2ltYWdlLW1hcC10YWJpbmRleC10ZXN0XCIgYWx0PVwiXCIgc3JjPVwiJytrKydcIj4nO3JldHVybiBmYWxzZX0sdmFsaWRhdGU6ZnVuY3Rpb24gdmFsaWRhdGUoZSxuLHQpe2lmKHMuaXMuR0VDS08pe3JldHVybiB0cnVlfXZhciByPWUucXVlcnlTZWxlY3RvcihcImFyZWFcIik7ci5mb2N1cygpO3JldHVybiB0LmFjdGl2ZUVsZW1lbnQ9PT1yfX07dmFyIEM9e2VsZW1lbnQ6XCJkaXZcIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe2UuaW5uZXJIVE1MPSc8bWFwIG5hbWU9XCJpbWFnZS1tYXAtYXJlYS1ocmVmLXRlc3RcIj4nKyc8YXJlYSBzaGFwZT1cInJlY3RcIiBjb29yZHM9XCI2MywxOSwxNDQsNDVcIj48L21hcD4nKyc8aW1nIHVzZW1hcD1cIiNpbWFnZS1tYXAtYXJlYS1ocmVmLXRlc3RcIiBhbHQ9XCJcIiBzcmM9XCInK2srJ1wiPic7cmV0dXJuIGUucXVlcnlTZWxlY3RvcihcImFyZWFcIil9LHZhbGlkYXRlOmZ1bmN0aW9uIHZhbGlkYXRlKGUsbix0KXtpZihzLmlzLkdFQ0tPKXtyZXR1cm4gdHJ1ZX1yZXR1cm4gdC5hY3RpdmVFbGVtZW50PT09bn19O3ZhciBEPXtuYW1lOlwiY2FuLWZvY3VzLWF1ZGlvLXdpdGhvdXQtY29udHJvbHNcIixlbGVtZW50OlwiYXVkaW9cIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe3RyeXtlLnNldEF0dHJpYnV0ZShcInNyY1wiLGspfWNhdGNoKGUpe319fTt2YXIgTT1cImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFBQUFBQUFQLy8vWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlwiO3ZhciBQPXtlbGVtZW50OlwiZGl2XCIsbXV0YXRlOmZ1bmN0aW9uIG11dGF0ZShlKXtlLmlubmVySFRNTD0nPG1hcCBuYW1lPVwiYnJva2VuLWltYWdlLW1hcC10ZXN0XCI+PGFyZWEgaHJlZj1cIiN2b2lkXCIgc2hhcGU9XCJyZWN0XCIgY29vcmRzPVwiNjMsMTksMTQ0LDQ1XCI+PC9tYXA+JysnPGltZyB1c2VtYXA9XCIjYnJva2VuLWltYWdlLW1hcC10ZXN0XCIgYWx0PVwiXCIgc3JjPVwiJytNKydcIj4nO3JldHVybiBlLnF1ZXJ5U2VsZWN0b3IoXCJhcmVhXCIpfX07dmFyIHo9e2VsZW1lbnQ6XCJkaXZcIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe2Uuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIixcIi0xXCIpO2Uuc2V0QXR0cmlidXRlKFwic3R5bGVcIixcImRpc3BsYXk6IC13ZWJraXQtZmxleDsgZGlzcGxheTogLW1zLWZsZXhib3g7IGRpc3BsYXk6IGZsZXg7XCIpO2UuaW5uZXJIVE1MPSc8c3BhbiBzdHlsZT1cImRpc3BsYXk6IGJsb2NrO1wiPmhlbGxvPC9zcGFuPic7cmV0dXJuIGUucXVlcnlTZWxlY3RvcihcInNwYW5cIil9fTt2YXIgQT17ZWxlbWVudDpcImZpZWxkc2V0XCIsbXV0YXRlOmZ1bmN0aW9uIG11dGF0ZShlKXtlLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsMCk7ZS5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLFwiZGlzYWJsZWRcIil9fTt2YXIgTj17ZWxlbWVudDpcImZpZWxkc2V0XCIsbXV0YXRlOmZ1bmN0aW9uIG11dGF0ZShlKXtlLmlubmVySFRNTD1cIjxsZWdlbmQ+bGVnZW5kPC9sZWdlbmQ+PHA+Y29udGVudDwvcD5cIn19O3ZhciBSPXtlbGVtZW50Olwic3BhblwiLG11dGF0ZTpmdW5jdGlvbiBtdXRhdGUoZSl7ZS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLFwiZGlzcGxheTogLXdlYmtpdC1mbGV4OyBkaXNwbGF5OiAtbXMtZmxleGJveDsgZGlzcGxheTogZmxleDtcIik7ZS5pbm5lckhUTUw9JzxzcGFuIHN0eWxlPVwiZGlzcGxheTogYmxvY2s7XCI+aGVsbG88L3NwYW4+J319O3ZhciBJPXtlbGVtZW50OlwiZm9ybVwiLG11dGF0ZTpmdW5jdGlvbiBtdXRhdGUoZSl7ZS5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLDApO2Uuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIixcImRpc2FibGVkXCIpfX07dmFyIEY9e2VsZW1lbnQ6XCJhXCIsbXV0YXRlOmZ1bmN0aW9uIG11dGF0ZShlKXtlLmhyZWY9XCIjdm9pZFwiO2UuaW5uZXJIVE1MPSc8aW1nIGlzbWFwIHNyYz1cIicraysnXCIgYWx0PVwiXCI+JztyZXR1cm4gZS5xdWVyeVNlbGVjdG9yKFwiaW1nXCIpfX07dmFyIEw9e2VsZW1lbnQ6XCJkaXZcIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe2UuaW5uZXJIVE1MPSc8bWFwIG5hbWU9XCJpbWFnZS1tYXAtdGFiaW5kZXgtdGVzdFwiPjxhcmVhIGhyZWY9XCIjdm9pZFwiIHNoYXBlPVwicmVjdFwiIGNvb3Jkcz1cIjYzLDE5LDE0NCw0NVwiPjwvbWFwPicrJzxpbWcgdXNlbWFwPVwiI2ltYWdlLW1hcC10YWJpbmRleC10ZXN0XCIgdGFiaW5kZXg9XCItMVwiIGFsdD1cIlwiICcrJ3NyYz1cIicraysnXCI+JztyZXR1cm4gZS5xdWVyeVNlbGVjdG9yKFwiaW1nXCIpfX07dmFyIEI9e2VsZW1lbnQ6ZnVuY3Rpb24gZWxlbWVudChlLG4pe3ZhciB0PW4uY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtlLmFwcGVuZENoaWxkKHQpO3ZhciByPXQuY29udGVudFdpbmRvdy5kb2N1bWVudDtyLm9wZW4oKTtyLmNsb3NlKCk7cmV0dXJuIHR9LG11dGF0ZTpmdW5jdGlvbiBtdXRhdGUoZSl7ZS5zdHlsZS52aXNpYmlsaXR5PVwiaGlkZGVuXCI7dmFyIG49ZS5jb250ZW50V2luZG93LmRvY3VtZW50O3ZhciB0PW4uY3JlYXRlRWxlbWVudChcImlucHV0XCIpO24uYm9keS5hcHBlbmRDaGlsZCh0KTtyZXR1cm4gdH0sdmFsaWRhdGU6ZnVuY3Rpb24gdmFsaWRhdGUoZSl7dmFyIG49ZS5jb250ZW50V2luZG93LmRvY3VtZW50O3ZhciB0PW4ucXVlcnlTZWxlY3RvcihcImlucHV0XCIpO3JldHVybiBuLmFjdGl2ZUVsZW1lbnQ9PT10fX07dmFyIEg9IXMuaXMuV0VCS0lUO2Z1bmN0aW9uIGZvY3VzSW5aZXJvRGltZW5zaW9uT2JqZWN0KCl7cmV0dXJuIEh9dmFyIHE9e2VsZW1lbnQ6XCJkaXZcIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe2Uuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIixcImludmFsaWQtdmFsdWVcIil9fTt2YXIgVT17ZWxlbWVudDpcImxhYmVsXCIsbXV0YXRlOmZ1bmN0aW9uIG11dGF0ZShlKXtlLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsXCItMVwiKX0sdmFsaWRhdGU6ZnVuY3Rpb24gdmFsaWRhdGUoZSxuLHQpe3ZhciByPWUub2Zmc2V0SGVpZ2h0O2UuZm9jdXMoKTtyZXR1cm4gdC5hY3RpdmVFbGVtZW50PT09ZX19O3ZhciBXPVwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhodGJcIitcIkc1ek9uaHNhVzVyUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMM2hzYVc1cklpQnBaRDBpYzNabklqNDhkR1Y0ZENCNFBTSXhNQ0lnZVQwaU1qQWlJR2xrUFNKXCIrXCJ6ZG1jdGJHbHVheTEwWlhoMElqNTBaWGgwUEM5MFpYaDBQand2YzNablBnPT1cIjt2YXIgVj17ZWxlbWVudDpcIm9iamVjdFwiLG11dGF0ZTpmdW5jdGlvbiBtdXRhdGUoZSl7ZS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsXCJpbWFnZS9zdmcreG1sXCIpO2Uuc2V0QXR0cmlidXRlKFwiZGF0YVwiLFcpO2Uuc2V0QXR0cmlidXRlKFwid2lkdGhcIixcIjIwMFwiKTtlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLFwiNTBcIik7ZS5zdHlsZS52aXNpYmlsaXR5PVwiaGlkZGVuXCJ9fTt2YXIgSz17bmFtZTpcImNhbi1mb2N1cy1vYmplY3Qtc3ZnXCIsZWxlbWVudDpcIm9iamVjdFwiLG11dGF0ZTpmdW5jdGlvbiBtdXRhdGUoZSl7ZS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsXCJpbWFnZS9zdmcreG1sXCIpO2Uuc2V0QXR0cmlidXRlKFwiZGF0YVwiLFcpO2Uuc2V0QXR0cmlidXRlKFwid2lkdGhcIixcIjIwMFwiKTtlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLFwiNTBcIil9LHZhbGlkYXRlOmZ1bmN0aW9uIHZhbGlkYXRlKGUsbix0KXtpZihzLmlzLkdFQ0tPKXtyZXR1cm4gdHJ1ZX1yZXR1cm4gdC5hY3RpdmVFbGVtZW50PT09ZX19O3ZhciBaPSFzLmlzLklFOTtmdW5jdGlvbiBmb2N1c09iamVjdFN3Zigpe3JldHVybiBafXZhciBHPXtlbGVtZW50OlwiZGl2XCIsbXV0YXRlOmZ1bmN0aW9uIG11dGF0ZShlKXtlLmlubmVySFRNTD0nPG1hcCBuYW1lPVwiZm9jdXMtcmVkaXJlY3QtaW1nLXVzZW1hcFwiPjxhcmVhIGhyZWY9XCIjdm9pZFwiIHNoYXBlPVwicmVjdFwiIGNvb3Jkcz1cIjYzLDE5LDE0NCw0NVwiPjwvbWFwPicrJzxpbWcgdXNlbWFwPVwiI2ZvY3VzLXJlZGlyZWN0LWltZy11c2VtYXBcIiBhbHQ9XCJcIiAnKydzcmM9XCInK2srJ1wiPic7cmV0dXJuIGUucXVlcnlTZWxlY3RvcihcImltZ1wiKX0sdmFsaWRhdGU6ZnVuY3Rpb24gdmFsaWRhdGUoZSxuLHQpe3ZhciByPWUucXVlcnlTZWxlY3RvcihcImFyZWFcIik7cmV0dXJuIHQuYWN0aXZlRWxlbWVudD09PXJ9fTt2YXIgWT17ZWxlbWVudDpcImZpZWxkc2V0XCIsbXV0YXRlOmZ1bmN0aW9uIG11dGF0ZShlKXtlLmlubmVySFRNTD0nPGxlZ2VuZD5sZWdlbmQ8L2xlZ2VuZD48aW5wdXQgdGFiaW5kZXg9XCItMVwiPjxpbnB1dCB0YWJpbmRleD1cIjBcIj4nO3JldHVybiBmYWxzZX0sdmFsaWRhdGU6ZnVuY3Rpb24gdmFsaWRhdGUoZSxuLHQpe3ZhciByPWUucXVlcnlTZWxlY3RvcignaW5wdXRbdGFiaW5kZXg9XCItMVwiXScpO3ZhciBhPWUucXVlcnlTZWxlY3RvcignaW5wdXRbdGFiaW5kZXg9XCIwXCJdJyk7ZS5mb2N1cygpO2UucXVlcnlTZWxlY3RvcihcImxlZ2VuZFwiKS5mb2N1cygpO3JldHVybiB0LmFjdGl2ZUVsZW1lbnQ9PT1yJiZcImZvY3VzYWJsZVwifHx0LmFjdGl2ZUVsZW1lbnQ9PT1hJiZcInRhYmJhYmxlXCJ8fFwiXCJ9fTt2YXIgSj17ZWxlbWVudDpcImRpdlwiLG11dGF0ZTpmdW5jdGlvbiBtdXRhdGUoZSl7ZS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLFwid2lkdGg6IDEwMHB4OyBoZWlnaHQ6IDUwcHg7IG92ZXJmbG93OiBhdXRvO1wiKTtlLmlubmVySFRNTD0nPGRpdiBzdHlsZT1cIndpZHRoOiA1MDBweDsgaGVpZ2h0OiA0MHB4O1wiPnNjcm9sbGFibGUgY29udGVudDwvZGl2Pic7cmV0dXJuIGUucXVlcnlTZWxlY3RvcihcImRpdlwiKX19O3ZhciAkPXtlbGVtZW50OlwiZGl2XCIsbXV0YXRlOmZ1bmN0aW9uIG11dGF0ZShlKXtlLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsXCJ3aWR0aDogMTAwcHg7IGhlaWdodDogNTBweDtcIik7ZS5pbm5lckhUTUw9JzxkaXYgc3R5bGU9XCJ3aWR0aDogNTAwcHg7IGhlaWdodDogNDBweDtcIj5zY3JvbGxhYmxlIGNvbnRlbnQ8L2Rpdj4nfX07dmFyIFg9e2VsZW1lbnQ6XCJkaXZcIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe2Uuc2V0QXR0cmlidXRlKFwic3R5bGVcIixcIndpZHRoOiAxMDBweDsgaGVpZ2h0OiA1MHB4OyBvdmVyZmxvdzogYXV0bztcIik7ZS5pbm5lckhUTUw9JzxkaXYgc3R5bGU9XCJ3aWR0aDogNTAwcHg7IGhlaWdodDogNDBweDtcIj5zY3JvbGxhYmxlIGNvbnRlbnQ8L2Rpdj4nfX07dmFyIFE9e2VsZW1lbnQ6XCJkZXRhaWxzXCIsbXV0YXRlOmZ1bmN0aW9uIG11dGF0ZShlKXtlLmlubmVySFRNTD1cIjxzdW1tYXJ5PmZvbzwvc3VtbWFyeT48cD5jb250ZW50PC9wPlwiO3JldHVybiBlLmZpcnN0RWxlbWVudENoaWxkfX07ZnVuY3Rpb24gbWFrZUZvY3VzYWJsZUZvcmVpZ25PYmplY3QoKXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFwiZm9yZWlnbk9iamVjdFwiKTtlLndpZHRoLmJhc2VWYWwudmFsdWU9MzA7ZS5oZWlnaHQuYmFzZVZhbC52YWx1ZT0zMDtlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSk7ZS5sYXN0Q2hpbGQudHlwZT1cInRleHRcIjtyZXR1cm4gZX1mdW5jdGlvbiBmb2N1c1N2Z0ZvcmVpZ25PYmplY3RIYWNrKGUpe3ZhciBuPWUub3duZXJTVkdFbGVtZW50fHxlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT1cInN2Z1wiO2lmKCFuKXtyZXR1cm4gZmFsc2V9dmFyIHQ9bWFrZUZvY3VzYWJsZUZvcmVpZ25PYmplY3QoKTtlLmFwcGVuZENoaWxkKHQpO3ZhciByPXQucXVlcnlTZWxlY3RvcihcImlucHV0XCIpO3IuZm9jdXMoKTtyLmRpc2FibGVkPXRydWU7ZS5yZW1vdmVDaGlsZCh0KTtyZXR1cm4gdHJ1ZX1mdW5jdGlvbiBnZW5lcmF0ZShlKXtyZXR1cm4nPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCI+JytlK1wiPC9zdmc+XCJ9ZnVuY3Rpb24gZm9jdXMoZSl7aWYoZS5mb2N1cyl7cmV0dXJufXRyeXtIVE1MRWxlbWVudC5wcm90b3R5cGUuZm9jdXMuY2FsbChlKX1jYXRjaChuKXtmb2N1c1N2Z0ZvcmVpZ25PYmplY3RIYWNrKGUpfX1mdW5jdGlvbiB2YWxpZGF0ZShlLG4sdCl7Zm9jdXMobik7cmV0dXJuIHQuYWN0aXZlRWxlbWVudD09PW59dmFyIGVlPXtlbGVtZW50OlwiZGl2XCIsbXV0YXRlOmZ1bmN0aW9uIG11dGF0ZShlKXtlLmlubmVySFRNTD1nZW5lcmF0ZSgnPHRleHQgZm9jdXNhYmxlPVwidHJ1ZVwiPmE8L3RleHQ+Jyk7cmV0dXJuIGUucXVlcnlTZWxlY3RvcihcInRleHRcIil9LHZhbGlkYXRlOnZhbGlkYXRlfTt2YXIgbmU9e2VsZW1lbnQ6XCJkaXZcIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe2UuaW5uZXJIVE1MPWdlbmVyYXRlKCc8dGV4dCB0YWJpbmRleD1cIjBcIj5hPC90ZXh0PicpO3JldHVybiBlLnF1ZXJ5U2VsZWN0b3IoXCJ0ZXh0XCIpfSx2YWxpZGF0ZTp2YWxpZGF0ZX07dmFyIHRlPXtlbGVtZW50OlwiZGl2XCIsbXV0YXRlOmZ1bmN0aW9uIG11dGF0ZShlKXtlLmlubmVySFRNTD1nZW5lcmF0ZSgnPHRleHQgdGFiaW5kZXg9XCItMVwiPmE8L3RleHQ+Jyk7cmV0dXJuIGUucXVlcnlTZWxlY3RvcihcInRleHRcIil9LHZhbGlkYXRlOnZhbGlkYXRlfTt2YXIgcmU9e2VsZW1lbnQ6XCJkaXZcIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe2UuaW5uZXJIVE1MPWdlbmVyYXRlKFsnPGcgaWQ9XCJhbGx5LXRlc3QtdGFyZ2V0XCI+PGEgeGxpbms6aHJlZj1cIiN2b2lkXCI+PHRleHQ+bGluazwvdGV4dD48L2E+PC9nPicsJzx1c2UgeGxpbms6aHJlZj1cIiNhbGx5LXRlc3QtdGFyZ2V0XCIgeD1cIjBcIiB5PVwiMFwiIHRhYmluZGV4PVwiLTFcIiAvPiddLmpvaW4oXCJcIikpO3JldHVybiBlLnF1ZXJ5U2VsZWN0b3IoXCJ1c2VcIil9LHZhbGlkYXRlOnZhbGlkYXRlfTt2YXIgYWU9e2VsZW1lbnQ6XCJkaXZcIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe2UuaW5uZXJIVE1MPWdlbmVyYXRlKCc8Zm9yZWlnbk9iamVjdCB0YWJpbmRleD1cIi0xXCI+PGlucHV0IHR5cGU9XCJ0ZXh0XCIgLz48L2ZvcmVpZ25PYmplY3Q+Jyk7cmV0dXJuIGUucXVlcnlTZWxlY3RvcihcImZvcmVpZ25PYmplY3RcIil8fGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJmb3JlaWduT2JqZWN0XCIpWzBdfSx2YWxpZGF0ZTp2YWxpZGF0ZX07dmFyIG9lPUJvb2xlYW4ocy5pcy5HRUNLTyYmdHlwZW9mIFNWR0VsZW1lbnQhPT1cInVuZGVmaW5lZFwiJiZTVkdFbGVtZW50LnByb3RvdHlwZS5mb2N1cyk7ZnVuY3Rpb24gZm9jdXNTdmdJbklmcmFtZSgpe3JldHVybiBvZX12YXIgaWU9e2VsZW1lbnQ6XCJkaXZcIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe2UuaW5uZXJIVE1MPWdlbmVyYXRlKFwiXCIpO3JldHVybiBlLmZpcnN0Q2hpbGR9LHZhbGlkYXRlOnZhbGlkYXRlfTt2YXIgbGU9e2VsZW1lbnQ6XCJkaXZcIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe2Uuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIixcIjN4XCIpfX07dmFyIHNlPXtlbGVtZW50OlwidGFibGVcIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUsbix0KXt2YXIgcj10LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtyLmlubmVySFRNTD1cIjx0cj48dGQ+Y2VsbDwvdGQ+PC90cj5cIjtlLmFwcGVuZENoaWxkKHIpfX07dmFyIHVlPXtlbGVtZW50OlwidmlkZW9cIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe3RyeXtlLnNldEF0dHJpYnV0ZShcInNyY1wiLGspfWNhdGNoKGUpe319fTt2YXIgY2U9cy5pcy5HRUNLT3x8cy5pcy5UUklERU5UfHxzLmlzLkVER0U7ZnVuY3Rpb24gdGFic2VxdWVuY2VBcmVhQXRJbWdQb3NpdGlvbigpe3JldHVybiBjZX12YXIgZmU9e2Nzc1NoYWRvd1BpZXJjaW5nRGVlcENvbWJpbmF0b3I6Y3NzU2hhZG93UGllcmNpbmdEZWVwQ29tYmluYXRvcixmb2N1c0luWmVyb0RpbWVuc2lvbk9iamVjdDpmb2N1c0luWmVyb0RpbWVuc2lvbk9iamVjdCxmb2N1c09iamVjdFN3Zjpmb2N1c09iamVjdFN3Zixmb2N1c1N2Z0luSWZyYW1lOmZvY3VzU3ZnSW5JZnJhbWUsdGFic2VxdWVuY2VBcmVhQXRJbWdQb3NpdGlvbjp0YWJzZXF1ZW5jZUFyZWFBdEltZ1Bvc2l0aW9ufTt2YXIgZGU9e2ZvY3VzQXJlYUltZ1RhYmluZGV4OlMsZm9jdXNBcmVhVGFiaW5kZXg6VCxmb2N1c0FyZWFXaXRob3V0SHJlZjpDLGZvY3VzQXVkaW9XaXRob3V0Q29udHJvbHM6RCxmb2N1c0Jyb2tlbkltYWdlTWFwOlAsZm9jdXNDaGlsZHJlbk9mRm9jdXNhYmxlRmxleGJveDp6LGZvY3VzRmllbGRzZXREaXNhYmxlZDpBLGZvY3VzRmllbGRzZXQ6Tixmb2N1c0ZsZXhib3hDb250YWluZXI6Uixmb2N1c0Zvcm1EaXNhYmxlZDpJLGZvY3VzSW1nSXNtYXA6Rixmb2N1c0ltZ1VzZW1hcFRhYmluZGV4OkwsZm9jdXNJbkhpZGRlbklmcmFtZTpCLGZvY3VzSW52YWxpZFRhYmluZGV4OnEsZm9jdXNMYWJlbFRhYmluZGV4OlUsZm9jdXNPYmplY3RTdmc6Syxmb2N1c09iamVjdFN2Z0hpZGRlbjpWLGZvY3VzUmVkaXJlY3RJbWdVc2VtYXA6Ryxmb2N1c1JlZGlyZWN0TGVnZW5kOlksZm9jdXNTY3JvbGxCb2R5OkosZm9jdXNTY3JvbGxDb250YWluZXJXaXRob3V0T3ZlcmZsb3c6JCxmb2N1c1Njcm9sbENvbnRhaW5lcjpYLGZvY3VzU3VtbWFyeTpRLGZvY3VzU3ZnRm9jdXNhYmxlQXR0cmlidXRlOmVlLGZvY3VzU3ZnVGFiaW5kZXhBdHRyaWJ1dGU6bmUsZm9jdXNTdmdOZWdhdGl2ZVRhYmluZGV4QXR0cmlidXRlOnRlLGZvY3VzU3ZnVXNlVGFiaW5kZXg6cmUsZm9jdXNTdmdGb3JlaWdub2JqZWN0VGFiaW5kZXg6YWUsZm9jdXNTdmc6aWUsZm9jdXNUYWJpbmRleFRyYWlsaW5nQ2hhcmFjdGVyczpsZSxmb2N1c1RhYmxlOnNlLGZvY3VzVmlkZW9XaXRob3V0Q29udHJvbHM6dWV9O2Z1bmN0aW9uIGV4ZWN1dGVUZXN0cygpe3ZhciBlPWRldGVjdEZvY3VzKGRlKTtPYmplY3Qua2V5cyhmZSkuZm9yRWFjaCgoZnVuY3Rpb24obil7ZVtuXT1mZVtuXSgpfSkpO3JldHVybiBlfXZhciB2ZT1udWxsO2Z1bmN0aW9uIF9zdXBwb3J0cygpe2lmKHZlKXtyZXR1cm4gdmV9dmU9Ty5nZXQoKTtpZighdmUudGltZSl7Ty5zZXQoZXhlY3V0ZVRlc3RzKCkpO3ZlPU8uZ2V0KCl9cmV0dXJuIHZlfXZhciBwZT12b2lkIDA7dmFyIG1lPS9eXFxzKigtfFxcKyk/WzAtOV0rXFxzKiQvO3ZhciBiZT0vXlxccyooLXxcXCspP1swLTldKy4qJC87ZnVuY3Rpb24gaXNWYWxpZFRhYmluZGV4KGUpe2lmKCFwZSl7cGU9X3N1cHBvcnRzKCl9dmFyIG49cGUuZm9jdXNUYWJpbmRleFRyYWlsaW5nQ2hhcmFjdGVycz9iZTptZTt2YXIgdD1jb250ZXh0VG9FbGVtZW50KHtsYWJlbDpcImlzL3ZhbGlkLXRhYmluZGV4XCIscmVzb2x2ZURvY3VtZW50OnRydWUsY29udGV4dDplfSk7dmFyIHI9dC5oYXNBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKTt2YXIgYT10Lmhhc0F0dHJpYnV0ZShcInRhYkluZGV4XCIpO2lmKCFyJiYhYSl7cmV0dXJuIGZhbHNlfXZhciBvPXQub3duZXJTVkdFbGVtZW50fHx0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT1cInN2Z1wiO2lmKG8mJiFwZS5mb2N1c1N2Z1RhYmluZGV4QXR0cmlidXRlKXtyZXR1cm4gZmFsc2V9aWYocGUuZm9jdXNJbnZhbGlkVGFiaW5kZXgpe3JldHVybiB0cnVlfXZhciBpPXQuZ2V0QXR0cmlidXRlKHI/XCJ0YWJpbmRleFwiOlwidGFiSW5kZXhcIik7aWYoaT09PVwiLTMyNzY4XCIpe3JldHVybiBmYWxzZX1yZXR1cm4gQm9vbGVhbihpJiZuLnRlc3QoaSkpfWZ1bmN0aW9uIHRhYmluZGV4VmFsdWUoZSl7aWYoIWlzVmFsaWRUYWJpbmRleChlKSl7cmV0dXJuIG51bGx9dmFyIG49ZS5oYXNBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKTt2YXIgdD1uP1widGFiaW5kZXhcIjpcInRhYkluZGV4XCI7dmFyIHI9cGFyc2VJbnQoZS5nZXRBdHRyaWJ1dGUodCksMTApO3JldHVybiBpc05hTihyKT8tMTpyfWZ1bmN0aW9uIGlzVXNlck1vZGlmeVdyaXRhYmxlKGUpe3ZhciBuPWUud2Via2l0VXNlck1vZGlmeXx8XCJcIjtyZXR1cm4gQm9vbGVhbihuJiZuLmluZGV4T2YoXCJ3cml0ZVwiKSE9PS0xKX1mdW5jdGlvbiBoYXNDc3NPdmVyZmxvd1Njcm9sbChlKXtyZXR1cm5bZS5nZXRQcm9wZXJ0eVZhbHVlKFwib3ZlcmZsb3dcIiksZS5nZXRQcm9wZXJ0eVZhbHVlKFwib3ZlcmZsb3cteFwiKSxlLmdldFByb3BlcnR5VmFsdWUoXCJvdmVyZmxvdy15XCIpXS5zb21lKChmdW5jdGlvbihlKXtyZXR1cm4gZT09PVwiYXV0b1wifHxlPT09XCJzY3JvbGxcIn0pKX1mdW5jdGlvbiBoYXNDc3NEaXNwbGF5RmxleChlKXtyZXR1cm4gZS5kaXNwbGF5LmluZGV4T2YoXCJmbGV4XCIpPi0xfWZ1bmN0aW9uIGlzU2Nyb2xsYWJsZUNvbnRhaW5lcihlLG4sdCxyKXtpZihuIT09XCJkaXZcIiYmbiE9PVwic3BhblwiKXtyZXR1cm4gZmFsc2V9aWYodCYmdCE9PVwiZGl2XCImJnQhPT1cInNwYW5cIiYmIWhhc0Nzc092ZXJmbG93U2Nyb2xsKHIpKXtyZXR1cm4gZmFsc2V9cmV0dXJuIGUub2Zmc2V0SGVpZ2h0PGUuc2Nyb2xsSGVpZ2h0fHxlLm9mZnNldFdpZHRoPGUuc2Nyb2xsV2lkdGh9dmFyIGdlPXZvaWQgMDtmdW5jdGlvbiBpc0ZvY3VzUmVsZXZhbnRSdWxlcygpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1swXTp7fSxuPWUuY29udGV4dCx0PWUuZXhjZXB0LHI9dD09PXVuZGVmaW5lZD97ZmxleGJveDpmYWxzZSxzY3JvbGxhYmxlOmZhbHNlLHNoYWRvdzpmYWxzZX06dDtpZighZ2Upe2dlPV9zdXBwb3J0cygpfXZhciBhPWNvbnRleHRUb0VsZW1lbnQoe2xhYmVsOlwiaXMvZm9jdXMtcmVsZXZhbnRcIixyZXNvbHZlRG9jdW1lbnQ6dHJ1ZSxjb250ZXh0Om59KTtpZighci5zaGFkb3cmJmEuc2hhZG93Um9vdCl7cmV0dXJuIHRydWV9dmFyIG89YS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO2lmKG89PT1cImlucHV0XCImJmEudHlwZT09PVwiaGlkZGVuXCIpe3JldHVybiBmYWxzZX1pZihvPT09XCJpbnB1dFwifHxvPT09XCJzZWxlY3RcInx8bz09PVwiYnV0dG9uXCJ8fG89PT1cInRleHRhcmVhXCIpe3JldHVybiB0cnVlfWlmKG89PT1cImxlZ2VuZFwiJiZnZS5mb2N1c1JlZGlyZWN0TGVnZW5kKXtyZXR1cm4gdHJ1ZX1pZihvPT09XCJsYWJlbFwiKXtyZXR1cm4gdHJ1ZX1pZihvPT09XCJhcmVhXCIpe3JldHVybiB0cnVlfWlmKG89PT1cImFcIiYmYS5oYXNBdHRyaWJ1dGUoXCJocmVmXCIpKXtyZXR1cm4gdHJ1ZX1pZihvPT09XCJvYmplY3RcIiYmYS5oYXNBdHRyaWJ1dGUoXCJ1c2VtYXBcIikpe3JldHVybiBmYWxzZX1pZihvPT09XCJvYmplY3RcIil7dmFyIGk9YS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpO2lmKCFnZS5mb2N1c09iamVjdFN2ZyYmaT09PVwiaW1hZ2Uvc3ZnK3htbFwiKXtyZXR1cm4gZmFsc2V9ZWxzZSBpZighZ2UuZm9jdXNPYmplY3RTd2YmJmk9PT1cImFwcGxpY2F0aW9uL3gtc2hvY2t3YXZlLWZsYXNoXCIpe3JldHVybiBmYWxzZX19aWYobz09PVwiaWZyYW1lXCJ8fG89PT1cIm9iamVjdFwiKXtyZXR1cm4gdHJ1ZX1pZihvPT09XCJlbWJlZFwifHxvPT09XCJrZXlnZW5cIil7cmV0dXJuIHRydWV9aWYoYS5oYXNBdHRyaWJ1dGUoXCJjb250ZW50ZWRpdGFibGVcIikpe3JldHVybiB0cnVlfWlmKG89PT1cImF1ZGlvXCImJihnZS5mb2N1c0F1ZGlvV2l0aG91dENvbnRyb2xzfHxhLmhhc0F0dHJpYnV0ZShcImNvbnRyb2xzXCIpKSl7cmV0dXJuIHRydWV9aWYobz09PVwidmlkZW9cIiYmKGdlLmZvY3VzVmlkZW9XaXRob3V0Q29udHJvbHN8fGEuaGFzQXR0cmlidXRlKFwiY29udHJvbHNcIikpKXtyZXR1cm4gdHJ1ZX1pZihnZS5mb2N1c1N1bW1hcnkmJm89PT1cInN1bW1hcnlcIil7cmV0dXJuIHRydWV9dmFyIGw9aXNWYWxpZFRhYmluZGV4KGEpO2lmKG89PT1cImltZ1wiJiZhLmhhc0F0dHJpYnV0ZShcInVzZW1hcFwiKSl7cmV0dXJuIGwmJmdlLmZvY3VzSW1nVXNlbWFwVGFiaW5kZXh8fGdlLmZvY3VzUmVkaXJlY3RJbWdVc2VtYXB9aWYoZ2UuZm9jdXNUYWJsZSYmKG89PT1cInRhYmxlXCJ8fG89PT1cInRkXCIpKXtyZXR1cm4gdHJ1ZX1pZihnZS5mb2N1c0ZpZWxkc2V0JiZvPT09XCJmaWVsZHNldFwiKXtyZXR1cm4gdHJ1ZX12YXIgcz1vPT09XCJzdmdcIjt2YXIgdT1hLm93bmVyU1ZHRWxlbWVudDt2YXIgYz1hLmdldEF0dHJpYnV0ZShcImZvY3VzYWJsZVwiKTt2YXIgZj10YWJpbmRleFZhbHVlKGEpO2lmKG89PT1cInVzZVwiJiZmIT09bnVsbCYmIWdlLmZvY3VzU3ZnVXNlVGFiaW5kZXgpe3JldHVybiBmYWxzZX1pZihvPT09XCJmb3JlaWdub2JqZWN0XCIpe3JldHVybiBmIT09bnVsbCYmZ2UuZm9jdXNTdmdGb3JlaWdub2JqZWN0VGFiaW5kZXh9aWYoZWxlbWVudE1hdGNoZXMoYSxcInN2ZyBhXCIpJiZhLmhhc0F0dHJpYnV0ZShcInhsaW5rOmhyZWZcIikpe3JldHVybiB0cnVlfWlmKChzfHx1KSYmYS5mb2N1cyYmIWdlLmZvY3VzU3ZnTmVnYXRpdmVUYWJpbmRleEF0dHJpYnV0ZSYmZjwwKXtyZXR1cm4gZmFsc2V9aWYocyl7cmV0dXJuIGx8fGdlLmZvY3VzU3ZnfHxnZS5mb2N1c1N2Z0luSWZyYW1lfHxCb29sZWFuKGdlLmZvY3VzU3ZnRm9jdXNhYmxlQXR0cmlidXRlJiZjJiZjPT09XCJ0cnVlXCIpfWlmKHUpe2lmKGdlLmZvY3VzU3ZnVGFiaW5kZXhBdHRyaWJ1dGUmJmwpe3JldHVybiB0cnVlfWlmKGdlLmZvY3VzU3ZnRm9jdXNhYmxlQXR0cmlidXRlKXtyZXR1cm4gYz09PVwidHJ1ZVwifX1pZihsKXtyZXR1cm4gdHJ1ZX12YXIgZD13aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShhLG51bGwpO2lmKGlzVXNlck1vZGlmeVdyaXRhYmxlKGQpKXtyZXR1cm4gdHJ1ZX1pZihnZS5mb2N1c0ltZ0lzbWFwJiZvPT09XCJpbWdcIiYmYS5oYXNBdHRyaWJ1dGUoXCJpc21hcFwiKSl7dmFyIHY9Z2V0UGFyZW50cyh7Y29udGV4dDphfSkuc29tZSgoZnVuY3Rpb24oZSl7cmV0dXJuIGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKT09PVwiYVwiJiZlLmhhc0F0dHJpYnV0ZShcImhyZWZcIil9KSk7aWYodil7cmV0dXJuIHRydWV9fWlmKCFyLnNjcm9sbGFibGUmJmdlLmZvY3VzU2Nyb2xsQ29udGFpbmVyKXtpZihnZS5mb2N1c1Njcm9sbENvbnRhaW5lcldpdGhvdXRPdmVyZmxvdyl7aWYoaXNTY3JvbGxhYmxlQ29udGFpbmVyKGEsbykpe3JldHVybiB0cnVlfX1lbHNlIGlmKGhhc0Nzc092ZXJmbG93U2Nyb2xsKGQpKXtyZXR1cm4gdHJ1ZX19aWYoIXIuZmxleGJveCYmZ2UuZm9jdXNGbGV4Ym94Q29udGFpbmVyJiZoYXNDc3NEaXNwbGF5RmxleChkKSl7cmV0dXJuIHRydWV9dmFyIHA9YS5wYXJlbnRFbGVtZW50O2lmKCFyLnNjcm9sbGFibGUmJnApe3ZhciBtPXAubm9kZU5hbWUudG9Mb3dlckNhc2UoKTt2YXIgYj13aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwLG51bGwpO2lmKGdlLmZvY3VzU2Nyb2xsQm9keSYmaXNTY3JvbGxhYmxlQ29udGFpbmVyKHAsbyxtLGIpKXtyZXR1cm4gdHJ1ZX1pZihnZS5mb2N1c0NoaWxkcmVuT2ZGb2N1c2FibGVGbGV4Ym94KXtpZihoYXNDc3NEaXNwbGF5RmxleChiKSl7cmV0dXJuIHRydWV9fX1yZXR1cm4gZmFsc2V9aXNGb2N1c1JlbGV2YW50UnVsZXMuZXhjZXB0PWZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZhcmd1bWVudHNbMF0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzBdOnt9O3ZhciBuPWZ1bmN0aW9uIGlzRm9jdXNSZWxldmFudChuKXtyZXR1cm4gaXNGb2N1c1JlbGV2YW50UnVsZXMoe2NvbnRleHQ6bixleGNlcHQ6ZX0pfTtuLnJ1bGVzPWlzRm9jdXNSZWxldmFudFJ1bGVzO3JldHVybiBufTt2YXIgaGU9aXNGb2N1c1JlbGV2YW50UnVsZXMuZXhjZXB0KHt9KTtmdW5jdGlvbiBmaW5kSW5kZXgoZSxuKXtpZihlLmZpbmRJbmRleCl7cmV0dXJuIGUuZmluZEluZGV4KG4pfXZhciB0PWUubGVuZ3RoO2lmKHQ9PT0wKXtyZXR1cm4tMX1mb3IodmFyIHI9MDtyPHQ7cisrKXtpZihuKGVbcl0scixlKSl7cmV0dXJuIHJ9fXJldHVybi0xfWZ1bmN0aW9uIGdldENvbnRlbnREb2N1bWVudChlKXt0cnl7cmV0dXJuIGUuY29udGVudERvY3VtZW50fHxlLmNvbnRlbnRXaW5kb3cmJmUuY29udGVudFdpbmRvdy5kb2N1bWVudHx8ZS5nZXRTVkdEb2N1bWVudCYmZS5nZXRTVkdEb2N1bWVudCgpfHxudWxsfWNhdGNoKGUpe3JldHVybiBudWxsfX1mdW5jdGlvbiBnZXRXaW5kb3coZSl7dmFyIG49Z2V0RG9jdW1lbnQoZSk7cmV0dXJuIG4uZGVmYXVsdFZpZXd8fHdpbmRvd312YXIgeWU9dm9pZCAwO2Z1bmN0aW9uIHNlbGVjdEluU2hhZG93cyhlKXtpZih0eXBlb2YgeWUhPT1cInN0cmluZ1wiKXt2YXIgbj1jc3NTaGFkb3dQaWVyY2luZ0RlZXBDb21iaW5hdG9yKCk7aWYobil7eWU9XCIsIGh0bWwgXCIrbitcIiBcIn19aWYoIXllKXtyZXR1cm4gZX1yZXR1cm4gZSt5ZStlLnJlcGxhY2UoL1xccyosXFxzKi9nLFwiLFwiKS5zcGxpdChcIixcIikuam9pbih5ZSl9dmFyIHhlPXZvaWQgMDtmdW5jdGlvbiBmaW5kRG9jdW1lbnRIb3N0RWxlbWVudChlKXtpZigheGUpe3hlPXNlbGVjdEluU2hhZG93cyhcIm9iamVjdCwgaWZyYW1lXCIpfWlmKGUuX2ZyYW1lRWxlbWVudCE9PXVuZGVmaW5lZCl7cmV0dXJuIGUuX2ZyYW1lRWxlbWVudH1lLl9mcmFtZUVsZW1lbnQ9bnVsbDt2YXIgbj1lLnBhcmVudC5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHhlKTtbXS5zb21lLmNhbGwobiwoZnVuY3Rpb24obil7dmFyIHQ9Z2V0Q29udGVudERvY3VtZW50KG4pO2lmKHQhPT1lLmRvY3VtZW50KXtyZXR1cm4gZmFsc2V9ZS5fZnJhbWVFbGVtZW50PW47cmV0dXJuIHRydWV9KSk7cmV0dXJuIGUuX2ZyYW1lRWxlbWVudH1mdW5jdGlvbiBnZXRGcmFtZUVsZW1lbnQoZSl7dmFyIG49Z2V0V2luZG93KGUpO2lmKCFuLnBhcmVudHx8bi5wYXJlbnQ9PT1uKXtyZXR1cm4gbnVsbH10cnl7cmV0dXJuIG4uZnJhbWVFbGVtZW50fHxmaW5kRG9jdW1lbnRIb3N0RWxlbWVudChuKX1jYXRjaChlKXtyZXR1cm4gbnVsbH19dmFyIHdlPS9eKGFyZWEpJC87ZnVuY3Rpb24gY29tcHV0ZWRTdHlsZShlLG4pe3JldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlLG51bGwpLmdldFByb3BlcnR5VmFsdWUobil9ZnVuY3Rpb24gbm90RGlzcGxheWVkKGUpe3JldHVybiBlLnNvbWUoKGZ1bmN0aW9uKGUpe3JldHVybiBjb21wdXRlZFN0eWxlKGUsXCJkaXNwbGF5XCIpPT09XCJub25lXCJ9KSl9ZnVuY3Rpb24gbm90VmlzaWJsZShlKXt2YXIgbj1maW5kSW5kZXgoZSwoZnVuY3Rpb24oZSl7dmFyIG49Y29tcHV0ZWRTdHlsZShlLFwidmlzaWJpbGl0eVwiKTtyZXR1cm4gbj09PVwiaGlkZGVuXCJ8fG49PT1cImNvbGxhcHNlXCJ9KSk7aWYobj09PS0xKXtyZXR1cm4gZmFsc2V9dmFyIHQ9ZmluZEluZGV4KGUsKGZ1bmN0aW9uKGUpe3JldHVybiBjb21wdXRlZFN0eWxlKGUsXCJ2aXNpYmlsaXR5XCIpPT09XCJ2aXNpYmxlXCJ9KSk7aWYodD09PS0xKXtyZXR1cm4gdHJ1ZX1pZihuPHQpe3JldHVybiB0cnVlfXJldHVybiBmYWxzZX1mdW5jdGlvbiBjb2xsYXBzZWRQYXJlbnQoZSl7dmFyIG49MTtpZihlWzBdLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT1cInN1bW1hcnlcIil7bj0yfXJldHVybiBlLnNsaWNlKG4pLnNvbWUoKGZ1bmN0aW9uKGUpe3JldHVybiBlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT1cImRldGFpbHNcIiYmZS5vcGVuPT09ZmFsc2V9KSl9ZnVuY3Rpb24gaXNWaXNpYmxlUnVsZXMoKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMF06e30sbj1lLmNvbnRleHQsdD1lLmV4Y2VwdCxyPXQ9PT11bmRlZmluZWQ/e25vdFJlbmRlcmVkOmZhbHNlLGNzc0Rpc3BsYXk6ZmFsc2UsY3NzVmlzaWJpbGl0eTpmYWxzZSxkZXRhaWxzRWxlbWVudDpmYWxzZSxicm93c2luZ0NvbnRleHQ6ZmFsc2V9OnQ7dmFyIGE9Y29udGV4dFRvRWxlbWVudCh7bGFiZWw6XCJpcy92aXNpYmxlXCIscmVzb2x2ZURvY3VtZW50OnRydWUsY29udGV4dDpufSk7dmFyIG89YS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO2lmKCFyLm5vdFJlbmRlcmVkJiZ3ZS50ZXN0KG8pKXtyZXR1cm4gdHJ1ZX12YXIgaT1nZXRQYXJlbnRzKHtjb250ZXh0OmF9KTt2YXIgbD1vPT09XCJhdWRpb1wiJiYhYS5oYXNBdHRyaWJ1dGUoXCJjb250cm9sc1wiKTtpZighci5jc3NEaXNwbGF5JiZub3REaXNwbGF5ZWQobD9pLnNsaWNlKDEpOmkpKXtyZXR1cm4gZmFsc2V9aWYoIXIuY3NzVmlzaWJpbGl0eSYmbm90VmlzaWJsZShpKSl7cmV0dXJuIGZhbHNlfWlmKCFyLmRldGFpbHNFbGVtZW50JiZjb2xsYXBzZWRQYXJlbnQoaSkpe3JldHVybiBmYWxzZX1pZighci5icm93c2luZ0NvbnRleHQpe3ZhciBzPWdldEZyYW1lRWxlbWVudChhKTt2YXIgdT1pc1Zpc2libGVSdWxlcy5leGNlcHQocik7aWYocyYmIXUocykpe3JldHVybiBmYWxzZX19cmV0dXJuIHRydWV9aXNWaXNpYmxlUnVsZXMuZXhjZXB0PWZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZhcmd1bWVudHNbMF0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzBdOnt9O3ZhciBuPWZ1bmN0aW9uIGlzVmlzaWJsZShuKXtyZXR1cm4gaXNWaXNpYmxlUnVsZXMoe2NvbnRleHQ6bixleGNlcHQ6ZX0pfTtuLnJ1bGVzPWlzVmlzaWJsZVJ1bGVzO3JldHVybiBufTt2YXIgX2U9aXNWaXNpYmxlUnVsZXMuZXhjZXB0KHt9KTtmdW5jdGlvbiBnZXRNYXBCeU5hbWUoZSxuKXt2YXIgdD1uLnF1ZXJ5U2VsZWN0b3IoJ21hcFtuYW1lPVwiJysoMCxvW1wiZGVmYXVsdFwiXSkoZSkrJ1wiXScpO3JldHVybiB0fHxudWxsfWZ1bmN0aW9uIGdldEltYWdlT2ZBcmVhKGUpe3ZhciBuPWUucGFyZW50RWxlbWVudDtpZighbi5uYW1lfHxuLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkhPT1cIm1hcFwiKXtyZXR1cm4gbnVsbH12YXIgdD1nZXREb2N1bWVudChlKTtyZXR1cm4gdC5xdWVyeVNlbGVjdG9yKCdpbWdbdXNlbWFwPVwiIycrKDAsb1tcImRlZmF1bHRcIl0pKG4ubmFtZSkrJ1wiXScpfHxudWxsfXZhciBFZT12b2lkIDA7ZnVuY3Rpb24gaXNWYWxpZEFyZWEoZSl7aWYoIUVlKXtFZT1fc3VwcG9ydHMoKX12YXIgbj1jb250ZXh0VG9FbGVtZW50KHtsYWJlbDpcImlzL3ZhbGlkLWFyZWFcIixjb250ZXh0OmV9KTt2YXIgdD1uLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7aWYodCE9PVwiYXJlYVwiKXtyZXR1cm4gZmFsc2V9dmFyIHI9bi5oYXNBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKTtpZighRWUuZm9jdXNBcmVhVGFiaW5kZXgmJnIpe3JldHVybiBmYWxzZX12YXIgYT1nZXRJbWFnZU9mQXJlYShuKTtpZighYXx8IV9lKGEpKXtyZXR1cm4gZmFsc2V9aWYoIUVlLmZvY3VzQnJva2VuSW1hZ2VNYXAmJighYS5jb21wbGV0ZXx8IWEubmF0dXJhbEhlaWdodHx8YS5vZmZzZXRXaWR0aDw9MHx8YS5vZmZzZXRIZWlnaHQ8PTApKXtyZXR1cm4gZmFsc2V9aWYoIUVlLmZvY3VzQXJlYVdpdGhvdXRIcmVmJiYhbi5ocmVmKXtyZXR1cm4gRWUuZm9jdXNBcmVhVGFiaW5kZXgmJnJ8fEVlLmZvY3VzQXJlYUltZ1RhYmluZGV4JiZhLmhhc0F0dHJpYnV0ZShcInRhYmluZGV4XCIpfXZhciBvPWdldFBhcmVudHMoe2NvbnRleHQ6YX0pLnNsaWNlKDEpLnNvbWUoKGZ1bmN0aW9uKGUpe3ZhciBuPWUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4gbj09PVwiYnV0dG9uXCJ8fG49PT1cImFcIn0pKTtpZihvKXtyZXR1cm4gZmFsc2V9cmV0dXJuIHRydWV9dmFyIGplPXZvaWQgMDt2YXIgT2U9dm9pZCAwO3ZhciBrZT17aW5wdXQ6dHJ1ZSxzZWxlY3Q6dHJ1ZSx0ZXh0YXJlYTp0cnVlLGJ1dHRvbjp0cnVlLGZpZWxkc2V0OnRydWUsZm9ybTp0cnVlfTtmdW5jdGlvbiBpc05hdGl2ZURpc2FibGVkU3VwcG9ydGVkKGUpe2lmKCFqZSl7amU9X3N1cHBvcnRzKCk7aWYoamUuZm9jdXNGaWVsZHNldERpc2FibGVkKXtkZWxldGUga2UuZmllbGRzZXR9aWYoamUuZm9jdXNGb3JtRGlzYWJsZWQpe2RlbGV0ZSBrZS5mb3JtfU9lPW5ldyBSZWdFeHAoXCJeKFwiK09iamVjdC5rZXlzKGtlKS5qb2luKFwifFwiKStcIikkXCIpfXZhciBuPWNvbnRleHRUb0VsZW1lbnQoe2xhYmVsOlwiaXMvbmF0aXZlLWRpc2FibGVkLXN1cHBvcnRlZFwiLGNvbnRleHQ6ZX0pO3ZhciB0PW4ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4gQm9vbGVhbihPZS50ZXN0KHQpKX12YXIgU2U9dm9pZCAwO2Z1bmN0aW9uIGlzRGlzYWJsZWRGaWVsZHNldChlKXt2YXIgbj1lLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuIG49PT1cImZpZWxkc2V0XCImJmUuZGlzYWJsZWR9ZnVuY3Rpb24gaXNEaXNhYmxlZEZvcm0oZSl7dmFyIG49ZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO3JldHVybiBuPT09XCJmb3JtXCImJmUuZGlzYWJsZWR9ZnVuY3Rpb24gaXNEaXNhYmxlZChlKXtpZighU2Upe1NlPV9zdXBwb3J0cygpfXZhciBuPWNvbnRleHRUb0VsZW1lbnQoe2xhYmVsOlwiaXMvZGlzYWJsZWRcIixjb250ZXh0OmV9KTtpZihuLmhhc0F0dHJpYnV0ZShcImRhdGEtYWxseS1kaXNhYmxlZFwiKSl7cmV0dXJuIHRydWV9aWYoIWlzTmF0aXZlRGlzYWJsZWRTdXBwb3J0ZWQobikpe3JldHVybiBmYWxzZX1pZihuLmRpc2FibGVkKXtyZXR1cm4gdHJ1ZX12YXIgdD1nZXRQYXJlbnRzKHtjb250ZXh0Om59KTtpZih0LnNvbWUoaXNEaXNhYmxlZEZpZWxkc2V0KSl7cmV0dXJuIHRydWV9aWYoIVNlLmZvY3VzRm9ybURpc2FibGVkJiZ0LnNvbWUoaXNEaXNhYmxlZEZvcm0pKXtyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2V9ZnVuY3Rpb24gaXNPbmx5VGFiYmFibGVSdWxlcygpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1swXTp7fSxuPWUuY29udGV4dCx0PWUuZXhjZXB0LHI9dD09PXVuZGVmaW5lZD97b25seUZvY3VzYWJsZUJyb3dzaW5nQ29udGV4dDpmYWxzZSx2aXNpYmxlOmZhbHNlfTp0O3ZhciBhPWNvbnRleHRUb0VsZW1lbnQoe2xhYmVsOlwiaXMvb25seS10YWJiYWJsZVwiLHJlc29sdmVEb2N1bWVudDp0cnVlLGNvbnRleHQ6bn0pO2lmKCFyLnZpc2libGUmJiFfZShhKSl7cmV0dXJuIGZhbHNlfWlmKCFyLm9ubHlGb2N1c2FibGVCcm93c2luZ0NvbnRleHQmJihzLmlzLkdFQ0tPfHxzLmlzLlRSSURFTlR8fHMuaXMuRURHRSkpe3ZhciBvPWdldEZyYW1lRWxlbWVudChhKTtpZihvKXtpZih0YWJpbmRleFZhbHVlKG8pPDApe3JldHVybiBmYWxzZX19fXZhciBpPWEubm9kZU5hbWUudG9Mb3dlckNhc2UoKTt2YXIgbD10YWJpbmRleFZhbHVlKGEpO2lmKGk9PT1cImxhYmVsXCImJnMuaXMuR0VDS08pe3JldHVybiBsIT09bnVsbCYmbD49MH1pZihzLmlzLkdFQ0tPJiZhLm93bmVyU1ZHRWxlbWVudCYmIWEuZm9jdXMpe2lmKGk9PT1cImFcIiYmYS5oYXNBdHRyaWJ1dGUoXCJ4bGluazpocmVmXCIpKXtpZihzLmlzLkdFQ0tPKXtyZXR1cm4gdHJ1ZX19fXJldHVybiBmYWxzZX1pc09ubHlUYWJiYWJsZVJ1bGVzLmV4Y2VwdD1mdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1swXTp7fTt2YXIgbj1mdW5jdGlvbiBpc09ubHlUYWJiYWJsZShuKXtyZXR1cm4gaXNPbmx5VGFiYmFibGVSdWxlcyh7Y29udGV4dDpuLGV4Y2VwdDplfSl9O24ucnVsZXM9aXNPbmx5VGFiYmFibGVSdWxlcztyZXR1cm4gbn07dmFyIFRlPWlzT25seVRhYmJhYmxlUnVsZXMuZXhjZXB0KHt9KTt2YXIgQ2U9dm9pZCAwO2Z1bmN0aW9uIGlzT25seUZvY3VzUmVsZXZhbnQoZSl7dmFyIG49ZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO2lmKG49PT1cImVtYmVkXCJ8fG49PT1cImtleWdlblwiKXtyZXR1cm4gdHJ1ZX12YXIgdD10YWJpbmRleFZhbHVlKGUpO2lmKGUuc2hhZG93Um9vdCYmdD09PW51bGwpe3JldHVybiB0cnVlfWlmKG49PT1cImxhYmVsXCIpe3JldHVybiFDZS5mb2N1c0xhYmVsVGFiaW5kZXh8fHQ9PT1udWxsfWlmKG49PT1cImxlZ2VuZFwiKXtyZXR1cm4gdD09PW51bGx9aWYoQ2UuZm9jdXNTdmdGb2N1c2FibGVBdHRyaWJ1dGUmJihlLm93bmVyU1ZHRWxlbWVudHx8bj09PVwic3ZnXCIpKXt2YXIgcj1lLmdldEF0dHJpYnV0ZShcImZvY3VzYWJsZVwiKTtyZXR1cm4gciYmcj09PVwiZmFsc2VcIn1pZihuPT09XCJpbWdcIiYmZS5oYXNBdHRyaWJ1dGUoXCJ1c2VtYXBcIikpe3JldHVybiB0PT09bnVsbHx8IUNlLmZvY3VzSW1nVXNlbWFwVGFiaW5kZXh9aWYobj09PVwiYXJlYVwiKXtyZXR1cm4haXNWYWxpZEFyZWEoZSl9cmV0dXJuIGZhbHNlfWZ1bmN0aW9uIGlzRm9jdXNhYmxlUnVsZXMoKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMF06e30sbj1lLmNvbnRleHQsdD1lLmV4Y2VwdCxyPXQ9PT11bmRlZmluZWQ/e2Rpc2FibGVkOmZhbHNlLHZpc2libGU6ZmFsc2Usb25seVRhYmJhYmxlOmZhbHNlfTp0O2lmKCFDZSl7Q2U9X3N1cHBvcnRzKCl9dmFyIGE9VGUucnVsZXMuZXhjZXB0KHtvbmx5Rm9jdXNhYmxlQnJvd3NpbmdDb250ZXh0OnRydWUsdmlzaWJsZTpyLnZpc2libGV9KTt2YXIgbz1jb250ZXh0VG9FbGVtZW50KHtsYWJlbDpcImlzL2ZvY3VzYWJsZVwiLHJlc29sdmVEb2N1bWVudDp0cnVlLGNvbnRleHQ6bn0pO3ZhciBpPWhlLnJ1bGVzKHtjb250ZXh0Om8sZXhjZXB0OnJ9KTtpZighaXx8aXNPbmx5Rm9jdXNSZWxldmFudChvKSl7cmV0dXJuIGZhbHNlfWlmKCFyLmRpc2FibGVkJiZpc0Rpc2FibGVkKG8pKXtyZXR1cm4gZmFsc2V9aWYoIXIub25seVRhYmJhYmxlJiZhKG8pKXtyZXR1cm4gZmFsc2V9aWYoIXIudmlzaWJsZSl7dmFyIGw9e2NvbnRleHQ6byxleGNlcHQ6e319O2lmKENlLmZvY3VzSW5IaWRkZW5JZnJhbWUpe2wuZXhjZXB0LmJyb3dzaW5nQ29udGV4dD10cnVlfWlmKENlLmZvY3VzT2JqZWN0U3ZnSGlkZGVuKXt2YXIgcz1vLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7aWYocz09PVwib2JqZWN0XCIpe2wuZXhjZXB0LmNzc1Zpc2liaWxpdHk9dHJ1ZX19aWYoIV9lLnJ1bGVzKGwpKXtyZXR1cm4gZmFsc2V9fXZhciB1PWdldEZyYW1lRWxlbWVudChvKTtpZih1KXt2YXIgYz11Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7aWYoYz09PVwib2JqZWN0XCImJiFDZS5mb2N1c0luWmVyb0RpbWVuc2lvbk9iamVjdCl7aWYoIXUub2Zmc2V0V2lkdGh8fCF1Lm9mZnNldEhlaWdodCl7cmV0dXJuIGZhbHNlfX19dmFyIGY9by5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO2lmKGY9PT1cInN2Z1wiJiZDZS5mb2N1c1N2Z0luSWZyYW1lJiYhdSYmby5nZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKT09PW51bGwpe3JldHVybiBmYWxzZX1yZXR1cm4gdHJ1ZX1pc0ZvY3VzYWJsZVJ1bGVzLmV4Y2VwdD1mdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1swXTp7fTt2YXIgbj1mdW5jdGlvbiBpc0ZvY3VzYWJsZShuKXtyZXR1cm4gaXNGb2N1c2FibGVSdWxlcyh7Y29udGV4dDpuLGV4Y2VwdDplfSl9O24ucnVsZXM9aXNGb2N1c2FibGVSdWxlcztyZXR1cm4gbn07dmFyIERlPWlzRm9jdXNhYmxlUnVsZXMuZXhjZXB0KHt9KTtmdW5jdGlvbiBjcmVhdGVGaWx0ZXIoZSl7dmFyIG49ZnVuY3Rpb24gZmlsdGVyKG4pe2lmKG4uc2hhZG93Um9vdCl7cmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVH1pZihlKG4pKXtyZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUfXJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQfTtuLmFjY2VwdE5vZGU9bjtyZXR1cm4gbn12YXIgTWU9Y3JlYXRlRmlsdGVyKGhlKTtmdW5jdGlvbiBxdWVyeUZvY3VzYWJsZVN0cmljdCgpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1swXTp7fSxuPWUuY29udGV4dCx0PWUuaW5jbHVkZUNvbnRleHQscj1lLmluY2x1ZGVPbmx5VGFiYmFibGUsYT1lLnN0cmF0ZWd5O2lmKCFuKXtuPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudH12YXIgbz1EZS5ydWxlcy5leGNlcHQoe29ubHlUYWJiYWJsZTpyfSk7dmFyIGk9Z2V0RG9jdW1lbnQobik7dmFyIGw9aS5jcmVhdGVUcmVlV2Fsa2VyKG4sTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQsYT09PVwiYWxsXCI/TWU6Y3JlYXRlRmlsdGVyKG8pLGZhbHNlKTt2YXIgcz1bXTt3aGlsZShsLm5leHROb2RlKCkpe2lmKGwuY3VycmVudE5vZGUuc2hhZG93Um9vdCl7aWYobyhsLmN1cnJlbnROb2RlKSl7cy5wdXNoKGwuY3VycmVudE5vZGUpfXM9cy5jb25jYXQocXVlcnlGb2N1c2FibGVTdHJpY3Qoe2NvbnRleHQ6bC5jdXJyZW50Tm9kZS5zaGFkb3dSb290LGluY2x1ZGVPbmx5VGFiYmFibGU6cixzdHJhdGVneTphfSkpfWVsc2V7cy5wdXNoKGwuY3VycmVudE5vZGUpfX1pZih0KXtpZihhPT09XCJhbGxcIil7aWYoaGUobikpe3MudW5zaGlmdChuKX19ZWxzZSBpZihvKG4pKXtzLnVuc2hpZnQobil9fXJldHVybiBzfXZhciBQZT12b2lkIDA7dmFyIHplPXZvaWQgMDtmdW5jdGlvbiBzZWxlY3RvciQyKCl7aWYoIVBlKXtQZT1fc3VwcG9ydHMoKX1pZih0eXBlb2YgemU9PT1cInN0cmluZ1wiKXtyZXR1cm4gemV9emU9XCJcIisoUGUuZm9jdXNUYWJsZT9cInRhYmxlLCB0ZCxcIjpcIlwiKSsoUGUuZm9jdXNGaWVsZHNldD9cImZpZWxkc2V0LFwiOlwiXCIpK1wic3ZnIGEsXCIrXCJhW2hyZWZdLFwiK1wiYXJlYVtocmVmXSxcIitcImlucHV0LCBzZWxlY3QsIHRleHRhcmVhLCBidXR0b24sXCIrXCJpZnJhbWUsIG9iamVjdCwgZW1iZWQsXCIrXCJrZXlnZW4sXCIrKFBlLmZvY3VzQXVkaW9XaXRob3V0Q29udHJvbHM/XCJhdWRpbyxcIjpcImF1ZGlvW2NvbnRyb2xzXSxcIikrKFBlLmZvY3VzVmlkZW9XaXRob3V0Q29udHJvbHM/XCJ2aWRlbyxcIjpcInZpZGVvW2NvbnRyb2xzXSxcIikrKFBlLmZvY3VzU3VtbWFyeT9cInN1bW1hcnksXCI6XCJcIikrXCJbdGFiaW5kZXhdLFwiK1wiW2NvbnRlbnRlZGl0YWJsZV1cIjt6ZT1zZWxlY3RJblNoYWRvd3MoemUpO3JldHVybiB6ZX1mdW5jdGlvbiBxdWVyeUZvY3VzYWJsZVF1aWNrKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZhcmd1bWVudHNbMF0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzBdOnt9LG49ZS5jb250ZXh0LHQ9ZS5pbmNsdWRlQ29udGV4dCxyPWUuaW5jbHVkZU9ubHlUYWJiYWJsZTt2YXIgYT1zZWxlY3RvciQyKCk7dmFyIG89bi5xdWVyeVNlbGVjdG9yQWxsKGEpO3ZhciBpPURlLnJ1bGVzLmV4Y2VwdCh7b25seVRhYmJhYmxlOnJ9KTt2YXIgbD1bXS5maWx0ZXIuY2FsbChvLGkpO2lmKHQmJmkobikpe2wudW5zaGlmdChuKX1yZXR1cm4gbH1mdW5jdGlvbiBxdWVyeUZvY3VzYWJsZSgpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1swXTp7fSxuPWUuY29udGV4dCx0PWUuaW5jbHVkZUNvbnRleHQscj1lLmluY2x1ZGVPbmx5VGFiYmFibGUsYT1lLnN0cmF0ZWd5LG89YT09PXVuZGVmaW5lZD9cInF1aWNrXCI6YTt2YXIgaT1jb250ZXh0VG9FbGVtZW50KHtsYWJlbDpcInF1ZXJ5L2ZvY3VzYWJsZVwiLHJlc29sdmVEb2N1bWVudDp0cnVlLGRlZmF1bHRUb0RvY3VtZW50OnRydWUsY29udGV4dDpufSk7dmFyIGw9e2NvbnRleHQ6aSxpbmNsdWRlQ29udGV4dDp0LGluY2x1ZGVPbmx5VGFiYmFibGU6cixzdHJhdGVneTpvfTtpZihvPT09XCJxdWlja1wiKXtyZXR1cm4gcXVlcnlGb2N1c2FibGVRdWljayhsKX1lbHNlIGlmKG89PT1cInN0cmljdFwifHxvPT09XCJhbGxcIil7cmV0dXJuIHF1ZXJ5Rm9jdXNhYmxlU3RyaWN0KGwpfXRocm93IG5ldyBUeXBlRXJyb3IoJ3F1ZXJ5L2ZvY3VzYWJsZSByZXF1aXJlcyBvcHRpb24uc3RyYXRlZ3kgdG8gYmUgb25lIG9mIFtcInF1aWNrXCIsIFwic3RyaWN0XCIsIFwiYWxsXCJdJyl9dmFyIEFlPXZvaWQgMDt2YXIgTmU9L14oZmllbGRzZXR8dGFibGV8dGR8Ym9keSkkLztmdW5jdGlvbiBpc1RhYmJhYmxlUnVsZXMoKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMF06e30sbj1lLmNvbnRleHQsdD1lLmV4Y2VwdCxyPXQ9PT11bmRlZmluZWQ/e2ZsZXhib3g6ZmFsc2Usc2Nyb2xsYWJsZTpmYWxzZSxzaGFkb3c6ZmFsc2UsdmlzaWJsZTpmYWxzZSxvbmx5VGFiYmFibGU6ZmFsc2V9OnQ7aWYoIUFlKXtBZT1fc3VwcG9ydHMoKX12YXIgYT1jb250ZXh0VG9FbGVtZW50KHtsYWJlbDpcImlzL3RhYmJhYmxlXCIscmVzb2x2ZURvY3VtZW50OnRydWUsY29udGV4dDpufSk7aWYocy5pcy5CTElOSyYmcy5pcy5BTkRST0lEJiZzLm1ham9yVmVyc2lvbj40Mil7cmV0dXJuIGZhbHNlfXZhciBvPWdldEZyYW1lRWxlbWVudChhKTtpZihvKXtpZihzLmlzLldFQktJVCYmcy5pcy5JT1Mpe3JldHVybiBmYWxzZX1pZih0YWJpbmRleFZhbHVlKG8pPDApe3JldHVybiBmYWxzZX1pZighci52aXNpYmxlJiYocy5pcy5CTElOS3x8cy5pcy5XRUJLSVQpJiYhX2Uobykpe3JldHVybiBmYWxzZX12YXIgaT1vLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7aWYoaT09PVwib2JqZWN0XCIpe3ZhciBsPXMubmFtZT09PVwiQ2hyb21lXCImJnMubWFqb3JWZXJzaW9uPj01NHx8cy5uYW1lPT09XCJPcGVyYVwiJiZzLm1ham9yVmVyc2lvbj49NDE7aWYocy5pcy5XRUJLSVR8fHMuaXMuQkxJTksmJiFsKXtyZXR1cm4gZmFsc2V9fX12YXIgdT1hLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7dmFyIGM9dGFiaW5kZXhWYWx1ZShhKTt2YXIgZj1jPT09bnVsbD9udWxsOmM+PTA7aWYocy5pcy5FREdFJiZzLm1ham9yVmVyc2lvbj49MTQmJm8mJmEub3duZXJTVkdFbGVtZW50JiZjPDApe3JldHVybiB0cnVlfXZhciBkPWYhPT1mYWxzZTt2YXIgdj1jIT09bnVsbCYmYz49MDtpZihhLmhhc0F0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiKSl7cmV0dXJuIGR9aWYoTmUudGVzdCh1KSYmZiE9PXRydWUpe3JldHVybiBmYWxzZX1pZihzLmlzLldFQktJVCYmcy5pcy5JT1Mpe3ZhciBwPXU9PT1cImlucHV0XCImJmEudHlwZT09PVwidGV4dFwifHxhLnR5cGU9PT1cInBhc3N3b3JkXCJ8fHU9PT1cInNlbGVjdFwifHx1PT09XCJ0ZXh0YXJlYVwifHxhLmhhc0F0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiKTtpZighcCl7dmFyIG09d2luZG93LmdldENvbXB1dGVkU3R5bGUoYSxudWxsKTtwPWlzVXNlck1vZGlmeVdyaXRhYmxlKG0pfWlmKCFwKXtyZXR1cm4gZmFsc2V9fWlmKHU9PT1cInVzZVwiJiZjIT09bnVsbCl7aWYocy5pcy5CTElOS3x8cy5pcy5XRUJLSVQmJnMubWFqb3JWZXJzaW9uPT09OSl7cmV0dXJuIHRydWV9fWlmKGVsZW1lbnRNYXRjaGVzKGEsXCJzdmcgYVwiKSYmYS5oYXNBdHRyaWJ1dGUoXCJ4bGluazpocmVmXCIpKXtpZihkKXtyZXR1cm4gdHJ1ZX1pZihhLmZvY3VzJiYhQWUuZm9jdXNTdmdOZWdhdGl2ZVRhYmluZGV4QXR0cmlidXRlKXtyZXR1cm4gdHJ1ZX19aWYodT09PVwic3ZnXCImJkFlLmZvY3VzU3ZnSW5JZnJhbWUmJmQpe3JldHVybiB0cnVlfWlmKHMuaXMuVFJJREVOVHx8cy5pcy5FREdFKXtpZih1PT09XCJzdmdcIil7aWYoQWUuZm9jdXNTdmcpe3JldHVybiB0cnVlfXJldHVybiBhLmhhc0F0dHJpYnV0ZShcImZvY3VzYWJsZVwiKXx8dn1pZihhLm93bmVyU1ZHRWxlbWVudCl7aWYoQWUuZm9jdXNTdmdUYWJpbmRleEF0dHJpYnV0ZSYmdil7cmV0dXJuIHRydWV9cmV0dXJuIGEuaGFzQXR0cmlidXRlKFwiZm9jdXNhYmxlXCIpfX1pZihhLnRhYkluZGV4PT09dW5kZWZpbmVkKXtyZXR1cm4gQm9vbGVhbihyLm9ubHlUYWJiYWJsZSl9aWYodT09PVwiYXVkaW9cIil7aWYoIWEuaGFzQXR0cmlidXRlKFwiY29udHJvbHNcIikpe3JldHVybiBmYWxzZX1lbHNlIGlmKHMuaXMuQkxJTkspe3JldHVybiB0cnVlfX1pZih1PT09XCJ2aWRlb1wiKXtpZighYS5oYXNBdHRyaWJ1dGUoXCJjb250cm9sc1wiKSl7aWYocy5pcy5UUklERU5UfHxzLmlzLkVER0Upe3JldHVybiBmYWxzZX19ZWxzZSBpZihzLmlzLkJMSU5LfHxzLmlzLkdFQ0tPKXtyZXR1cm4gdHJ1ZX19aWYodT09PVwib2JqZWN0XCIpe2lmKHMuaXMuQkxJTkt8fHMuaXMuV0VCS0lUKXtyZXR1cm4gZmFsc2V9fWlmKHU9PT1cImlmcmFtZVwiKXtyZXR1cm4gZmFsc2V9aWYoIXIuc2Nyb2xsYWJsZSYmcy5pcy5HRUNLTyl7dmFyIGI9d2luZG93LmdldENvbXB1dGVkU3R5bGUoYSxudWxsKTtpZihoYXNDc3NPdmVyZmxvd1Njcm9sbChiKSl7cmV0dXJuIGR9fWlmKHMuaXMuVFJJREVOVHx8cy5pcy5FREdFKXtpZih1PT09XCJhcmVhXCIpe3ZhciBnPWdldEltYWdlT2ZBcmVhKGEpO2lmKGcmJnRhYmluZGV4VmFsdWUoZyk8MCl7cmV0dXJuIGZhbHNlfX12YXIgaD13aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShhLG51bGwpO2lmKGlzVXNlck1vZGlmeVdyaXRhYmxlKGgpKXtyZXR1cm4gYS50YWJJbmRleD49MH1pZighci5mbGV4Ym94JiZoYXNDc3NEaXNwbGF5RmxleChoKSl7aWYoYyE9PW51bGwpe3JldHVybiB2fXJldHVybiBSZShhKSYmSWUoYSl9aWYoaXNTY3JvbGxhYmxlQ29udGFpbmVyKGEsdSkpe3JldHVybiBmYWxzZX12YXIgeT1hLnBhcmVudEVsZW1lbnQ7aWYoeSl7dmFyIHg9eS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO3ZhciB3PXdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHksbnVsbCk7aWYoaXNTY3JvbGxhYmxlQ29udGFpbmVyKHksdSx4LHcpKXtyZXR1cm4gZmFsc2V9aWYoaGFzQ3NzRGlzcGxheUZsZXgodykpe3JldHVybiB2fX19cmV0dXJuIGEudGFiSW5kZXg+PTB9aXNUYWJiYWJsZVJ1bGVzLmV4Y2VwdD1mdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1swXTp7fTt2YXIgbj1mdW5jdGlvbiBpc1RhYmJhYmxlKG4pe3JldHVybiBpc1RhYmJhYmxlUnVsZXMoe2NvbnRleHQ6bixleGNlcHQ6ZX0pfTtuLnJ1bGVzPWlzVGFiYmFibGVSdWxlcztyZXR1cm4gbn07dmFyIFJlPWhlLnJ1bGVzLmV4Y2VwdCh7ZmxleGJveDp0cnVlfSk7dmFyIEllPWlzVGFiYmFibGVSdWxlcy5leGNlcHQoe2ZsZXhib3g6dHJ1ZX0pO3ZhciBGZT1pc1RhYmJhYmxlUnVsZXMuZXhjZXB0KHt9KTtmdW5jdGlvbiBxdWVyeVRhYmJhYmxlKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZhcmd1bWVudHNbMF0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzBdOnt9LG49ZS5jb250ZXh0LHQ9ZS5pbmNsdWRlQ29udGV4dCxyPWUuaW5jbHVkZU9ubHlUYWJiYWJsZSxhPWUuc3RyYXRlZ3k7dmFyIG89RmUucnVsZXMuZXhjZXB0KHtvbmx5VGFiYmFibGU6cn0pO3JldHVybiBxdWVyeUZvY3VzYWJsZSh7Y29udGV4dDpuLGluY2x1ZGVDb250ZXh0OnQsaW5jbHVkZU9ubHlUYWJiYWJsZTpyLHN0cmF0ZWd5OmF9KS5maWx0ZXIobyl9ZnVuY3Rpb24gY29tcGFyZURvbVBvc2l0aW9uKGUsbil7cmV0dXJuIGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24obikmTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkc/LTE6MX1mdW5jdGlvbiBzb3J0RG9tT3JkZXIoZSl7cmV0dXJuIGUuc29ydChjb21wYXJlRG9tUG9zaXRpb24pfWZ1bmN0aW9uIGdldEZpcnN0U3VjY2Vzc29yT2Zmc2V0KGUsbil7cmV0dXJuIGZpbmRJbmRleChlLChmdW5jdGlvbihlKXtyZXR1cm4gbi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihlKSZOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lOR30pKX1mdW5jdGlvbiBmaW5kSW5zZXJ0aW9uT2Zmc2V0cyhlLG4sdCl7dmFyIHI9W107bi5mb3JFYWNoKChmdW5jdGlvbihuKXt2YXIgYT10cnVlO3ZhciBvPWUuaW5kZXhPZihuKTtpZihvPT09LTEpe289Z2V0Rmlyc3RTdWNjZXNzb3JPZmZzZXQoZSxuKTthPWZhbHNlfWlmKG89PT0tMSl7bz1lLmxlbmd0aH12YXIgaT1ub2RlQXJyYXkodD90KG4pOm4pO2lmKCFpLmxlbmd0aCl7cmV0dXJufXIucHVzaCh7b2Zmc2V0Om8scmVwbGFjZTphLGVsZW1lbnRzOml9KX0pKTtyZXR1cm4gcn1mdW5jdGlvbiBpbnNlcnRFbGVtZW50c0F0T2Zmc2V0cyhlLG4pe3ZhciB0PTA7bi5zb3J0KChmdW5jdGlvbihlLG4pe3JldHVybiBlLm9mZnNldC1uLm9mZnNldH0pKTtuLmZvckVhY2goKGZ1bmN0aW9uKG4pe3ZhciByPW4ucmVwbGFjZT8xOjA7dmFyIGE9W24ub2Zmc2V0K3Qscl0uY29uY2F0KG4uZWxlbWVudHMpO2Uuc3BsaWNlLmFwcGx5KGUsYSk7dCs9bi5lbGVtZW50cy5sZW5ndGgtcn0pKX1mdW5jdGlvbiBtZXJnZUluRG9tT3JkZXIoKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMF06e30sbj1lLmxpc3QsdD1lLmVsZW1lbnRzLHI9ZS5yZXNvbHZlRWxlbWVudDt2YXIgYT1uLnNsaWNlKDApO3ZhciBvPW5vZGVBcnJheSh0KS5zbGljZSgwKTtzb3J0RG9tT3JkZXIobyk7dmFyIGk9ZmluZEluc2VydGlvbk9mZnNldHMoYSxvLHIpO2luc2VydEVsZW1lbnRzQXRPZmZzZXRzKGEsaSk7cmV0dXJuIGF9dmFyIExlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhlLG4pe2Zvcih2YXIgdD0wO3Q8bi5sZW5ndGg7dCsrKXt2YXIgcj1uW3RdO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fGZhbHNlO3IuY29uZmlndXJhYmxlPXRydWU7aWYoXCJ2YWx1ZVwiaW4gcilyLndyaXRhYmxlPXRydWU7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsci5rZXkscil9fXJldHVybiBmdW5jdGlvbihlLG4sdCl7aWYobilkZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLG4pO2lmKHQpZGVmaW5lUHJvcGVydGllcyhlLHQpO3JldHVybiBlfX0oKTtmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soZSxuKXtpZighKGUgaW5zdGFuY2VvZiBuKSl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX19dmFyIEJlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gTWFwcyhlKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxNYXBzKTt0aGlzLl9kb2N1bWVudD1nZXREb2N1bWVudChlKTt0aGlzLm1hcHM9e319TGUoTWFwcyxbe2tleTpcImdldEFyZWFzRm9yXCIsdmFsdWU6ZnVuY3Rpb24gZ2V0QXJlYXNGb3IoZSl7aWYoIXRoaXMubWFwc1tlXSl7dGhpcy5hZGRNYXBCeU5hbWUoZSl9cmV0dXJuIHRoaXMubWFwc1tlXX19LHtrZXk6XCJhZGRNYXBCeU5hbWVcIix2YWx1ZTpmdW5jdGlvbiBhZGRNYXBCeU5hbWUoZSl7dmFyIG49Z2V0TWFwQnlOYW1lKGUsdGhpcy5fZG9jdW1lbnQpO2lmKCFuKXtyZXR1cm59dGhpcy5tYXBzW24ubmFtZV09cXVlcnlUYWJiYWJsZSh7Y29udGV4dDpufSl9fSx7a2V5OlwiZXh0cmFjdEFyZWFzRnJvbUxpc3RcIix2YWx1ZTpmdW5jdGlvbiBleHRyYWN0QXJlYXNGcm9tTGlzdChlKXtyZXR1cm4gZS5maWx0ZXIoKGZ1bmN0aW9uKGUpe3ZhciBuPWUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtpZihuIT09XCJhcmVhXCIpe3JldHVybiB0cnVlfXZhciB0PWUucGFyZW50Tm9kZTtpZighdGhpcy5tYXBzW3QubmFtZV0pe3RoaXMubWFwc1t0Lm5hbWVdPVtdfXRoaXMubWFwc1t0Lm5hbWVdLnB1c2goZSk7cmV0dXJuIGZhbHNlfSksdGhpcyl9fV0pO3JldHVybiBNYXBzfSgpO2Z1bmN0aW9uIHNvcnRBcmVhKGUsbil7dmFyIHQ9bi5xdWVyeVNlbGVjdG9yQWxsKFwiaW1nW3VzZW1hcF1cIik7dmFyIHI9bmV3IEJlKG4pO3ZhciBhPXIuZXh0cmFjdEFyZWFzRnJvbUxpc3QoZSk7aWYoIXQubGVuZ3RoKXtyZXR1cm4gYX1yZXR1cm4gbWVyZ2VJbkRvbU9yZGVyKHtsaXN0OmEsZWxlbWVudHM6dCxyZXNvbHZlRWxlbWVudDpmdW5jdGlvbiByZXNvbHZlRWxlbWVudChlKXt2YXIgbj1lLmdldEF0dHJpYnV0ZShcInVzZW1hcFwiKS5zbGljZSgxKTtyZXR1cm4gci5nZXRBcmVhc0ZvcihuKX19KX12YXIgSGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGUsbil7Zm9yKHZhciB0PTA7dDxuLmxlbmd0aDt0Kyspe3ZhciByPW5bdF07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ZmFsc2U7ci5jb25maWd1cmFibGU9dHJ1ZTtpZihcInZhbHVlXCJpbiByKXIud3JpdGFibGU9dHJ1ZTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLmtleSxyKX19cmV0dXJuIGZ1bmN0aW9uKGUsbix0KXtpZihuKWRlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsbik7aWYodClkZWZpbmVQcm9wZXJ0aWVzKGUsdCk7cmV0dXJuIGV9fSgpO2Z1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayQxKGUsbil7aWYoIShlIGluc3RhbmNlb2Ygbikpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9fXZhciBxZT1mdW5jdGlvbigpe2Z1bmN0aW9uIFNoYWRvd3MoZSxuKXtfY2xhc3NDYWxsQ2hlY2skMSh0aGlzLFNoYWRvd3MpO3RoaXMuY29udGV4dD1lO3RoaXMuc29ydEVsZW1lbnRzPW47dGhpcy5ob3N0Q291bnRlcj0xO3RoaXMuaW5Ib3N0PXt9O3RoaXMuaW5Eb2N1bWVudD1bXTt0aGlzLmhvc3RzPXt9O3RoaXMuZWxlbWVudHM9e319SGUoU2hhZG93cyxbe2tleTpcIl9yZWdpc3Rlckhvc3RcIix2YWx1ZTpmdW5jdGlvbiBfcmVnaXN0ZXJIb3N0KGUpe2lmKGUuX3NvcnRpbmdJZCl7cmV0dXJufWUuX3NvcnRpbmdJZD1cInNoYWRvdy1cIit0aGlzLmhvc3RDb3VudGVyKys7dGhpcy5ob3N0c1tlLl9zb3J0aW5nSWRdPWU7dmFyIG49Z2V0U2hhZG93SG9zdCh7Y29udGV4dDplfSk7aWYobil7dGhpcy5fcmVnaXN0ZXJIb3N0KG4pO3RoaXMuX3JlZ2lzdGVySG9zdFBhcmVudChlLG4pfWVsc2V7dGhpcy5pbkRvY3VtZW50LnB1c2goZSl9fX0se2tleTpcIl9yZWdpc3Rlckhvc3RQYXJlbnRcIix2YWx1ZTpmdW5jdGlvbiBfcmVnaXN0ZXJIb3N0UGFyZW50KGUsbil7aWYoIXRoaXMuaW5Ib3N0W24uX3NvcnRpbmdJZF0pe3RoaXMuaW5Ib3N0W24uX3NvcnRpbmdJZF09W119dGhpcy5pbkhvc3Rbbi5fc29ydGluZ0lkXS5wdXNoKGUpfX0se2tleTpcIl9yZWdpc3RlckVsZW1lbnRcIix2YWx1ZTpmdW5jdGlvbiBfcmVnaXN0ZXJFbGVtZW50KGUsbil7aWYoIXRoaXMuZWxlbWVudHNbbi5fc29ydGluZ0lkXSl7dGhpcy5lbGVtZW50c1tuLl9zb3J0aW5nSWRdPVtdfXRoaXMuZWxlbWVudHNbbi5fc29ydGluZ0lkXS5wdXNoKGUpfX0se2tleTpcImV4dHJhY3RFbGVtZW50c1wiLHZhbHVlOmZ1bmN0aW9uIGV4dHJhY3RFbGVtZW50cyhlKXtyZXR1cm4gZS5maWx0ZXIoKGZ1bmN0aW9uKGUpe3ZhciBuPWdldFNoYWRvd0hvc3Qoe2NvbnRleHQ6ZX0pO2lmKCFuKXtyZXR1cm4gdHJ1ZX10aGlzLl9yZWdpc3Rlckhvc3Qobik7dGhpcy5fcmVnaXN0ZXJFbGVtZW50KGUsbik7cmV0dXJuIGZhbHNlfSksdGhpcyl9fSx7a2V5Olwic29ydFwiLHZhbHVlOmZ1bmN0aW9uIHNvcnQoZSl7dmFyIG49dGhpcy5faW5qZWN0SG9zdHMoZSk7bj10aGlzLl9yZXBsYWNlSG9zdHMobik7dGhpcy5fY2xlYW51cCgpO3JldHVybiBufX0se2tleTpcIl9pbmplY3RIb3N0c1wiLHZhbHVlOmZ1bmN0aW9uIF9pbmplY3RIb3N0cyhlKXtPYmplY3Qua2V5cyh0aGlzLmhvc3RzKS5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgbj10aGlzLmVsZW1lbnRzW2VdO3ZhciB0PXRoaXMuaW5Ib3N0W2VdO3ZhciByPXRoaXMuaG9zdHNbZV0uc2hhZG93Um9vdDt0aGlzLmVsZW1lbnRzW2VdPXRoaXMuX21lcmdlKG4sdCxyKX0pLHRoaXMpO3JldHVybiB0aGlzLl9tZXJnZShlLHRoaXMuaW5Eb2N1bWVudCx0aGlzLmNvbnRleHQpfX0se2tleTpcIl9tZXJnZVwiLHZhbHVlOmZ1bmN0aW9uIF9tZXJnZShlLG4sdCl7dmFyIHI9bWVyZ2VJbkRvbU9yZGVyKHtsaXN0OmUsZWxlbWVudHM6bn0pO3JldHVybiB0aGlzLnNvcnRFbGVtZW50cyhyLHQpfX0se2tleTpcIl9yZXBsYWNlSG9zdHNcIix2YWx1ZTpmdW5jdGlvbiBfcmVwbGFjZUhvc3RzKGUpe3JldHVybiBtZXJnZUluRG9tT3JkZXIoe2xpc3Q6ZSxlbGVtZW50czp0aGlzLmluRG9jdW1lbnQscmVzb2x2ZUVsZW1lbnQ6dGhpcy5fcmVzb2x2ZUhvc3RFbGVtZW50LmJpbmQodGhpcyl9KX19LHtrZXk6XCJfcmVzb2x2ZUhvc3RFbGVtZW50XCIsdmFsdWU6ZnVuY3Rpb24gX3Jlc29sdmVIb3N0RWxlbWVudChlKXt2YXIgbj1tZXJnZUluRG9tT3JkZXIoe2xpc3Q6dGhpcy5lbGVtZW50c1tlLl9zb3J0aW5nSWRdLGVsZW1lbnRzOnRoaXMuaW5Ib3N0W2UuX3NvcnRpbmdJZF0scmVzb2x2ZUVsZW1lbnQ6dGhpcy5fcmVzb2x2ZUhvc3RFbGVtZW50LmJpbmQodGhpcyl9KTt2YXIgdD10YWJpbmRleFZhbHVlKGUpO2lmKHQhPT1udWxsJiZ0Pi0xKXtyZXR1cm5bZV0uY29uY2F0KG4pfXJldHVybiBufX0se2tleTpcIl9jbGVhbnVwXCIsdmFsdWU6ZnVuY3Rpb24gX2NsZWFudXAoKXtPYmplY3Qua2V5cyh0aGlzLmhvc3RzKS5mb3JFYWNoKChmdW5jdGlvbihlKXtkZWxldGUgdGhpcy5ob3N0c1tlXS5fc29ydGluZ0lkfSksdGhpcyl9fV0pO3JldHVybiBTaGFkb3dzfSgpO2Z1bmN0aW9uIHNvcnRTaGFkb3dlZChlLG4sdCl7dmFyIHI9bmV3IHFlKG4sdCk7dmFyIGE9ci5leHRyYWN0RWxlbWVudHMoZSk7aWYoYS5sZW5ndGg9PT1lLmxlbmd0aCl7cmV0dXJuIHQoZSl9cmV0dXJuIHIuc29ydChhKX1mdW5jdGlvbiBzb3J0VGFiaW5kZXgoZSl7dmFyIG49e307dmFyIHQ9W107dmFyIHI9ZS5maWx0ZXIoKGZ1bmN0aW9uKGUpe3ZhciByPWUudGFiSW5kZXg7aWYocj09PXVuZGVmaW5lZCl7cj10YWJpbmRleFZhbHVlKGUpfWlmKHI8PTB8fHI9PT1udWxsfHxyPT09dW5kZWZpbmVkKXtyZXR1cm4gdHJ1ZX1pZighbltyXSl7bltyXT1bXTt0LnB1c2gocil9bltyXS5wdXNoKGUpO3JldHVybiBmYWxzZX0pKTt2YXIgYT10LnNvcnQoKS5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBuW2VdfSkpLnJlZHVjZVJpZ2h0KChmdW5jdGlvbihlLG4pe3JldHVybiBuLmNvbmNhdChlKX0pLHIpO3JldHVybiBhfXZhciBVZT12b2lkIDA7ZnVuY3Rpb24gbW92ZUNvbnRleHRUb0JlZ2lubmluZyhlLG4pe3ZhciB0PWUuaW5kZXhPZihuKTtpZih0PjApe3ZhciByPWUuc3BsaWNlKHQsMSk7cmV0dXJuIHIuY29uY2F0KGUpfXJldHVybiBlfWZ1bmN0aW9uIHNvcnRFbGVtZW50cyhlLG4pe2lmKFVlLnRhYnNlcXVlbmNlQXJlYUF0SW1nUG9zaXRpb24pe2U9c29ydEFyZWEoZSxuKX1lPXNvcnRUYWJpbmRleChlKTtyZXR1cm4gZX1mdW5jdGlvbiBxdWVyeVRhYnNlcXVlbmNlKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZhcmd1bWVudHNbMF0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzBdOnt9LG49ZS5jb250ZXh0LHQ9ZS5pbmNsdWRlQ29udGV4dCxyPWUuaW5jbHVkZU9ubHlUYWJiYWJsZSxhPWUuc3RyYXRlZ3k7aWYoIVVlKXtVZT1fc3VwcG9ydHMoKX12YXIgbz1ub2RlQXJyYXkobilbMF18fGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDt2YXIgaT1xdWVyeVRhYmJhYmxlKHtjb250ZXh0Om8saW5jbHVkZUNvbnRleHQ6dCxpbmNsdWRlT25seVRhYmJhYmxlOnIsc3RyYXRlZ3k6YX0pO2lmKGRvY3VtZW50LmJvZHkuY3JlYXRlU2hhZG93Um9vdCYmcy5pcy5CTElOSyl7aT1zb3J0U2hhZG93ZWQoaSxvLHNvcnRFbGVtZW50cyl9ZWxzZXtpPXNvcnRFbGVtZW50cyhpLG8pfWlmKHQpe2k9bW92ZUNvbnRleHRUb0JlZ2lubmluZyhpLG8pfXJldHVybiBpfXZhciBXZT17dGFiOjksbGVmdDozNyx1cDozOCxyaWdodDozOSxkb3duOjQwLHBhZ2VVcDozMyxcInBhZ2UtdXBcIjozMyxwYWdlRG93bjozNCxcInBhZ2UtZG93blwiOjM0LGVuZDozNSxob21lOjM2LGVudGVyOjEzLGVzY2FwZToyNyxzcGFjZTozMixzaGlmdDoxNixjYXBzTG9jazoyMCxcImNhcHMtbG9ja1wiOjIwLGN0cmw6MTcsYWx0OjE4LG1ldGE6OTEscGF1c2U6MTksaW5zZXJ0OjQ1LGRlbGV0ZTo0NixiYWNrc3BhY2U6OCxfYWxpYXM6ezkxOls5Miw5MywyMjRdfX07Zm9yKHZhciBWZT0xO1ZlPDI2O1ZlKyspe1dlW1wiZlwiK1ZlXT1WZSsxMTF9Zm9yKHZhciBLZT0wO0tlPDEwO0tlKyspe3ZhciBaZT1LZSs0ODt2YXIgR2U9S2UrOTY7V2VbS2VdPVplO1dlW1wibnVtLVwiK0tlXT1HZTtXZS5fYWxpYXNbWmVdPVtHZV19Zm9yKHZhciBZZT0wO1llPDI2O1llKyspe3ZhciBKZT1ZZSs2NTt2YXIgJGU9U3RyaW5nLmZyb21DaGFyQ29kZShKZSkudG9Mb3dlckNhc2UoKTtXZVskZV09SmV9dmFyIFhlPXthbHQ6XCJhbHRLZXlcIixjdHJsOlwiY3RybEtleVwiLG1ldGE6XCJtZXRhS2V5XCIsc2hpZnQ6XCJzaGlmdEtleVwifTt2YXIgUWU9T2JqZWN0LmtleXMoWGUpLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIFhlW2VdfSkpO2Z1bmN0aW9uIGNyZWF0ZUV4cGVjdGVkTW9kaWZpZXJzKGUpe3ZhciBuPWU/bnVsbDpmYWxzZTtyZXR1cm57YWx0S2V5Om4sY3RybEtleTpuLG1ldGFLZXk6bixzaGlmdEtleTpufX1mdW5jdGlvbiByZXNvbHZlTW9kaWZpZXJzKGUpe3ZhciBuPWUuaW5kZXhPZihcIipcIikhPT0tMTt2YXIgdD1jcmVhdGVFeHBlY3RlZE1vZGlmaWVycyhuKTtlLmZvckVhY2goKGZ1bmN0aW9uKGUpe2lmKGU9PT1cIipcIil7cmV0dXJufXZhciBuPXRydWU7dmFyIHI9ZS5zbGljZSgwLDEpO2lmKHI9PT1cIj9cIil7bj1udWxsfWVsc2UgaWYocj09PVwiIVwiKXtuPWZhbHNlfWlmKG4hPT10cnVlKXtlPWUuc2xpY2UoMSl9dmFyIGE9WGVbZV07aWYoIWEpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gbW9kaWZpZXIgXCInK2UrJ1wiJyl9dFthXT1ufSkpO3JldHVybiB0fWZ1bmN0aW9uIHJlc29sdmVLZXkoZSl7dmFyIG49V2VbZV18fHBhcnNlSW50KGUsMTApO2lmKCFufHx0eXBlb2YgbiE9PVwibnVtYmVyXCJ8fGlzTmFOKG4pKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGtleSBcIicrZSsnXCInKX1yZXR1cm5bbl0uY29uY2F0KFdlLl9hbGlhc1tuXXx8W10pfWZ1bmN0aW9uIG1hdGNoTW9kaWZpZXJzKGUsbil7cmV0dXJuIVFlLnNvbWUoKGZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgZVt0XT09PVwiYm9vbGVhblwiJiZCb29sZWFuKG5bdF0pIT09ZVt0XX0pKX1mdW5jdGlvbiBrZXlCaW5kaW5nKGUpe3JldHVybiBlLnNwbGl0KC9cXHMrLykubWFwKChmdW5jdGlvbihlKXt2YXIgbj1lLnNwbGl0KFwiK1wiKTt2YXIgdD1yZXNvbHZlTW9kaWZpZXJzKG4uc2xpY2UoMCwtMSkpO3ZhciByPXJlc29sdmVLZXkobi5zbGljZSgtMSkpO3JldHVybntrZXlDb2RlczpyLG1vZGlmaWVyczp0LG1hdGNoTW9kaWZpZXJzOm1hdGNoTW9kaWZpZXJzLmJpbmQobnVsbCx0KX19KSl9ZnVuY3Rpb24gZ2V0UGFyZW50Q29tcGFyYXRvcigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1swXTp7fSxuPWUucGFyZW50LHQ9ZS5lbGVtZW50LHI9ZS5pbmNsdWRlU2VsZjtpZihuKXtyZXR1cm4gZnVuY3Rpb24gaXNDaGlsZE9mKGUpe3JldHVybiBCb29sZWFuKHImJmU9PT1ufHxuLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGUpJk5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZKX19ZWxzZSBpZih0KXtyZXR1cm4gZnVuY3Rpb24gaXNQYXJlbnRPZihlKXtyZXR1cm4gQm9vbGVhbihyJiZ0PT09ZXx8ZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0KSZOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWSl9fXRocm93IG5ldyBUeXBlRXJyb3IoXCJ1dGlsL2NvbXBhcmUtcG9zaXRpb24jZ2V0UGFyZW50Q29tcGFyYXRvciByZXF1aXJlZCBlaXRoZXIgb3B0aW9ucy5wYXJlbnQgb3Igb3B0aW9ucy5lbGVtZW50XCIpfWZ1bmN0aW9uIHdoZW5LZXkoKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMF06e307dmFyIG49e307dmFyIHQ9bm9kZUFycmF5KGUuY29udGV4dClbMF18fGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtkZWxldGUgZS5jb250ZXh0O3ZhciByPW5vZGVBcnJheShlLmZpbHRlcik7ZGVsZXRlIGUuZmlsdGVyO3ZhciBhPU9iamVjdC5rZXlzKGUpO2lmKCFhLmxlbmd0aCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIndoZW4va2V5IHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBvcHRpb24ga2V5XCIpfXZhciBvPWZ1bmN0aW9uIHJlZ2lzdGVyQmluZGluZyhlKXtlLmtleUNvZGVzLmZvckVhY2goKGZ1bmN0aW9uKHQpe2lmKCFuW3RdKXtuW3RdPVtdfW5bdF0ucHVzaChlKX0pKX07YS5mb3JFYWNoKChmdW5jdGlvbihuKXtpZih0eXBlb2YgZVtuXSE9PVwiZnVuY3Rpb25cIil7dGhyb3cgbmV3IFR5cGVFcnJvcignd2hlbi9rZXkgcmVxdWlyZXMgb3B0aW9uW1wiJytuKydcIl0gdG8gYmUgYSBmdW5jdGlvbicpfXZhciB0PWZ1bmN0aW9uIGFkZENhbGxiYWNrKHQpe3QuY2FsbGJhY2s9ZVtuXTtyZXR1cm4gdH07a2V5QmluZGluZyhuKS5tYXAodCkuZm9yRWFjaChvKX0pKTt2YXIgaT1mdW5jdGlvbiBoYW5kbGVLZXlEb3duKGUpe2lmKGUuZGVmYXVsdFByZXZlbnRlZCl7cmV0dXJufWlmKHIubGVuZ3RoKXt2YXIgYT1nZXRQYXJlbnRDb21wYXJhdG9yKHtlbGVtZW50OmUudGFyZ2V0LGluY2x1ZGVTZWxmOnRydWV9KTtpZihyLnNvbWUoYSkpe3JldHVybn19dmFyIG89ZS5rZXlDb2RlfHxlLndoaWNoO2lmKCFuW29dKXtyZXR1cm59bltvXS5mb3JFYWNoKChmdW5jdGlvbihuKXtpZighbi5tYXRjaE1vZGlmaWVycyhlKSl7cmV0dXJufW4uY2FsbGJhY2suY2FsbCh0LGUsbCl9KSl9O3QuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIixpLGZhbHNlKTt2YXIgbD1mdW5jdGlvbiBkaXNlbmdhZ2UoKXt0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsaSxmYWxzZSl9O3JldHVybntkaXNlbmdhZ2U6bH19ZnVuY3Rpb24gZGVmYXVsdF8xKGUpe3ZhciBuPWU9PT12b2lkIDA/e306ZSx0PW4uY29udGV4dDtpZighdCl7dD1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnR9cXVlcnlUYWJzZXF1ZW5jZSgpO3JldHVybiB3aGVuS2V5KHtcIj9hbHQrP3NoaWZ0K3RhYlwiOmZ1bmN0aW9uIGFsdFNoaWZ0VGFiKGUpe2UucHJldmVudERlZmF1bHQoKTt2YXIgbj1xdWVyeVRhYnNlcXVlbmNlKHtjb250ZXh0OnR9KTt2YXIgcj1lLnNoaWZ0S2V5O3ZhciBhPW5bMF07dmFyIG89bltuLmxlbmd0aC0xXTt2YXIgaT1yP2E6bzt2YXIgbD1yP286YTtpZihpc0FjdGl2ZUVsZW1lbnQoaSkpe2wuZm9jdXMoKTtyZXR1cm59dmFyIHM9dm9pZCAwO3ZhciB1PW4uc29tZSgoZnVuY3Rpb24oZSxuKXtpZighaXNBY3RpdmVFbGVtZW50KGUpKXtyZXR1cm4gZmFsc2V9cz1uO3JldHVybiB0cnVlfSkpO2lmKCF1KXthLmZvY3VzKCk7cmV0dXJufXZhciBjPXI/LTE6MTtuW3MrY10uZm9jdXMoKX19KX1uW1wiZGVmYXVsdFwiXT1kZWZhdWx0XzF9LDk5MzpmdW5jdGlvbihlLG4sdCl7dmFyIHI9dGhpcyYmdGhpcy5fX21ha2VUZW1wbGF0ZU9iamVjdHx8ZnVuY3Rpb24oZSxuKXtpZihPYmplY3QuZGVmaW5lUHJvcGVydHkpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwicmF3XCIse3ZhbHVlOm59KX1lbHNle2UucmF3PW59cmV0dXJuIGV9O24uX19lc01vZHVsZT10cnVlO24uc3R5bGVzPXZvaWQgMDt2YXIgYT10KDkxMCk7dmFyIG89KDAsYS5ub29wKShpfHwoaT1yKFtcIlxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1vdmVybGF5XSB7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgdG9wOiAwO1xcbiAgICByaWdodDogMDtcXG4gICAgYm90dG9tOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICBvdmVyZmxvdzogYXV0bztcXG4gICAgei1pbmRleDogOTAwMDtcXG5cXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24tY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICBwYWRkaW5nOiAxMHZoIDE1cHggMDtcXG4gIH1cXG5cXG4gIEBtZWRpYSAobWF4LWhlaWdodDogODEycHgpIHtcXG4gICAgW2RhdGEtbmV4dGpzLWRpYWxvZy1vdmVybGF5XSB7XFxuICAgICAgcGFkZGluZzogMTVweCAxNXB4IDA7XFxuICAgIH1cXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctYmFja2Ryb3BdIHtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICB0b3A6IDA7XFxuICAgIHJpZ2h0OiAwO1xcbiAgICBib3R0b206IDA7XFxuICAgIGxlZnQ6IDA7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTcsIDE3LCAxNywgMC4yKTtcXG4gICAgcG9pbnRlci1ldmVudHM6IGFsbDtcXG4gICAgei1pbmRleDogLTE7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWJhY2tkcm9wLWZpeGVkXSB7XFxuICAgIGN1cnNvcjogbm90LWFsbG93ZWQ7XFxuICAgIC13ZWJraXQtYmFja2Ryb3AtZmlsdGVyOiBibHVyKDhweCk7XFxuICAgIGJhY2tkcm9wLWZpbHRlcjogYmx1cig4cHgpO1xcbiAgfVxcblwiXSxbXCJcXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctb3ZlcmxheV0ge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIHRvcDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgb3ZlcmZsb3c6IGF1dG87XFxuICAgIHotaW5kZXg6IDkwMDA7XFxuXFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgcGFkZGluZzogMTB2aCAxNXB4IDA7XFxuICB9XFxuXFxuICBAbWVkaWEgKG1heC1oZWlnaHQ6IDgxMnB4KSB7XFxuICAgIFtkYXRhLW5leHRqcy1kaWFsb2ctb3ZlcmxheV0ge1xcbiAgICAgIHBhZGRpbmc6IDE1cHggMTVweCAwO1xcbiAgICB9XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWJhY2tkcm9wXSB7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgdG9wOiAwO1xcbiAgICByaWdodDogMDtcXG4gICAgYm90dG9tOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDE3LCAxNywgMTcsIDAuMik7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBhbGw7XFxuICAgIHotaW5kZXg6IC0xO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYWNrZHJvcC1maXhlZF0ge1xcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xcbiAgICAtd2Via2l0LWJhY2tkcm9wLWZpbHRlcjogYmx1cig4cHgpO1xcbiAgICBiYWNrZHJvcC1maWx0ZXI6IGJsdXIoOHB4KTtcXG4gIH1cXG5cIl0pKSk7bi5zdHlsZXM9bzt2YXIgaX0sMzM4OmZ1bmN0aW9uKGUsbix0KXt2YXIgcj10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7dmFyIGE9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLHQpO2lmKCFhfHwoXCJnZXRcImluIGE/IW4uX19lc01vZHVsZTphLndyaXRhYmxlfHxhLmNvbmZpZ3VyYWJsZSkpe2E9e2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gblt0XX19fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIsYSl9OmZ1bmN0aW9uKGUsbix0LHIpe2lmKHI9PT11bmRlZmluZWQpcj10O2Vbcl09blt0XX0pO3ZhciBhPXRoaXMmJnRoaXMuX19zZXRNb2R1bGVEZWZhdWx0fHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOnRydWUsdmFsdWU6bn0pfTpmdW5jdGlvbihlLG4pe2VbXCJkZWZhdWx0XCJdPW59KTt2YXIgbz10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciBuPXt9O2lmKGUhPW51bGwpZm9yKHZhciB0IGluIGUpaWYodCE9PVwiZGVmYXVsdFwiJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KSlyKG4sZSx0KTthKG4sZSk7cmV0dXJuIG59O3ZhciBpPXRoaXMmJnRoaXMuX19yZWFkfHxmdW5jdGlvbihlLG4pe3ZhciB0PXR5cGVvZiBTeW1ib2w9PT1cImZ1bmN0aW9uXCImJmVbU3ltYm9sLml0ZXJhdG9yXTtpZighdClyZXR1cm4gZTt2YXIgcj10LmNhbGwoZSksYSxvPVtdLGk7dHJ5e3doaWxlKChuPT09dm9pZCAwfHxuLS0gPjApJiYhKGE9ci5uZXh0KCkpLmRvbmUpby5wdXNoKGEudmFsdWUpfWNhdGNoKGUpe2k9e2Vycm9yOmV9fWZpbmFsbHl7dHJ5e2lmKGEmJiFhLmRvbmUmJih0PXJbXCJyZXR1cm5cIl0pKXQuY2FsbChyKX1maW5hbGx5e2lmKGkpdGhyb3cgaS5lcnJvcn19cmV0dXJuIG99O24uX19lc01vZHVsZT10cnVlO24uU2hhZG93UG9ydGFsPXZvaWQgMDt2YXIgbD1vKHQoNTIyKSk7dmFyIHM9dCgyNTUpO3ZhciB1PWZ1bmN0aW9uIFBvcnRhbChlKXt2YXIgbj1lLmNoaWxkcmVuLHQ9ZS5nbG9iYWxPdmVybGF5O3ZhciByPWwudXNlUmVmKG51bGwpO3ZhciBhPWwudXNlUmVmKG51bGwpO3ZhciBvPWwudXNlUmVmKG51bGwpO3ZhciB1PWkobC51c2VTdGF0ZSgpLDIpLGM9dVsxXTtsLnVzZUxheW91dEVmZmVjdCgoZnVuY3Rpb24oKXt2YXIgZT10P2RvY3VtZW50OnIuY3VycmVudC5vd25lckRvY3VtZW50O2EuY3VycmVudD1lLmNyZWF0ZUVsZW1lbnQoXCJuZXh0anMtcG9ydGFsXCIpO28uY3VycmVudD1hLmN1cnJlbnQuYXR0YWNoU2hhZG93KHttb2RlOlwib3BlblwifSk7ZS5ib2R5LmFwcGVuZENoaWxkKGEuY3VycmVudCk7Yyh7fSk7cmV0dXJuIGZ1bmN0aW9uKCl7aWYoYS5jdXJyZW50JiZhLmN1cnJlbnQub3duZXJEb2N1bWVudCl7YS5jdXJyZW50Lm93bmVyRG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChhLmN1cnJlbnQpfX19KSxbdF0pO3JldHVybiBvLmN1cnJlbnQ/KDAscy5jcmVhdGVQb3J0YWwpKG4sby5jdXJyZW50KTp0P251bGw6bC5jcmVhdGVFbGVtZW50KFwic3BhblwiLHtyZWY6cn0pfTtuLlNoYWRvd1BvcnRhbD11fSwyMTU6ZnVuY3Rpb24oZSxuLHQpe3ZhciByPXRoaXMmJnRoaXMuX19hc3NpZ258fGZ1bmN0aW9uKCl7cj1PYmplY3QuYXNzaWdufHxmdW5jdGlvbihlKXtmb3IodmFyIG4sdD0xLHI9YXJndW1lbnRzLmxlbmd0aDt0PHI7dCsrKXtuPWFyZ3VtZW50c1t0XTtmb3IodmFyIGEgaW4gbilpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobixhKSllW2FdPW5bYV19cmV0dXJuIGV9O3JldHVybiByLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07dmFyIGE9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsbix0LHIpe2lmKHI9PT11bmRlZmluZWQpcj10O3ZhciBhPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobix0KTtpZighYXx8KFwiZ2V0XCJpbiBhPyFuLl9fZXNNb2R1bGU6YS53cml0YWJsZXx8YS5jb25maWd1cmFibGUpKXthPXtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG5bdF19fX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLGEpfTpmdW5jdGlvbihlLG4sdCxyKXtpZihyPT09dW5kZWZpbmVkKXI9dDtlW3JdPW5bdF19KTt2YXIgbz10aGlzJiZ0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdHx8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImRlZmF1bHRcIix7ZW51bWVyYWJsZTp0cnVlLHZhbHVlOm59KX06ZnVuY3Rpb24oZSxuKXtlW1wiZGVmYXVsdFwiXT1ufSk7dmFyIGk9dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgbj17fTtpZihlIT1udWxsKWZvcih2YXIgdCBpbiBlKWlmKHQhPT1cImRlZmF1bHRcIiYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCkpYShuLGUsdCk7byhuLGUpO3JldHVybiBufTt2YXIgbD10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fTtuLl9fZXNNb2R1bGU9dHJ1ZTtuLlRlcm1pbmFsPXZvaWQgMDt2YXIgcz1sKHQoOTk3KSk7dmFyIHU9aSh0KDUyMikpO3ZhciBjPWZ1bmN0aW9uIFRlcm1pbmFsKGUpe3ZhciBuPWUuY29udGVudDt2YXIgdD11LnVzZU1lbW8oKGZ1bmN0aW9uKCl7cmV0dXJuIHNbXCJkZWZhdWx0XCJdLmFuc2lUb0pzb24obix7anNvbjp0cnVlLHVzZV9jbGFzc2VzOnRydWUscmVtb3ZlX2VtcHR5OnRydWV9KX0pLFtuXSk7cmV0dXJuIHUuY3JlYXRlRWxlbWVudChcImRpdlwiLHtcImRhdGEtbmV4dGpzLXRlcm1pbmFsXCI6dHJ1ZX0sdS5jcmVhdGVFbGVtZW50KFwicHJlXCIsbnVsbCx0Lm1hcCgoZnVuY3Rpb24oZSxuKXtyZXR1cm4gdS5jcmVhdGVFbGVtZW50KFwic3BhblwiLHtrZXk6XCJ0ZXJtaW5hbC1lbnRyeS1cIi5jb25jYXQobiksc3R5bGU6cih7Y29sb3I6ZS5mZz9cInZhcigtLWNvbG9yLVwiLmNvbmNhdChlLmZnLFwiKVwiKTp1bmRlZmluZWR9LGUuZGVjb3JhdGlvbj09PVwiYm9sZFwiP3tmb250V2VpZ2h0OjgwMH06ZS5kZWNvcmF0aW9uPT09XCJpdGFsaWNcIj97Zm9udFN0eWxlOlwiaXRhbGljXCJ9OnVuZGVmaW5lZCl9LGUuY29udGVudCl9KSkpKX07bi5UZXJtaW5hbD1jfSwyMzY6ZnVuY3Rpb24oZSxuLHQpe3ZhciByPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLG4sdCxyKXtpZihyPT09dW5kZWZpbmVkKXI9dDt2YXIgYT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sdCk7aWYoIWF8fChcImdldFwiaW4gYT8hbi5fX2VzTW9kdWxlOmEud3JpdGFibGV8fGEuY29uZmlndXJhYmxlKSl7YT17ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBuW3RdfX19T2JqZWN0LmRlZmluZVByb3BlcnR5KGUscixhKX06ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7ZVtyXT1uW3RdfSk7bi5fX2VzTW9kdWxlPXRydWU7bi5UZXJtaW5hbD12b2lkIDA7dmFyIGE9dCgyMTUpO3IobixhLFwiVGVybWluYWxcIil9LDQ4ODpmdW5jdGlvbihlLG4sdCl7dmFyIHI9dGhpcyYmdGhpcy5fX21ha2VUZW1wbGF0ZU9iamVjdHx8ZnVuY3Rpb24oZSxuKXtpZihPYmplY3QuZGVmaW5lUHJvcGVydHkpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwicmF3XCIse3ZhbHVlOm59KX1lbHNle2UucmF3PW59cmV0dXJuIGV9O24uX19lc01vZHVsZT10cnVlO24uc3R5bGVzPXZvaWQgMDt2YXIgYT10KDkxMCk7dmFyIG89KDAsYS5ub29wKShpfHwoaT1yKFtcIlxcbiAgW2RhdGEtbmV4dGpzLXRlcm1pbmFsXSB7XFxuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLWJnKTtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktZmcpO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLXRlcm1pbmFsXTo6c2VsZWN0aW9uLFxcbiAgW2RhdGEtbmV4dGpzLXRlcm1pbmFsXSAqOjpzZWxlY3Rpb24ge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXNlbGVjdGlvbik7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdICoge1xcbiAgICBjb2xvcjogaW5oZXJpdDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LXN0YWNrLW1vbm9zcGFjZSk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdID4gKiB7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgcGFkZGluZzogY2FsYyh2YXIoLS1zaXplLWdhcCkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSlcXG4gICAgICBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSk7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdIHByZSB7XFxuICAgIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcXG4gICAgd29yZC1icmVhazogYnJlYWstd29yZDtcXG4gIH1cXG5cIl0sW1wiXFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdIHtcXG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktYmcpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1mZyk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdOjpzZWxlY3Rpb24sXFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdICo6OnNlbGVjdGlvbiB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktc2VsZWN0aW9uKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy10ZXJtaW5hbF0gKiB7XFxuICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy10ZXJtaW5hbF0gPiAqIHtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBwYWRkaW5nOiBjYWxjKHZhcigtLXNpemUtZ2FwKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKVxcbiAgICAgIGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy10ZXJtaW5hbF0gcHJlIHtcXG4gICAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xcbiAgICB3b3JkLWJyZWFrOiBicmVhay13b3JkO1xcbiAgfVxcblwiXSkpKTtuLnN0eWxlcz1vO3ZhciBpfSw2ODM6ZnVuY3Rpb24oZSxuLHQpe3ZhciByPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLG4sdCxyKXtpZihyPT09dW5kZWZpbmVkKXI9dDt2YXIgYT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sdCk7aWYoIWF8fChcImdldFwiaW4gYT8hbi5fX2VzTW9kdWxlOmEud3JpdGFibGV8fGEuY29uZmlndXJhYmxlKSl7YT17ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBuW3RdfX19T2JqZWN0LmRlZmluZVByb3BlcnR5KGUscixhKX06ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7ZVtyXT1uW3RdfSk7dmFyIGE9dGhpcyYmdGhpcy5fX3NldE1vZHVsZURlZmF1bHR8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6dHJ1ZSx2YWx1ZTpufSl9OmZ1bmN0aW9uKGUsbil7ZVtcImRlZmF1bHRcIl09bn0pO3ZhciBvPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIG49e307aWYoZSE9bnVsbClmb3IodmFyIHQgaW4gZSlpZih0IT09XCJkZWZhdWx0XCImJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpKXIobixlLHQpO2EobixlKTtyZXR1cm4gbn07bi5fX2VzTW9kdWxlPXRydWU7bi5Ub2FzdD12b2lkIDA7dmFyIGk9byh0KDUyMikpO3ZhciBsPWZ1bmN0aW9uIFRvYXN0KGUpe3ZhciBuPWUub25DbGljayx0PWUuY2hpbGRyZW4scj1lLmNsYXNzTmFtZTtyZXR1cm4gaS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse1wiZGF0YS1uZXh0anMtdG9hc3RcIjp0cnVlLG9uQ2xpY2s6bixjbGFzc05hbWU6cn0saS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse1wiZGF0YS1uZXh0anMtdG9hc3Qtd3JhcHBlclwiOnRydWV9LHQpKX07bi5Ub2FzdD1sfSwxMjA6ZnVuY3Rpb24oZSxuLHQpe3ZhciByPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLG4sdCxyKXtpZihyPT09dW5kZWZpbmVkKXI9dDt2YXIgYT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sdCk7aWYoIWF8fChcImdldFwiaW4gYT8hbi5fX2VzTW9kdWxlOmEud3JpdGFibGV8fGEuY29uZmlndXJhYmxlKSl7YT17ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBuW3RdfX19T2JqZWN0LmRlZmluZVByb3BlcnR5KGUscixhKX06ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7ZVtyXT1uW3RdfSk7bi5fX2VzTW9kdWxlPXRydWU7bi5Ub2FzdD1uLnN0eWxlcz12b2lkIDA7dmFyIGE9dCg2OSk7cihuLGEsXCJzdHlsZXNcIik7dmFyIG89dCg2ODMpO3IobixvLFwiVG9hc3RcIil9LDY5OmZ1bmN0aW9uKGUsbix0KXt2YXIgcj10aGlzJiZ0aGlzLl9fbWFrZVRlbXBsYXRlT2JqZWN0fHxmdW5jdGlvbihlLG4pe2lmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJyYXdcIix7dmFsdWU6bn0pfWVsc2V7ZS5yYXc9bn1yZXR1cm4gZX07bi5fX2VzTW9kdWxlPXRydWU7bi5zdHlsZXM9dm9pZCAwO3ZhciBhPXQoOTEwKTt2YXIgbz0oMCxhLm5vb3ApKGl8fChpPXIoW1wiXFxuICBbZGF0YS1uZXh0anMtdG9hc3RdIHtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICBib3R0b206IHZhcigtLXNpemUtZ2FwLWRvdWJsZSk7XFxuICAgIGxlZnQ6IHZhcigtLXNpemUtZ2FwLWRvdWJsZSk7XFxuICAgIG1heC13aWR0aDogNDIwcHg7XFxuICAgIHotaW5kZXg6IDkwMDA7XFxuICB9XFxuXFxuICBAbWVkaWEgKG1heC13aWR0aDogNDQwcHgpIHtcXG4gICAgW2RhdGEtbmV4dGpzLXRvYXN0XSB7XFxuICAgICAgbWF4LXdpZHRoOiA5MHZ3O1xcbiAgICAgIGxlZnQ6IDV2dztcXG4gICAgfVxcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLXRvYXN0LXdyYXBwZXJdIHtcXG4gICAgcGFkZGluZzogMTZweDtcXG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICAgIGZvbnQtd2VpZ2h0OiA1MDA7XFxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLWJyaWdodC13aGl0ZSk7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktcmVkKTtcXG4gICAgYm94LXNoYWRvdzogMHB4IHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgdmFyKC0tc2l6ZS1nYXAtcXVhZClcXG4gICAgICByZ2JhKDAsIDAsIDAsIDAuMjUpO1xcbiAgfVxcblwiXSxbXCJcXG4gIFtkYXRhLW5leHRqcy10b2FzdF0ge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIGJvdHRvbTogdmFyKC0tc2l6ZS1nYXAtZG91YmxlKTtcXG4gICAgbGVmdDogdmFyKC0tc2l6ZS1nYXAtZG91YmxlKTtcXG4gICAgbWF4LXdpZHRoOiA0MjBweDtcXG4gICAgei1pbmRleDogOTAwMDtcXG4gIH1cXG5cXG4gIEBtZWRpYSAobWF4LXdpZHRoOiA0NDBweCkge1xcbiAgICBbZGF0YS1uZXh0anMtdG9hc3RdIHtcXG4gICAgICBtYXgtd2lkdGg6IDkwdnc7XFxuICAgICAgbGVmdDogNXZ3O1xcbiAgICB9XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtdG9hc3Qtd3JhcHBlcl0ge1xcbiAgICBwYWRkaW5nOiAxNnB4O1xcbiAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1zaXplLWdhcC1oYWxmKTtcXG4gICAgZm9udC13ZWlnaHQ6IDUwMDtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktYnJpZ2h0LXdoaXRlKTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS1yZWQpO1xcbiAgICBib3gtc2hhZG93OiAwcHggdmFyKC0tc2l6ZS1nYXAtZG91YmxlKSB2YXIoLS1zaXplLWdhcC1xdWFkKVxcbiAgICAgIHJnYmEoMCwgMCwgMCwgMC4yNSk7XFxuICB9XFxuXCJdKSkpO24uc3R5bGVzPW87dmFyIGl9LDkzNjpmdW5jdGlvbihlLG4sdCl7dmFyIHI9dGhpcyYmdGhpcy5fX21ha2VUZW1wbGF0ZU9iamVjdHx8ZnVuY3Rpb24oZSxuKXtpZihPYmplY3QuZGVmaW5lUHJvcGVydHkpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwicmF3XCIse3ZhbHVlOm59KX1lbHNle2UucmF3PW59cmV0dXJuIGV9O3ZhciBhPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLG4sdCxyKXtpZihyPT09dW5kZWZpbmVkKXI9dDt2YXIgYT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sdCk7aWYoIWF8fChcImdldFwiaW4gYT8hbi5fX2VzTW9kdWxlOmEud3JpdGFibGV8fGEuY29uZmlndXJhYmxlKSl7YT17ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBuW3RdfX19T2JqZWN0LmRlZmluZVByb3BlcnR5KGUscixhKX06ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7ZVtyXT1uW3RdfSk7dmFyIG89dGhpcyYmdGhpcy5fX3NldE1vZHVsZURlZmF1bHR8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6dHJ1ZSx2YWx1ZTpufSl9OmZ1bmN0aW9uKGUsbil7ZVtcImRlZmF1bHRcIl09bn0pO3ZhciBpPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIG49e307aWYoZSE9bnVsbClmb3IodmFyIHQgaW4gZSlpZih0IT09XCJkZWZhdWx0XCImJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpKWEobixlLHQpO28obixlKTtyZXR1cm4gbn07bi5fX2VzTW9kdWxlPXRydWU7bi5zdHlsZXM9bi5CdWlsZEVycm9yPXZvaWQgMDt2YXIgbD1pKHQoNTIyKSk7dmFyIHM9dCg2NTEpO3ZhciB1PXQoMjc4KTt2YXIgYz10KDIzNik7dmFyIGY9dCg5MTApO3ZhciBkPWZ1bmN0aW9uIEJ1aWxkRXJyb3IoZSl7dmFyIG49ZS5tZXNzYWdlO3ZhciB0PWwudXNlQ2FsbGJhY2soKGZ1bmN0aW9uKCl7fSksW10pO3JldHVybiBsLmNyZWF0ZUVsZW1lbnQodS5PdmVybGF5LHtmaXhlZDp0cnVlfSxsLmNyZWF0ZUVsZW1lbnQocy5EaWFsb2cse3R5cGU6XCJlcnJvclwiLFwiYXJpYS1sYWJlbGxlZGJ5XCI6XCJuZXh0anNfX2NvbnRhaW5lcl9idWlsZF9lcnJvcl9sYWJlbFwiLFwiYXJpYS1kZXNjcmliZWRieVwiOlwibmV4dGpzX19jb250YWluZXJfYnVpbGRfZXJyb3JfZGVzY1wiLG9uQ2xvc2U6dH0sbC5jcmVhdGVFbGVtZW50KHMuRGlhbG9nQ29udGVudCxudWxsLGwuY3JlYXRlRWxlbWVudChzLkRpYWxvZ0hlYWRlcix7Y2xhc3NOYW1lOlwibmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci1oZWFkZXJcIn0sbC5jcmVhdGVFbGVtZW50KFwiaDRcIix7aWQ6XCJuZXh0anNfX2NvbnRhaW5lcl9idWlsZF9lcnJvcl9sYWJlbFwifSxcIkZhaWxlZCB0byBjb21waWxlXCIpKSxsLmNyZWF0ZUVsZW1lbnQocy5EaWFsb2dCb2R5LHtjbGFzc05hbWU6XCJuZXh0anMtY29udGFpbmVyLWJ1aWxkLWVycm9yLWJvZHlcIn0sbC5jcmVhdGVFbGVtZW50KGMuVGVybWluYWwse2NvbnRlbnQ6bn0pLGwuY3JlYXRlRWxlbWVudChcImZvb3RlclwiLG51bGwsbC5jcmVhdGVFbGVtZW50KFwicFwiLHtpZDpcIm5leHRqc19fY29udGFpbmVyX2J1aWxkX2Vycm9yX2Rlc2NcIn0sbC5jcmVhdGVFbGVtZW50KFwic21hbGxcIixudWxsLFwiVGhpcyBlcnJvciBvY2N1cnJlZCBkdXJpbmcgdGhlIGJ1aWxkIHByb2Nlc3MgYW5kIGNhbiBvbmx5IGJlIGRpc21pc3NlZCBieSBmaXhpbmcgdGhlIGVycm9yLlwiKSkpKSkpKX07bi5CdWlsZEVycm9yPWQ7bi5zdHlsZXM9KDAsZi5ub29wKSh2fHwodj1yKFtcIlxcbiAgLm5leHRqcy1jb250YWluZXItYnVpbGQtZXJyb3ItaGVhZGVyID4gaDQge1xcbiAgICBsaW5lLWhlaWdodDogMS41O1xcbiAgICBtYXJnaW46IDA7XFxuICAgIHBhZGRpbmc6IDA7XFxuICB9XFxuXFxuICAubmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci1ib2R5IGZvb3RlciB7XFxuICAgIG1hcmdpbi10b3A6IHZhcigtLXNpemUtZ2FwKTtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWJ1aWxkLWVycm9yLWJvZHkgZm9vdGVyIHAge1xcbiAgICBtYXJnaW46IDA7XFxuICB9XFxuXFxuICAubmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci1ib2R5IHNtYWxsIHtcXG4gICAgY29sb3I6ICM3NTc1NzU7XFxuICB9XFxuXCJdLFtcIlxcbiAgLm5leHRqcy1jb250YWluZXItYnVpbGQtZXJyb3ItaGVhZGVyID4gaDQge1xcbiAgICBsaW5lLWhlaWdodDogMS41O1xcbiAgICBtYXJnaW46IDA7XFxuICAgIHBhZGRpbmc6IDA7XFxuICB9XFxuXFxuICAubmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci1ib2R5IGZvb3RlciB7XFxuICAgIG1hcmdpbi10b3A6IHZhcigtLXNpemUtZ2FwKTtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWJ1aWxkLWVycm9yLWJvZHkgZm9vdGVyIHAge1xcbiAgICBtYXJnaW46IDA7XFxuICB9XFxuXFxuICAubmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci1ib2R5IHNtYWxsIHtcXG4gICAgY29sb3I6ICM3NTc1NzU7XFxuICB9XFxuXCJdKSkpO3ZhciB2fSwzNTU6ZnVuY3Rpb24oZSxuLHQpe3ZhciByPXRoaXMmJnRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3R8fGZ1bmN0aW9uKGUsbil7aWYoT2JqZWN0LmRlZmluZVByb3BlcnR5KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcInJhd1wiLHt2YWx1ZTpufSl9ZWxzZXtlLnJhdz1ufXJldHVybiBlfTt2YXIgYT10aGlzJiZ0aGlzLl9fYXNzaWdufHxmdW5jdGlvbigpe2E9T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24oZSl7Zm9yKHZhciBuLHQ9MSxyPWFyZ3VtZW50cy5sZW5ndGg7dDxyO3QrKyl7bj1hcmd1bWVudHNbdF07Zm9yKHZhciBhIGluIG4paWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sYSkpZVthXT1uW2FdfXJldHVybiBlfTtyZXR1cm4gYS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3ZhciBvPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLG4sdCxyKXtpZihyPT09dW5kZWZpbmVkKXI9dDt2YXIgYT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sdCk7aWYoIWF8fChcImdldFwiaW4gYT8hbi5fX2VzTW9kdWxlOmEud3JpdGFibGV8fGEuY29uZmlndXJhYmxlKSl7YT17ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBuW3RdfX19T2JqZWN0LmRlZmluZVByb3BlcnR5KGUscixhKX06ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7ZVtyXT1uW3RdfSk7dmFyIGk9dGhpcyYmdGhpcy5fX3NldE1vZHVsZURlZmF1bHR8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6dHJ1ZSx2YWx1ZTpufSl9OmZ1bmN0aW9uKGUsbil7ZVtcImRlZmF1bHRcIl09bn0pO3ZhciBsPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIG49e307aWYoZSE9bnVsbClmb3IodmFyIHQgaW4gZSlpZih0IT09XCJkZWZhdWx0XCImJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpKW8obixlLHQpO2kobixlKTtyZXR1cm4gbn07dmFyIHM9dGhpcyYmdGhpcy5fX3JlYWR8fGZ1bmN0aW9uKGUsbil7dmFyIHQ9dHlwZW9mIFN5bWJvbD09PVwiZnVuY3Rpb25cIiYmZVtTeW1ib2wuaXRlcmF0b3JdO2lmKCF0KXJldHVybiBlO3ZhciByPXQuY2FsbChlKSxhLG89W10saTt0cnl7d2hpbGUoKG49PT12b2lkIDB8fG4tLSA+MCkmJiEoYT1yLm5leHQoKSkuZG9uZSlvLnB1c2goYS52YWx1ZSl9Y2F0Y2goZSl7aT17ZXJyb3I6ZX19ZmluYWxseXt0cnl7aWYoYSYmIWEuZG9uZSYmKHQ9cltcInJldHVyblwiXSkpdC5jYWxsKHIpfWZpbmFsbHl7aWYoaSl0aHJvdyBpLmVycm9yfX1yZXR1cm4gb307bi5fX2VzTW9kdWxlPXRydWU7bi5zdHlsZXM9bi5FcnJvcnM9dm9pZCAwO3ZhciB1PWwodCg1MjIpKTt2YXIgYz10KDg1MSk7dmFyIGY9dCg2NTEpO3ZhciBkPXQoNzMyKTt2YXIgdj10KDI3OCk7dmFyIHA9dCgxMjApO3ZhciBtPXQoNDAzKTt2YXIgYj10KDIzMyk7dmFyIGc9dCg5MTApO3ZhciBoPXQoODY1KTt2YXIgeT10KDQ4NCk7ZnVuY3Rpb24gZ2V0RXJyb3JTaWduYXR1cmUoZSl7dmFyIG49ZS5ldmVudDtzd2l0Y2gobi50eXBlKXtjYXNlIGMuVFlQRV9VTkhBTkRMRURfRVJST1I6Y2FzZSBjLlRZUEVfVU5IQU5ETEVEX1JFSkVDVElPTjp7cmV0dXJuXCJcIi5jb25jYXQobi5yZWFzb24ubmFtZSxcIjo6XCIpLmNvbmNhdChuLnJlYXNvbi5tZXNzYWdlLFwiOjpcIikuY29uY2F0KG4ucmVhc29uLnN0YWNrKX1kZWZhdWx0Ont9fXZhciB0PW47cmV0dXJuXCJcIn12YXIgeD1mdW5jdGlvbiBIb3RsaW5rZWRUZXh0KGUpe3ZhciBuPWUudGV4dDt2YXIgdD0vaHR0cHM/OlxcL1xcL1teXFxzLyQuPyNdLlteXFxzXCJdKi9pO3JldHVybiB1LmNyZWF0ZUVsZW1lbnQodS5GcmFnbWVudCxudWxsLHQudGVzdChuKT9uLnNwbGl0KFwiIFwiKS5tYXAoKGZ1bmN0aW9uKGUsbixyKXtpZih0LnRlc3QoZSkpe3JldHVybiB1LmNyZWF0ZUVsZW1lbnQodS5GcmFnbWVudCx7a2V5OlwibGluay1cIi5jb25jYXQobil9LHUuY3JlYXRlRWxlbWVudChcImFcIix7aHJlZjplfSxlKSxuPT09ci5sZW5ndGgtMT9cIlwiOlwiIFwiKX1yZXR1cm4gbj09PXIubGVuZ3RoLTE/dS5jcmVhdGVFbGVtZW50KHUuRnJhZ21lbnQse2tleTpcInRleHQtXCIuY29uY2F0KG4pfSxlKTp1LmNyZWF0ZUVsZW1lbnQodS5GcmFnbWVudCx7a2V5OlwidGV4dC1cIi5jb25jYXQobil9LGUsXCIgXCIpfSkpOm4pfTt2YXIgdz1mdW5jdGlvbiBFcnJvcnMoZSl7dmFyIG49ZS5lcnJvcnM7dmFyIHQ9cyh1LnVzZVN0YXRlKHt9KSwyKSxyPXRbMF0sbz10WzFdO3ZhciBpPXModS51c2VNZW1vKChmdW5jdGlvbigpe3ZhciBlPVtdO3ZhciB0PW51bGw7Zm9yKHZhciBhPTA7YTxuLmxlbmd0aDsrK2Epe3ZhciBvPW5bYV07dmFyIGk9by5pZDtpZihpIGluIHIpe2UucHVzaChyW2ldKTtjb250aW51ZX1pZihhPjApe3ZhciBsPW5bYS0xXTtpZihnZXRFcnJvclNpZ25hdHVyZShsKT09PWdldEVycm9yU2lnbmF0dXJlKG8pKXtjb250aW51ZX19dD1vO2JyZWFrfXJldHVybltlLHRdfSksW24scl0pLDIpLGw9aVswXSxjPWlbMV07dmFyIGc9dS51c2VNZW1vKChmdW5jdGlvbigpe3JldHVybiBsLmxlbmd0aDwxJiZCb29sZWFuKG4ubGVuZ3RoKX0pLFtuLmxlbmd0aCxsLmxlbmd0aF0pO3UudXNlRWZmZWN0KChmdW5jdGlvbigpe2lmKGM9PW51bGwpe3JldHVybn12YXIgZT10cnVlOygwLG0uZ2V0RXJyb3JCeVR5cGUpKGMpLnRoZW4oKGZ1bmN0aW9uKG4pe2lmKGUpe28oKGZ1bmN0aW9uKGUpe3ZhciB0O3JldHVybiBhKGEoe30sZSksKHQ9e30sdFtuLmlkXT1uLHQpKX0pKX19KSwoZnVuY3Rpb24oKXt9KSk7cmV0dXJuIGZ1bmN0aW9uKCl7ZT1mYWxzZX19KSxbY10pO3ZhciB3PXModS51c2VTdGF0ZShcImZ1bGxzY3JlZW5cIiksMiksXz13WzBdLEU9d1sxXTt2YXIgaj1zKHUudXNlU3RhdGUoMCksMiksTz1qWzBdLGs9alsxXTt2YXIgUz11LnVzZUNhbGxiYWNrKChmdW5jdGlvbihlKXtlPT09bnVsbHx8ZT09PXZvaWQgMD92b2lkIDA6ZS5wcmV2ZW50RGVmYXVsdCgpO2soKGZ1bmN0aW9uKGUpe3JldHVybiBNYXRoLm1heCgwLGUtMSl9KSl9KSxbXSk7dmFyIFQ9dS51c2VDYWxsYmFjaygoZnVuY3Rpb24oZSl7ZT09PW51bGx8fGU9PT12b2lkIDA/dm9pZCAwOmUucHJldmVudERlZmF1bHQoKTtrKChmdW5jdGlvbihlKXtyZXR1cm4gTWF0aC5tYXgoMCxNYXRoLm1pbihsLmxlbmd0aC0xLGUrMSkpfSkpfSksW2wubGVuZ3RoXSk7dmFyIEM9dS51c2VNZW1vKChmdW5jdGlvbigpe3ZhciBlO3JldHVybihlPWxbT10pIT09bnVsbCYmZSE9PXZvaWQgMD9lOm51bGx9KSxbTyxsXSk7dS51c2VFZmZlY3QoKGZ1bmN0aW9uKCl7aWYobi5sZW5ndGg8MSl7byh7fSk7RShcImhpZGRlblwiKTtrKDApfX0pLFtuLmxlbmd0aF0pO3ZhciBEPXUudXNlQ2FsbGJhY2soKGZ1bmN0aW9uKGUpe2U9PT1udWxsfHxlPT09dm9pZCAwP3ZvaWQgMDplLnByZXZlbnREZWZhdWx0KCk7RShcIm1pbmltaXplZFwiKX0pLFtdKTt2YXIgTT11LnVzZUNhbGxiYWNrKChmdW5jdGlvbihlKXtlPT09bnVsbHx8ZT09PXZvaWQgMD92b2lkIDA6ZS5wcmV2ZW50RGVmYXVsdCgpO0UoXCJoaWRkZW5cIil9KSxbXSk7dmFyIFA9dS51c2VDYWxsYmFjaygoZnVuY3Rpb24oZSl7ZT09PW51bGx8fGU9PT12b2lkIDA/dm9pZCAwOmUucHJldmVudERlZmF1bHQoKTtFKFwiZnVsbHNjcmVlblwiKX0pLFtdKTtpZihuLmxlbmd0aDwxfHxDPT1udWxsKXtyZXR1cm4gbnVsbH1pZihnKXtyZXR1cm4gdS5jcmVhdGVFbGVtZW50KHYuT3ZlcmxheSxudWxsKX1pZihfPT09XCJoaWRkZW5cIil7cmV0dXJuIG51bGx9aWYoXz09PVwibWluaW1pemVkXCIpe3JldHVybiB1LmNyZWF0ZUVsZW1lbnQocC5Ub2FzdCx7Y2xhc3NOYW1lOlwibmV4dGpzLXRvYXN0LWVycm9ycy1wYXJlbnRcIixvbkNsaWNrOlB9LHUuY3JlYXRlRWxlbWVudChcImRpdlwiLHtjbGFzc05hbWU6XCJuZXh0anMtdG9hc3QtZXJyb3JzXCJ9LHUuY3JlYXRlRWxlbWVudChcInN2Z1wiLHt4bWxuczpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsd2lkdGg6XCIyNFwiLGhlaWdodDpcIjI0XCIsdmlld0JveDpcIjAgMCAyNCAyNFwiLGZpbGw6XCJub25lXCIsc3Ryb2tlOlwiY3VycmVudENvbG9yXCIsc3Ryb2tlV2lkdGg6XCIyXCIsc3Ryb2tlTGluZWNhcDpcInJvdW5kXCIsc3Ryb2tlTGluZWpvaW46XCJyb3VuZFwifSx1LmNyZWF0ZUVsZW1lbnQoXCJjaXJjbGVcIix7Y3g6XCIxMlwiLGN5OlwiMTJcIixyOlwiMTBcIn0pLHUuY3JlYXRlRWxlbWVudChcImxpbmVcIix7eDE6XCIxMlwiLHkxOlwiOFwiLHgyOlwiMTJcIix5MjpcIjEyXCJ9KSx1LmNyZWF0ZUVsZW1lbnQoXCJsaW5lXCIse3gxOlwiMTJcIix5MTpcIjE2XCIseDI6XCIxMi4wMVwiLHkyOlwiMTZcIn0pKSx1LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsbnVsbCxsLmxlbmd0aCxcIiBlcnJvclwiLGwubGVuZ3RoPjE/XCJzXCI6XCJcIiksdS5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIse1wiZGF0YS1uZXh0anMtdG9hc3QtZXJyb3JzLWhpZGUtYnV0dG9uXCI6dHJ1ZSxjbGFzc05hbWU6XCJuZXh0anMtdG9hc3QtZXJyb3JzLWhpZGUtYnV0dG9uXCIsdHlwZTpcImJ1dHRvblwiLG9uQ2xpY2s6ZnVuY3Rpb24oZSl7ZS5zdG9wUHJvcGFnYXRpb24oKTtNKCl9LFwiYXJpYS1sYWJlbFwiOlwiSGlkZSBFcnJvcnNcIn0sdS5jcmVhdGVFbGVtZW50KGguQ2xvc2VJY29uLG51bGwpKSkpfXZhciB6PVtcInNlcnZlclwiLFwiZWRnZS1zZXJ2ZXJcIl0uaW5jbHVkZXMoKDAsYi5nZXRFcnJvclNvdXJjZSkoQy5lcnJvcil8fFwiXCIpO3JldHVybiB1LmNyZWF0ZUVsZW1lbnQodi5PdmVybGF5LG51bGwsdS5jcmVhdGVFbGVtZW50KGYuRGlhbG9nLHt0eXBlOlwiZXJyb3JcIixcImFyaWEtbGFiZWxsZWRieVwiOlwibmV4dGpzX19jb250YWluZXJfZXJyb3JzX2xhYmVsXCIsXCJhcmlhLWRlc2NyaWJlZGJ5XCI6XCJuZXh0anNfX2NvbnRhaW5lcl9lcnJvcnNfZGVzY1wiLG9uQ2xvc2U6ej91bmRlZmluZWQ6RH0sdS5jcmVhdGVFbGVtZW50KGYuRGlhbG9nQ29udGVudCxudWxsLHUuY3JlYXRlRWxlbWVudChmLkRpYWxvZ0hlYWRlcix7Y2xhc3NOYW1lOlwibmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtaGVhZGVyXCJ9LHUuY3JlYXRlRWxlbWVudChkLkxlZnRSaWdodERpYWxvZ0hlYWRlcix7cHJldmlvdXM6Tz4wP1M6bnVsbCxuZXh0Ok88bC5sZW5ndGgtMT9UOm51bGwsY2xvc2U6ej91bmRlZmluZWQ6RH0sdS5jcmVhdGVFbGVtZW50KFwic21hbGxcIixudWxsLHUuY3JlYXRlRWxlbWVudChcInNwYW5cIixudWxsLE8rMSksXCIgb2ZcIixcIiBcIix1LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsbnVsbCxsLmxlbmd0aCksXCIgdW5oYW5kbGVkIGVycm9yXCIsbC5sZW5ndGg8Mj9cIlwiOlwic1wiKSksdS5jcmVhdGVFbGVtZW50KFwiaDFcIix7aWQ6XCJuZXh0anNfX2NvbnRhaW5lcl9lcnJvcnNfbGFiZWxcIn0sej9cIlNlcnZlciBFcnJvclwiOlwiVW5oYW5kbGVkIFJ1bnRpbWUgRXJyb3JcIiksdS5jcmVhdGVFbGVtZW50KFwicFwiLHtpZDpcIm5leHRqc19fY29udGFpbmVyX2Vycm9yc19kZXNjXCJ9LEMuZXJyb3IubmFtZSxcIjpcIixcIiBcIix1LmNyZWF0ZUVsZW1lbnQoeCx7dGV4dDpDLmVycm9yLm1lc3NhZ2V9KSksej91LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIixudWxsLHUuY3JlYXRlRWxlbWVudChcInNtYWxsXCIsbnVsbCxcIlRoaXMgZXJyb3IgaGFwcGVuZWQgd2hpbGUgZ2VuZXJhdGluZyB0aGUgcGFnZS4gQW55IGNvbnNvbGUgbG9ncyB3aWxsIGJlIGRpc3BsYXllZCBpbiB0aGUgdGVybWluYWwgd2luZG93LlwiKSk6dW5kZWZpbmVkKSx1LmNyZWF0ZUVsZW1lbnQoZi5EaWFsb2dCb2R5LHtjbGFzc05hbWU6XCJuZXh0anMtY29udGFpbmVyLWVycm9ycy1ib2R5XCJ9LHUuY3JlYXRlRWxlbWVudCh5LlJ1bnRpbWVFcnJvcix7a2V5OkMuaWQudG9TdHJpbmcoKSxlcnJvcjpDfSkpKSkpfTtuLkVycm9ycz13O24uc3R5bGVzPSgwLGcubm9vcCkoX3x8KF89cihbXCJcXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgPiBoMSB7XFxuICAgIGZvbnQtc2l6ZTogdmFyKC0tc2l6ZS1mb250LWJpZyk7XFxuICAgIGxpbmUtaGVpZ2h0OiB2YXIoLS1zaXplLWZvbnQtYmlnZ2VyKTtcXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgbWFyZ2luLXRvcDogY2FsYyh2YXIoLS1zaXplLWdhcC1kb3VibGUpICsgdmFyKC0tc2l6ZS1nYXAtaGFsZikpO1xcbiAgfVxcbiAgLm5leHRqcy1jb250YWluZXItZXJyb3JzLWhlYWRlciBzbWFsbCB7XFxuICAgIGZvbnQtc2l6ZTogdmFyKC0tc2l6ZS1mb250LXNtYWxsKTtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFjY2VudHMtMSk7XFxuICAgIG1hcmdpbi1sZWZ0OiB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgfVxcbiAgLm5leHRqcy1jb250YWluZXItZXJyb3JzLWhlYWRlciBzbWFsbCA+IHNwYW4ge1xcbiAgICBmb250LWZhbWlseTogdmFyKC0tZm9udC1zdGFjay1tb25vc3BhY2UpO1xcbiAgfVxcbiAgLm5leHRqcy1jb250YWluZXItZXJyb3JzLWhlYWRlciA+IHAge1xcbiAgICBmb250LWZhbWlseTogdmFyKC0tZm9udC1zdGFjay1tb25vc3BhY2UpO1xcbiAgICBmb250LXNpemU6IHZhcigtLXNpemUtZm9udC1zbWFsbCk7XFxuICAgIGxpbmUtaGVpZ2h0OiB2YXIoLS1zaXplLWZvbnQtYmlnKTtcXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgbWFyZ2luLXRvcDogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXJlZCk7XFxuICAgIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgPiBkaXYgPiBzbWFsbCB7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgbWFyZ2luLXRvcDogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICB9XFxuICAubmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtaGVhZGVyID4gcCA+IGEge1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1yZWQpO1xcbiAgfVxcblxcbiAgLm5leHRqcy1jb250YWluZXItZXJyb3JzLWJvZHkgPiBoNTpub3QoOmZpcnN0LWNoaWxkKSB7XFxuICAgIG1hcmdpbi10b3A6IGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwKSk7XFxuICB9XFxuICAubmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtYm9keSA+IGg1IHtcXG4gICAgbWFyZ2luLWJvdHRvbTogdmFyKC0tc2l6ZS1nYXApO1xcbiAgfVxcblxcbiAgLm5leHRqcy10b2FzdC1lcnJvcnMtcGFyZW50IHtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4ycyBlYXNlO1xcbiAgfVxcbiAgLm5leHRqcy10b2FzdC1lcnJvcnMtcGFyZW50OmhvdmVyIHtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgxLjEpO1xcbiAgfVxcbiAgLm5leHRqcy10b2FzdC1lcnJvcnMge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XFxuICB9XFxuICAubmV4dGpzLXRvYXN0LWVycm9ycyA+IHN2ZyB7XFxuICAgIG1hcmdpbi1yaWdodDogdmFyKC0tc2l6ZS1nYXApO1xcbiAgfVxcbiAgLm5leHRqcy10b2FzdC1lcnJvcnMtaGlkZS1idXR0b24ge1xcbiAgICBtYXJnaW4tbGVmdDogdmFyKC0tc2l6ZS1nYXAtdHJpcGxlKTtcXG4gICAgYm9yZGVyOiBub25lO1xcbiAgICBiYWNrZ3JvdW5kOiBub25lO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1icmlnaHQtd2hpdGUpO1xcbiAgICBwYWRkaW5nOiAwO1xcbiAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMjVzIGVhc2U7XFxuICAgIG9wYWNpdHk6IDAuNztcXG4gIH1cXG4gIC5uZXh0anMtdG9hc3QtZXJyb3JzLWhpZGUtYnV0dG9uOmhvdmVyIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gIH1cXG5cIl0sW1wiXFxuICAubmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtaGVhZGVyID4gaDEge1xcbiAgICBmb250LXNpemU6IHZhcigtLXNpemUtZm9udC1iaWcpO1xcbiAgICBsaW5lLWhlaWdodDogdmFyKC0tc2l6ZS1mb250LWJpZ2dlcik7XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgICBtYXJnaW46IDA7XFxuICAgIG1hcmdpbi10b3A6IGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKTtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgc21hbGwge1xcbiAgICBmb250LXNpemU6IHZhcigtLXNpemUtZm9udC1zbWFsbCk7XFxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hY2NlbnRzLTEpO1xcbiAgICBtYXJnaW4tbGVmdDogdmFyKC0tc2l6ZS1nYXAtZG91YmxlKTtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgc21hbGwgPiBzcGFuIHtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgPiBwIHtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gICAgZm9udC1zaXplOiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xcbiAgICBsaW5lLWhlaWdodDogdmFyKC0tc2l6ZS1mb250LWJpZyk7XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgICBtYXJnaW46IDA7XFxuICAgIG1hcmdpbi10b3A6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1yZWQpO1xcbiAgICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XFxuICB9XFxuICAubmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtaGVhZGVyID4gZGl2ID4gc21hbGwge1xcbiAgICBtYXJnaW46IDA7XFxuICAgIG1hcmdpbi10b3A6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgfVxcbiAgLm5leHRqcy1jb250YWluZXItZXJyb3JzLWhlYWRlciA+IHAgPiBhIHtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktcmVkKTtcXG4gIH1cXG5cXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1ib2R5ID4gaDU6bm90KDpmaXJzdC1jaGlsZCkge1xcbiAgICBtYXJnaW4tdG9wOiBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcCkpO1xcbiAgfVxcbiAgLm5leHRqcy1jb250YWluZXItZXJyb3JzLWJvZHkgPiBoNSB7XFxuICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNpemUtZ2FwKTtcXG4gIH1cXG5cXG4gIC5uZXh0anMtdG9hc3QtZXJyb3JzLXBhcmVudCB7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMnMgZWFzZTtcXG4gIH1cXG4gIC5uZXh0anMtdG9hc3QtZXJyb3JzLXBhcmVudDpob3ZlciB7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUoMS4xKTtcXG4gIH1cXG4gIC5uZXh0anMtdG9hc3QtZXJyb3JzIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xcbiAgfVxcbiAgLm5leHRqcy10b2FzdC1lcnJvcnMgPiBzdmcge1xcbiAgICBtYXJnaW4tcmlnaHQ6IHZhcigtLXNpemUtZ2FwKTtcXG4gIH1cXG4gIC5uZXh0anMtdG9hc3QtZXJyb3JzLWhpZGUtYnV0dG9uIHtcXG4gICAgbWFyZ2luLWxlZnQ6IHZhcigtLXNpemUtZ2FwLXRyaXBsZSk7XFxuICAgIGJvcmRlcjogbm9uZTtcXG4gICAgYmFja2dyb3VuZDogbm9uZTtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktYnJpZ2h0LXdoaXRlKTtcXG4gICAgcGFkZGluZzogMDtcXG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjI1cyBlYXNlO1xcbiAgICBvcGFjaXR5OiAwLjc7XFxuICB9XFxuICAubmV4dGpzLXRvYXN0LWVycm9ycy1oaWRlLWJ1dHRvbjpob3ZlciB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICB9XFxuXCJdKSkpO3ZhciBffSw0ODQ6ZnVuY3Rpb24oZSxuLHQpe3ZhciByPXRoaXMmJnRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3R8fGZ1bmN0aW9uKGUsbil7aWYoT2JqZWN0LmRlZmluZVByb3BlcnR5KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcInJhd1wiLHt2YWx1ZTpufSl9ZWxzZXtlLnJhdz1ufXJldHVybiBlfTt2YXIgYT10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7dmFyIGE9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLHQpO2lmKCFhfHwoXCJnZXRcImluIGE/IW4uX19lc01vZHVsZTphLndyaXRhYmxlfHxhLmNvbmZpZ3VyYWJsZSkpe2E9e2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gblt0XX19fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIsYSl9OmZ1bmN0aW9uKGUsbix0LHIpe2lmKHI9PT11bmRlZmluZWQpcj10O2Vbcl09blt0XX0pO3ZhciBvPXRoaXMmJnRoaXMuX19zZXRNb2R1bGVEZWZhdWx0fHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOnRydWUsdmFsdWU6bn0pfTpmdW5jdGlvbihlLG4pe2VbXCJkZWZhdWx0XCJdPW59KTt2YXIgaT10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciBuPXt9O2lmKGUhPW51bGwpZm9yKHZhciB0IGluIGUpaWYodCE9PVwiZGVmYXVsdFwiJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KSlhKG4sZSx0KTtvKG4sZSk7cmV0dXJuIG59O3ZhciBsPXRoaXMmJnRoaXMuX19yZWFkfHxmdW5jdGlvbihlLG4pe3ZhciB0PXR5cGVvZiBTeW1ib2w9PT1cImZ1bmN0aW9uXCImJmVbU3ltYm9sLml0ZXJhdG9yXTtpZighdClyZXR1cm4gZTt2YXIgcj10LmNhbGwoZSksYSxvPVtdLGk7dHJ5e3doaWxlKChuPT09dm9pZCAwfHxuLS0gPjApJiYhKGE9ci5uZXh0KCkpLmRvbmUpby5wdXNoKGEudmFsdWUpfWNhdGNoKGUpe2k9e2Vycm9yOmV9fWZpbmFsbHl7dHJ5e2lmKGEmJiFhLmRvbmUmJih0PXJbXCJyZXR1cm5cIl0pKXQuY2FsbChyKX1maW5hbGx5e2lmKGkpdGhyb3cgaS5lcnJvcn19cmV0dXJuIG99O24uX19lc01vZHVsZT10cnVlO24uUnVudGltZUVycm9yPW4uc3R5bGVzPXZvaWQgMDt2YXIgcz1pKHQoNTIyKSk7dmFyIHU9dCg0MTMpO3ZhciBjPXQoOTEwKTt2YXIgZj10KDUwNCk7dmFyIGQ9ZnVuY3Rpb24gQ2FsbFN0YWNrRnJhbWUoZSl7dmFyIG47dmFyIHQ9ZS5mcmFtZTt2YXIgcj0obj10Lm9yaWdpbmFsU3RhY2tGcmFtZSkhPT1udWxsJiZuIT09dm9pZCAwP246dC5zb3VyY2VTdGFja0ZyYW1lO3ZhciBhPUJvb2xlYW4odC5vcmlnaW5hbENvZGVGcmFtZSk7dmFyIG89cy51c2VDYWxsYmFjaygoZnVuY3Rpb24oKXt2YXIgZTtpZighYSlyZXR1cm47dmFyIG49bmV3IFVSTFNlYXJjaFBhcmFtcztmb3IodmFyIHQgaW4gcil7bi5hcHBlbmQodCwoKGU9clt0XSkhPT1udWxsJiZlIT09dm9pZCAwP2U6XCJcIikudG9TdHJpbmcoKSl9c2VsZi5mZXRjaChcIlwiLmNvbmNhdChwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIfHxcIlwiLFwiL19fbmV4dGpzX2xhdW5jaC1lZGl0b3I/XCIpLmNvbmNhdChuLnRvU3RyaW5nKCkpKS50aGVuKChmdW5jdGlvbigpe30pLChmdW5jdGlvbigpe2NvbnNvbGUuZXJyb3IoXCJUaGVyZSB3YXMgYW4gaXNzdWUgb3BlbmluZyB0aGlzIGNvZGUgaW4geW91ciBlZGl0b3IuXCIpfSkpfSksW2Escl0pO3JldHVybiBzLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7XCJkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXCI6dHJ1ZX0scy5jcmVhdGVFbGVtZW50KFwiaDZcIix7XCJkYXRhLW5leHRqcy1mcmFtZS1leHBhbmRlZFwiOkJvb2xlYW4odC5leHBhbmRlZCl9LHIubWV0aG9kTmFtZSkscy5jcmVhdGVFbGVtZW50KFwiZGl2XCIse1wiZGF0YS1oYXMtc291cmNlXCI6YT9cInRydWVcIjp1bmRlZmluZWQsdGFiSW5kZXg6YT8xMDp1bmRlZmluZWQscm9sZTphP1wibGlua1wiOnVuZGVmaW5lZCxvbkNsaWNrOm8sdGl0bGU6YT9cIkNsaWNrIHRvIG9wZW4gaW4geW91ciBlZGl0b3JcIjp1bmRlZmluZWR9LHMuY3JlYXRlRWxlbWVudChcInNwYW5cIixudWxsLCgwLGYuZ2V0RnJhbWVTb3VyY2UpKHIpKSxzLmNyZWF0ZUVsZW1lbnQoXCJzdmdcIix7eG1sbnM6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLHZpZXdCb3g6XCIwIDAgMjQgMjRcIixmaWxsOlwibm9uZVwiLHN0cm9rZTpcImN1cnJlbnRDb2xvclwiLHN0cm9rZVdpZHRoOlwiMlwiLHN0cm9rZUxpbmVjYXA6XCJyb3VuZFwiLHN0cm9rZUxpbmVqb2luOlwicm91bmRcIn0scy5jcmVhdGVFbGVtZW50KFwicGF0aFwiLHtkOlwiTTE4IDEzdjZhMiAyIDAgMCAxLTIgMkg1YTIgMiAwIDAgMS0yLTJWOGEyIDIgMCAwIDEgMi0yaDZcIn0pLHMuY3JlYXRlRWxlbWVudChcInBvbHlsaW5lXCIse3BvaW50czpcIjE1IDMgMjEgMyAyMSA5XCJ9KSxzLmNyZWF0ZUVsZW1lbnQoXCJsaW5lXCIse3gxOlwiMTBcIix5MTpcIjE0XCIseDI6XCIyMVwiLHkyOlwiM1wifSkpKSl9O3ZhciB2PWZ1bmN0aW9uIFJ1bnRpbWVFcnJvcihlKXt2YXIgbj1lLmVycm9yO3ZhciB0PXMudXNlTWVtbygoZnVuY3Rpb24oKXtyZXR1cm4gbi5mcmFtZXMuZmluZEluZGV4KChmdW5jdGlvbihlKXtyZXR1cm4gZS5leHBhbmRlZCYmQm9vbGVhbihlLm9yaWdpbmFsQ29kZUZyYW1lKSYmQm9vbGVhbihlLm9yaWdpbmFsU3RhY2tGcmFtZSl9KSl9KSxbbi5mcmFtZXNdKTt2YXIgcj1zLnVzZU1lbW8oKGZ1bmN0aW9uKCl7dmFyIGU7cmV0dXJuKGU9bi5mcmFtZXNbdF0pIT09bnVsbCYmZSE9PXZvaWQgMD9lOm51bGx9KSxbbi5mcmFtZXMsdF0pO3ZhciBhPXMudXNlTWVtbygoZnVuY3Rpb24oKXtyZXR1cm4gdDwwP1tdOm4uZnJhbWVzLnNsaWNlKDAsdCl9KSxbbi5mcmFtZXMsdF0pO3ZhciBvPWwocy51c2VTdGF0ZShyPT1udWxsKSwyKSxpPW9bMF0sYz1vWzFdO3ZhciBmPXMudXNlQ2FsbGJhY2soKGZ1bmN0aW9uKCl7YygoZnVuY3Rpb24oZSl7cmV0dXJuIWV9KSl9KSxbXSk7dmFyIHY9cy51c2VNZW1vKChmdW5jdGlvbigpe3JldHVybiBhLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIGUuZXhwYW5kZWR8fGl9KSl9KSxbaSxhXSk7dmFyIHA9cy51c2VNZW1vKChmdW5jdGlvbigpe3JldHVybiBuLmZyYW1lcy5zbGljZSh0KzEpfSksW24uZnJhbWVzLHRdKTt2YXIgbT1zLnVzZU1lbW8oKGZ1bmN0aW9uKCl7cmV0dXJuIHAuZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4gZS5leHBhbmRlZHx8aX0pKX0pLFtpLHBdKTt2YXIgYj1zLnVzZU1lbW8oKGZ1bmN0aW9uKCl7cmV0dXJuIHAubGVuZ3RoIT09bS5sZW5ndGh8fGkmJnIhPW51bGx9KSxbaSxwLmxlbmd0aCxyLG0ubGVuZ3RoXSk7cmV0dXJuIHMuY3JlYXRlRWxlbWVudChzLkZyYWdtZW50LG51bGwscj9zLmNyZWF0ZUVsZW1lbnQocy5GcmFnbWVudCxudWxsLHMuY3JlYXRlRWxlbWVudChcImg1XCIsbnVsbCxcIlNvdXJjZVwiKSx2Lm1hcCgoZnVuY3Rpb24oZSxuKXtyZXR1cm4gcy5jcmVhdGVFbGVtZW50KGQse2tleTpcImxlYWRpbmctZnJhbWUtXCIuY29uY2F0KG4sXCItXCIpLmNvbmNhdChpKSxmcmFtZTplfSl9KSkscy5jcmVhdGVFbGVtZW50KHUuQ29kZUZyYW1lLHtzdGFja0ZyYW1lOnIub3JpZ2luYWxTdGFja0ZyYW1lLGNvZGVGcmFtZTpyLm9yaWdpbmFsQ29kZUZyYW1lfSkpOnVuZGVmaW5lZCxtLmxlbmd0aD9zLmNyZWF0ZUVsZW1lbnQocy5GcmFnbWVudCxudWxsLHMuY3JlYXRlRWxlbWVudChcImg1XCIsbnVsbCxcIkNhbGwgU3RhY2tcIiksbS5tYXAoKGZ1bmN0aW9uKGUsbil7cmV0dXJuIHMuY3JlYXRlRWxlbWVudChkLHtrZXk6XCJjYWxsLXN0YWNrLVwiLmNvbmNhdChuLFwiLVwiKS5jb25jYXQoaSksZnJhbWU6ZX0pfSkpKTp1bmRlZmluZWQsYj9zLmNyZWF0ZUVsZW1lbnQocy5GcmFnbWVudCxudWxsLHMuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLHt0YWJJbmRleDoxMCxcImRhdGEtbmV4dGpzLWRhdGEtcnVudGltZS1lcnJvci1jb2xsYXBzZWQtYWN0aW9uXCI6dHJ1ZSx0eXBlOlwiYnV0dG9uXCIsb25DbGljazpmfSxpP1wiSGlkZVwiOlwiU2hvd1wiLFwiIGNvbGxhcHNlZCBmcmFtZXNcIikpOnVuZGVmaW5lZCl9O24uUnVudGltZUVycm9yPXY7bi5zdHlsZXM9KDAsYy5ub29wKShwfHwocD1yKFtcIlxcbiAgYnV0dG9uW2RhdGEtbmV4dGpzLWRhdGEtcnVudGltZS1lcnJvci1jb2xsYXBzZWQtYWN0aW9uXSB7XFxuICAgIGJhY2tncm91bmQ6IG5vbmU7XFxuICAgIGJvcmRlcjogbm9uZTtcXG4gICAgcGFkZGluZzogMDtcXG4gICAgZm9udC1zaXplOiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xcbiAgICBsaW5lLWhlaWdodDogdmFyKC0tc2l6ZS1mb250LWJpZ2dlcik7XFxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hY2NlbnRzLTMpO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdOm5vdCg6bGFzdC1jaGlsZCkge1xcbiAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gaDYge1xcbiAgICBtYXJnaW4tdG9wOiAwO1xcbiAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcCk7XFxuICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LXN0YWNrLW1vbm9zcGFjZSk7XFxuICAgIGNvbG9yOiAjMjIyO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gaDZbZGF0YS1uZXh0anMtZnJhbWUtZXhwYW5kZWQ9J2ZhbHNlJ10ge1xcbiAgICBjb2xvcjogIzY2NjtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGRpdiB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIHBhZGRpbmctbGVmdDogY2FsYyh2YXIoLS1zaXplLWdhcCkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSk7XFxuICAgIGZvbnQtc2l6ZTogdmFyKC0tc2l6ZS1mb250LXNtYWxsKTtcXG4gICAgY29sb3I6ICM5OTk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBkaXYgPiBzdmcge1xcbiAgICB3aWR0aDogYXV0bztcXG4gICAgaGVpZ2h0OiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xcbiAgICBtYXJnaW4tbGVmdDogdmFyKC0tc2l6ZS1nYXApO1xcblxcbiAgICBkaXNwbGF5OiBub25lO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gZGl2W2RhdGEtaGFzLXNvdXJjZV0ge1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBkaXZbZGF0YS1oYXMtc291cmNlXTpob3ZlciB7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGRpdltkYXRhLWhhcy1zb3VyY2VdID4gc3ZnIHtcXG4gICAgZGlzcGxheTogdW5zZXQ7XFxuICB9XFxuXCJdLFtcIlxcbiAgYnV0dG9uW2RhdGEtbmV4dGpzLWRhdGEtcnVudGltZS1lcnJvci1jb2xsYXBzZWQtYWN0aW9uXSB7XFxuICAgIGJhY2tncm91bmQ6IG5vbmU7XFxuICAgIGJvcmRlcjogbm9uZTtcXG4gICAgcGFkZGluZzogMDtcXG4gICAgZm9udC1zaXplOiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xcbiAgICBsaW5lLWhlaWdodDogdmFyKC0tc2l6ZS1mb250LWJpZ2dlcik7XFxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hY2NlbnRzLTMpO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdOm5vdCg6bGFzdC1jaGlsZCkge1xcbiAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gaDYge1xcbiAgICBtYXJnaW4tdG9wOiAwO1xcbiAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcCk7XFxuICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LXN0YWNrLW1vbm9zcGFjZSk7XFxuICAgIGNvbG9yOiAjMjIyO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gaDZbZGF0YS1uZXh0anMtZnJhbWUtZXhwYW5kZWQ9J2ZhbHNlJ10ge1xcbiAgICBjb2xvcjogIzY2NjtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGRpdiB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIHBhZGRpbmctbGVmdDogY2FsYyh2YXIoLS1zaXplLWdhcCkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSk7XFxuICAgIGZvbnQtc2l6ZTogdmFyKC0tc2l6ZS1mb250LXNtYWxsKTtcXG4gICAgY29sb3I6ICM5OTk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBkaXYgPiBzdmcge1xcbiAgICB3aWR0aDogYXV0bztcXG4gICAgaGVpZ2h0OiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xcbiAgICBtYXJnaW4tbGVmdDogdmFyKC0tc2l6ZS1nYXApO1xcblxcbiAgICBkaXNwbGF5OiBub25lO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gZGl2W2RhdGEtaGFzLXNvdXJjZV0ge1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBkaXZbZGF0YS1oYXMtc291cmNlXTpob3ZlciB7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGRpdltkYXRhLWhhcy1zb3VyY2VdID4gc3ZnIHtcXG4gICAgZGlzcGxheTogdW5zZXQ7XFxuICB9XFxuXCJdKSkpO3ZhciBwfSw0MDM6ZnVuY3Rpb24oZSxuLHQpe3ZhciByPXRoaXMmJnRoaXMuX19hd2FpdGVyfHxmdW5jdGlvbihlLG4sdCxyKXtmdW5jdGlvbiBhZG9wdChlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIHQ/ZTpuZXcgdCgoZnVuY3Rpb24obil7bihlKX0pKX1yZXR1cm4gbmV3KHR8fCh0PVByb21pc2UpKSgoZnVuY3Rpb24odCxhKXtmdW5jdGlvbiBmdWxmaWxsZWQoZSl7dHJ5e3N0ZXAoci5uZXh0KGUpKX1jYXRjaChlKXthKGUpfX1mdW5jdGlvbiByZWplY3RlZChlKXt0cnl7c3RlcChyW1widGhyb3dcIl0oZSkpfWNhdGNoKGUpe2EoZSl9fWZ1bmN0aW9uIHN0ZXAoZSl7ZS5kb25lP3QoZS52YWx1ZSk6YWRvcHQoZS52YWx1ZSkudGhlbihmdWxmaWxsZWQscmVqZWN0ZWQpfXN0ZXAoKHI9ci5hcHBseShlLG58fFtdKSkubmV4dCgpKX0pKX07dmFyIGE9dGhpcyYmdGhpcy5fX2dlbmVyYXRvcnx8ZnVuY3Rpb24oZSxuKXt2YXIgdD17bGFiZWw6MCxzZW50OmZ1bmN0aW9uKCl7aWYob1swXSYxKXRocm93IG9bMV07cmV0dXJuIG9bMV19LHRyeXM6W10sb3BzOltdfSxyLGEsbyxpO3JldHVybiBpPXtuZXh0OnZlcmIoMCksdGhyb3c6dmVyYigxKSxyZXR1cm46dmVyYigyKX0sdHlwZW9mIFN5bWJvbD09PVwiZnVuY3Rpb25cIiYmKGlbU3ltYm9sLml0ZXJhdG9yXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSksaTtmdW5jdGlvbiB2ZXJiKGUpe3JldHVybiBmdW5jdGlvbihuKXtyZXR1cm4gc3RlcChbZSxuXSl9fWZ1bmN0aW9uIHN0ZXAoaSl7aWYocil0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTt3aGlsZSh0KXRyeXtpZihyPTEsYSYmKG89aVswXSYyP2FbXCJyZXR1cm5cIl06aVswXT9hW1widGhyb3dcIl18fCgobz1hW1wicmV0dXJuXCJdKSYmby5jYWxsKGEpLDApOmEubmV4dCkmJiEobz1vLmNhbGwoYSxpWzFdKSkuZG9uZSlyZXR1cm4gbztpZihhPTAsbylpPVtpWzBdJjIsby52YWx1ZV07c3dpdGNoKGlbMF0pe2Nhc2UgMDpjYXNlIDE6bz1pO2JyZWFrO2Nhc2UgNDp0LmxhYmVsKys7cmV0dXJue3ZhbHVlOmlbMV0sZG9uZTpmYWxzZX07Y2FzZSA1OnQubGFiZWwrKzthPWlbMV07aT1bMF07Y29udGludWU7Y2FzZSA3Omk9dC5vcHMucG9wKCk7dC50cnlzLnBvcCgpO2NvbnRpbnVlO2RlZmF1bHQ6aWYoIShvPXQudHJ5cyxvPW8ubGVuZ3RoPjAmJm9bby5sZW5ndGgtMV0pJiYoaVswXT09PTZ8fGlbMF09PT0yKSl7dD0wO2NvbnRpbnVlfWlmKGlbMF09PT0zJiYoIW98fGlbMV0+b1swXSYmaVsxXTxvWzNdKSl7dC5sYWJlbD1pWzFdO2JyZWFrfWlmKGlbMF09PT02JiZ0LmxhYmVsPG9bMV0pe3QubGFiZWw9b1sxXTtvPWk7YnJlYWt9aWYobyYmdC5sYWJlbDxvWzJdKXt0LmxhYmVsPW9bMl07dC5vcHMucHVzaChpKTticmVha31pZihvWzJdKXQub3BzLnBvcCgpO3QudHJ5cy5wb3AoKTtjb250aW51ZX1pPW4uY2FsbChlLHQpfWNhdGNoKGUpe2k9WzYsZV07YT0wfWZpbmFsbHl7cj1vPTB9aWYoaVswXSY1KXRocm93IGlbMV07cmV0dXJue3ZhbHVlOmlbMF0/aVsxXTp2b2lkIDAsZG9uZTp0cnVlfX19O24uX19lc01vZHVsZT10cnVlO24uZ2V0RXJyb3JCeVR5cGU9dm9pZCAwO3ZhciBvPXQoODUxKTt2YXIgaT10KDIzMyk7dmFyIGw9dCg1MDQpO2Z1bmN0aW9uIGdldEVycm9yQnlUeXBlKGUpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgbix0LHIsczt2YXIgdTtyZXR1cm4gYSh0aGlzLChmdW5jdGlvbihhKXtzd2l0Y2goYS5sYWJlbCl7Y2FzZSAwOm49ZS5pZCx0PWUuZXZlbnQ7cj10LnR5cGU7c3dpdGNoKHIpe2Nhc2Ugby5UWVBFX1VOSEFORExFRF9FUlJPUjpyZXR1cm5bMywxXTtjYXNlIG8uVFlQRV9VTkhBTkRMRURfUkVKRUNUSU9OOnJldHVyblszLDFdfXJldHVyblszLDNdO2Nhc2UgMTp1PXtpZDpuLHJ1bnRpbWU6dHJ1ZSxlcnJvcjp0LnJlYXNvbn07cmV0dXJuWzQsKDAsbC5nZXRPcmlnaW5hbFN0YWNrRnJhbWVzKSh0LmZyYW1lcywoMCxpLmdldEVycm9yU291cmNlKSh0LnJlYXNvbiksdC5yZWFzb24udG9TdHJpbmcoKSldO2Nhc2UgMjpyZXR1cm5bMiwodS5mcmFtZXM9YS5zZW50KCksdSldO2Nhc2UgMzp7cmV0dXJuWzMsNF19YS5sYWJlbD00O2Nhc2UgNDpzPXQ7dGhyb3cgbmV3IEVycm9yKFwidHlwZSBzeXN0ZW0gaW52YXJpYW50IHZpb2xhdGlvblwiKX19KSl9KSl9bi5nZXRFcnJvckJ5VHlwZT1nZXRFcnJvckJ5VHlwZX0sMjMzOmZ1bmN0aW9uKGUsbix0KXt2YXIgcj10aGlzJiZ0aGlzLl9fYXNzaWdufHxmdW5jdGlvbigpe3I9T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24oZSl7Zm9yKHZhciBuLHQ9MSxyPWFyZ3VtZW50cy5sZW5ndGg7dDxyO3QrKyl7bj1hcmd1bWVudHNbdF07Zm9yKHZhciBhIGluIG4paWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sYSkpZVthXT1uW2FdfXJldHVybiBlfTtyZXR1cm4gci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O24uX19lc01vZHVsZT10cnVlO24uZ2V0U2VydmVyRXJyb3I9bi5kZWNvcmF0ZVNlcnZlckVycm9yPW4uZ2V0RXJyb3JTb3VyY2U9bi5nZXRGaWxlc3lzdGVtRnJhbWU9dm9pZCAwO3ZhciBhPXQoOTc0KTtmdW5jdGlvbiBnZXRGaWxlc3lzdGVtRnJhbWUoZSl7dmFyIG49cih7fSxlKTtpZih0eXBlb2Ygbi5maWxlPT09XCJzdHJpbmdcIil7aWYobi5maWxlLnN0YXJ0c1dpdGgoXCIvXCIpfHwvXlthLXpdOlxcXFwvaS50ZXN0KG4uZmlsZSl8fG4uZmlsZS5zdGFydHNXaXRoKFwiXFxcXFxcXFxcIikpe24uZmlsZT1cImZpbGU6Ly9cIi5jb25jYXQobi5maWxlKX19cmV0dXJuIG59bi5nZXRGaWxlc3lzdGVtRnJhbWU9Z2V0RmlsZXN5c3RlbUZyYW1lO3ZhciBvPVN5bWJvbChcIk5leHRqc0Vycm9yXCIpO2Z1bmN0aW9uIGdldEVycm9yU291cmNlKGUpe3JldHVybiBlW29dfHxudWxsfW4uZ2V0RXJyb3JTb3VyY2U9Z2V0RXJyb3JTb3VyY2U7ZnVuY3Rpb24gZGVjb3JhdGVTZXJ2ZXJFcnJvcihlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG8se3dyaXRhYmxlOmZhbHNlLGVudW1lcmFibGU6ZmFsc2UsY29uZmlndXJhYmxlOmZhbHNlLHZhbHVlOm59KX1uLmRlY29yYXRlU2VydmVyRXJyb3I9ZGVjb3JhdGVTZXJ2ZXJFcnJvcjtmdW5jdGlvbiBnZXRTZXJ2ZXJFcnJvcihlLG4pe3ZhciB0O3RyeXt0aHJvdyBuZXcgRXJyb3IoZS5tZXNzYWdlKX1jYXRjaChlKXt0PWV9dC5uYW1lPWUubmFtZTt0cnl7dC5zdGFjaz1cIlwiLmNvbmNhdCh0LnRvU3RyaW5nKCksXCJcXG5cIikuY29uY2F0KCgwLGEucGFyc2UpKGUuc3RhY2spLm1hcChnZXRGaWxlc3lzdGVtRnJhbWUpLm1hcCgoZnVuY3Rpb24oZSl7dmFyIG49XCIgICAgYXQgXCIuY29uY2F0KGUubWV0aG9kTmFtZSk7aWYoZS5maWxlKXt2YXIgdD1lLmZpbGU7aWYoZS5saW5lTnVtYmVyKXt0Kz1cIjpcIi5jb25jYXQoZS5saW5lTnVtYmVyKTtpZihlLmNvbHVtbil7dCs9XCI6XCIuY29uY2F0KGUuY29sdW1uKX19bis9XCIgKFwiLmNvbmNhdCh0LFwiKVwiKX1yZXR1cm4gbn0pKS5qb2luKFwiXFxuXCIpKX1jYXRjaChuKXt0LnN0YWNrPWUuc3RhY2t9ZGVjb3JhdGVTZXJ2ZXJFcnJvcih0LG4pO3JldHVybiB0fW4uZ2V0U2VydmVyRXJyb3I9Z2V0U2VydmVyRXJyb3J9LDkxMDpmdW5jdGlvbihlLG4pe24uX19lc01vZHVsZT10cnVlO24ubm9vcD12b2lkIDA7ZnVuY3Rpb24gbm9vcChlKXt2YXIgbj1bXTtmb3IodmFyIHQ9MTt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXtuW3QtMV09YXJndW1lbnRzW3RdfXZhciByPWUubGVuZ3RoLTE7cmV0dXJuIGUuc2xpY2UoMCxyKS5yZWR1Y2UoKGZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gZSt0K25bcl19KSxcIlwiKStlW3JdfW4ubm9vcD1ub29wfSw2MzY6ZnVuY3Rpb24oZSxuLHQpe24uX19lc01vZHVsZT10cnVlO24ucGFyc2VTdGFjaz12b2lkIDA7dmFyIHI9dCg5NzQpO3ZhciBhPS9cXC9fbmV4dChcXC9zdGF0aWNcXC8uKykvZztmdW5jdGlvbiBwYXJzZVN0YWNrKGUpe3ZhciBuPSgwLHIucGFyc2UpKGUpO3JldHVybiBuLm1hcCgoZnVuY3Rpb24oZSl7dmFyIG4sdDt0cnl7dmFyIHI9bmV3IFVSTChlLmZpbGUpO3ZhciBvPWEuZXhlYyhyLnBhdGhuYW1lKTtpZihvKXt2YXIgaT0odD0obj1wcm9jZXNzLmVudi5fX05FWFRfRElTVF9ESVIpPT09bnVsbHx8bj09PXZvaWQgMD92b2lkIDA6bi5yZXBsYWNlKC9cXFxcL2csXCIvXCIpKT09PW51bGx8fHQ9PT12b2lkIDA/dm9pZCAwOnQucmVwbGFjZSgvXFwvJC8sXCJcIik7aWYoaSl7ZS5maWxlPVwiZmlsZTovL1wiK2kuY29uY2F0KG8ucG9wKCkpfX19Y2F0Y2goZSl7fXJldHVybiBlfSkpfW4ucGFyc2VTdGFjaz1wYXJzZVN0YWNrfSw1MDQ6ZnVuY3Rpb24oZSxuKXt2YXIgdD10aGlzJiZ0aGlzLl9fYXdhaXRlcnx8ZnVuY3Rpb24oZSxuLHQscil7ZnVuY3Rpb24gYWRvcHQoZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiB0P2U6bmV3IHQoKGZ1bmN0aW9uKG4pe24oZSl9KSl9cmV0dXJuIG5ldyh0fHwodD1Qcm9taXNlKSkoKGZ1bmN0aW9uKHQsYSl7ZnVuY3Rpb24gZnVsZmlsbGVkKGUpe3RyeXtzdGVwKHIubmV4dChlKSl9Y2F0Y2goZSl7YShlKX19ZnVuY3Rpb24gcmVqZWN0ZWQoZSl7dHJ5e3N0ZXAocltcInRocm93XCJdKGUpKX1jYXRjaChlKXthKGUpfX1mdW5jdGlvbiBzdGVwKGUpe2UuZG9uZT90KGUudmFsdWUpOmFkb3B0KGUudmFsdWUpLnRoZW4oZnVsZmlsbGVkLHJlamVjdGVkKX1zdGVwKChyPXIuYXBwbHkoZSxufHxbXSkpLm5leHQoKSl9KSl9O3ZhciByPXRoaXMmJnRoaXMuX19nZW5lcmF0b3J8fGZ1bmN0aW9uKGUsbil7dmFyIHQ9e2xhYmVsOjAsc2VudDpmdW5jdGlvbigpe2lmKG9bMF0mMSl0aHJvdyBvWzFdO3JldHVybiBvWzFdfSx0cnlzOltdLG9wczpbXX0scixhLG8saTtyZXR1cm4gaT17bmV4dDp2ZXJiKDApLHRocm93OnZlcmIoMSkscmV0dXJuOnZlcmIoMil9LHR5cGVvZiBTeW1ib2w9PT1cImZ1bmN0aW9uXCImJihpW1N5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pLGk7ZnVuY3Rpb24gdmVyYihlKXtyZXR1cm4gZnVuY3Rpb24obil7cmV0dXJuIHN0ZXAoW2Usbl0pfX1mdW5jdGlvbiBzdGVwKGkpe2lmKHIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7d2hpbGUodCl0cnl7aWYocj0xLGEmJihvPWlbMF0mMj9hW1wicmV0dXJuXCJdOmlbMF0/YVtcInRocm93XCJdfHwoKG89YVtcInJldHVyblwiXSkmJm8uY2FsbChhKSwwKTphLm5leHQpJiYhKG89by5jYWxsKGEsaVsxXSkpLmRvbmUpcmV0dXJuIG87aWYoYT0wLG8paT1baVswXSYyLG8udmFsdWVdO3N3aXRjaChpWzBdKXtjYXNlIDA6Y2FzZSAxOm89aTticmVhaztjYXNlIDQ6dC5sYWJlbCsrO3JldHVybnt2YWx1ZTppWzFdLGRvbmU6ZmFsc2V9O2Nhc2UgNTp0LmxhYmVsKys7YT1pWzFdO2k9WzBdO2NvbnRpbnVlO2Nhc2UgNzppPXQub3BzLnBvcCgpO3QudHJ5cy5wb3AoKTtjb250aW51ZTtkZWZhdWx0OmlmKCEobz10LnRyeXMsbz1vLmxlbmd0aD4wJiZvW28ubGVuZ3RoLTFdKSYmKGlbMF09PT02fHxpWzBdPT09Mikpe3Q9MDtjb250aW51ZX1pZihpWzBdPT09MyYmKCFvfHxpWzFdPm9bMF0mJmlbMV08b1szXSkpe3QubGFiZWw9aVsxXTticmVha31pZihpWzBdPT09NiYmdC5sYWJlbDxvWzFdKXt0LmxhYmVsPW9bMV07bz1pO2JyZWFrfWlmKG8mJnQubGFiZWw8b1syXSl7dC5sYWJlbD1vWzJdO3Qub3BzLnB1c2goaSk7YnJlYWt9aWYob1syXSl0Lm9wcy5wb3AoKTt0LnRyeXMucG9wKCk7Y29udGludWV9aT1uLmNhbGwoZSx0KX1jYXRjaChlKXtpPVs2LGVdO2E9MH1maW5hbGx5e3I9bz0wfWlmKGlbMF0mNSl0aHJvdyBpWzFdO3JldHVybnt2YWx1ZTppWzBdP2lbMV06dm9pZCAwLGRvbmU6dHJ1ZX19fTtuLl9fZXNNb2R1bGU9dHJ1ZTtuLmdldEZyYW1lU291cmNlPW4uZ2V0T3JpZ2luYWxTdGFja0ZyYW1lcz1uLmdldE9yaWdpbmFsU3RhY2tGcmFtZT12b2lkIDA7ZnVuY3Rpb24gZ2V0T3JpZ2luYWxTdGFja0ZyYW1lKGUsbixhKXt2YXIgbyxpO2Z1bmN0aW9uIF9nZXRPcmlnaW5hbFN0YWNrRnJhbWUoKXt2YXIgbyxpLGwscyx1O3JldHVybiB0KHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgdCxjLGYsZCx2LHAsbSxiLGc7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDp0PW5ldyBVUkxTZWFyY2hQYXJhbXM7dC5hcHBlbmQoXCJpc1NlcnZlclwiLFN0cmluZyhuPT09XCJzZXJ2ZXJcIikpO3QuYXBwZW5kKFwiaXNFZGdlU2VydmVyXCIsU3RyaW5nKG49PT1cImVkZ2Utc2VydmVyXCIpKTt0LmFwcGVuZChcImVycm9yTWVzc2FnZVwiLGEpO2ZvcihjIGluIGUpe3QuYXBwZW5kKGMsKChvPWVbY10pIT09bnVsbCYmbyE9PXZvaWQgMD9vOlwiXCIpLnRvU3RyaW5nKCkpfWY9bmV3IEFib3J0Q29udHJvbGxlcjtkPXNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7cmV0dXJuIGYuYWJvcnQoKX0pLDNlMyk7cmV0dXJuWzQsc2VsZi5mZXRjaChcIlwiLmNvbmNhdChwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIfHxcIlwiLFwiL19fbmV4dGpzX29yaWdpbmFsLXN0YWNrLWZyYW1lP1wiKS5jb25jYXQodC50b1N0cmluZygpKSx7c2lnbmFsOmYuc2lnbmFsfSlbXCJmaW5hbGx5XCJdKChmdW5jdGlvbigpe2NsZWFyVGltZW91dChkKX0pKV07Y2FzZSAxOnY9ci5zZW50KCk7aWYoISghdi5va3x8di5zdGF0dXM9PT0yMDQpKXJldHVyblszLDNdO209KHA9UHJvbWlzZSkucmVqZWN0O2I9RXJyb3IuYmluZDtyZXR1cm5bNCx2LnRleHQoKV07Y2FzZSAyOnJldHVyblsyLG0uYXBwbHkocCxbbmV3KGIuYXBwbHkoRXJyb3IsW3ZvaWQgMCxyLnNlbnQoKV0pKV0pXTtjYXNlIDM6cmV0dXJuWzQsdi5qc29uKCldO2Nhc2UgNDpnPXIuc2VudCgpO3JldHVyblsyLHtlcnJvcjpmYWxzZSxyZWFzb246bnVsbCxleHRlcm5hbDpmYWxzZSxleHBhbmRlZDohQm9vbGVhbigodT0oKGk9ZS5maWxlKT09PW51bGx8fGk9PT12b2lkIDA/dm9pZCAwOmkuaW5jbHVkZXMoXCJub2RlX21vZHVsZXNcIikpfHwoKHM9KGw9Zy5vcmlnaW5hbFN0YWNrRnJhbWUpPT09bnVsbHx8bD09PXZvaWQgMD92b2lkIDA6bC5maWxlKT09PW51bGx8fHM9PT12b2lkIDA/dm9pZCAwOnMuaW5jbHVkZXMoXCJub2RlX21vZHVsZXNcIikpKSE9PW51bGwmJnUhPT12b2lkIDA/dTp0cnVlKSxzb3VyY2VTdGFja0ZyYW1lOmUsb3JpZ2luYWxTdGFja0ZyYW1lOmcub3JpZ2luYWxTdGFja0ZyYW1lLG9yaWdpbmFsQ29kZUZyYW1lOmcub3JpZ2luYWxDb2RlRnJhbWV8fG51bGx9XX19KSl9KSl9aWYoISgoKG89ZS5maWxlKT09PW51bGx8fG89PT12b2lkIDA/dm9pZCAwOm8uc3RhcnRzV2l0aChcIndlYnBhY2staW50ZXJuYWw6XCIpKXx8KChpPWUuZmlsZSk9PT1udWxsfHxpPT09dm9pZCAwP3ZvaWQgMDppLnN0YXJ0c1dpdGgoXCJmaWxlOlwiKSkpKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtlcnJvcjpmYWxzZSxyZWFzb246bnVsbCxleHRlcm5hbDp0cnVlLGV4cGFuZGVkOmZhbHNlLHNvdXJjZVN0YWNrRnJhbWU6ZSxvcmlnaW5hbFN0YWNrRnJhbWU6bnVsbCxvcmlnaW5hbENvZGVGcmFtZTpudWxsfSl9cmV0dXJuIF9nZXRPcmlnaW5hbFN0YWNrRnJhbWUoKVtcImNhdGNoXCJdKChmdW5jdGlvbihuKXt2YXIgdCxyO3JldHVybntlcnJvcjp0cnVlLHJlYXNvbjoocj0odD1uPT09bnVsbHx8bj09PXZvaWQgMD92b2lkIDA6bi5tZXNzYWdlKSE9PW51bGwmJnQhPT12b2lkIDA/dDpuPT09bnVsbHx8bj09PXZvaWQgMD92b2lkIDA6bi50b1N0cmluZygpKSE9PW51bGwmJnIhPT12b2lkIDA/cjpcIlVua25vd24gRXJyb3JcIixleHRlcm5hbDpmYWxzZSxleHBhbmRlZDpmYWxzZSxzb3VyY2VTdGFja0ZyYW1lOmUsb3JpZ2luYWxTdGFja0ZyYW1lOm51bGwsb3JpZ2luYWxDb2RlRnJhbWU6bnVsbH19KSl9bi5nZXRPcmlnaW5hbFN0YWNrRnJhbWU9Z2V0T3JpZ2luYWxTdGFja0ZyYW1lO2Z1bmN0aW9uIGdldE9yaWdpbmFsU3RhY2tGcmFtZXMoZSxuLHQpe3JldHVybiBQcm9taXNlLmFsbChlLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIGdldE9yaWdpbmFsU3RhY2tGcmFtZShlLG4sdCl9KSkpfW4uZ2V0T3JpZ2luYWxTdGFja0ZyYW1lcz1nZXRPcmlnaW5hbFN0YWNrRnJhbWVzO2Z1bmN0aW9uIGdldEZyYW1lU291cmNlKGUpe3ZhciBuO3ZhciB0PVwiXCI7dHJ5e3ZhciByPW5ldyBVUkwoZS5maWxlKTtpZih0eXBlb2YgZ2xvYmFsVGhpcyE9PVwidW5kZWZpbmVkXCImJigobj1nbG9iYWxUaGlzLmxvY2F0aW9uKT09PW51bGx8fG49PT12b2lkIDA/dm9pZCAwOm4ub3JpZ2luKSE9PXIub3JpZ2luKXtpZihyLm9yaWdpbj09PVwibnVsbFwiKXt0Kz1yLnByb3RvY29sfWVsc2V7dCs9ci5vcmlnaW59fXQrPXIucGF0aG5hbWU7dCs9XCIgXCJ9Y2F0Y2gobil7dCs9KGUuZmlsZXx8XCIodW5rbm93bilcIikrXCIgXCJ9aWYoZS5saW5lTnVtYmVyIT1udWxsKXtpZihlLmNvbHVtbiE9bnVsbCl7dCs9XCIoXCIuY29uY2F0KGUubGluZU51bWJlcixcIjpcIikuY29uY2F0KGUuY29sdW1uLFwiKSBcIil9ZWxzZXt0Kz1cIihcIi5jb25jYXQoZS5saW5lTnVtYmVyLFwiKSBcIil9fXJldHVybiB0LnNsaWNlKDAsLTEpfW4uZ2V0RnJhbWVTb3VyY2U9Z2V0RnJhbWVTb3VyY2V9LDE2OTpmdW5jdGlvbihlLG4sdCl7dmFyIHI9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsbix0LHIpe2lmKHI9PT11bmRlZmluZWQpcj10O3ZhciBhPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobix0KTtpZighYXx8KFwiZ2V0XCJpbiBhPyFuLl9fZXNNb2R1bGU6YS53cml0YWJsZXx8YS5jb25maWd1cmFibGUpKXthPXtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG5bdF19fX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLGEpfTpmdW5jdGlvbihlLG4sdCxyKXtpZihyPT09dW5kZWZpbmVkKXI9dDtlW3JdPW5bdF19KTt2YXIgYT10aGlzJiZ0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdHx8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImRlZmF1bHRcIix7ZW51bWVyYWJsZTp0cnVlLHZhbHVlOm59KX06ZnVuY3Rpb24oZSxuKXtlW1wiZGVmYXVsdFwiXT1ufSk7dmFyIG89dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgbj17fTtpZihlIT1udWxsKWZvcih2YXIgdCBpbiBlKWlmKHQhPT1cImRlZmF1bHRcIiYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCkpcihuLGUsdCk7YShuLGUpO3JldHVybiBufTtuLl9fZXNNb2R1bGU9dHJ1ZTtuLnVzZU9uQ2xpY2tPdXRzaWRlPXZvaWQgMDt2YXIgaT1vKHQoNTIyKSk7ZnVuY3Rpb24gdXNlT25DbGlja091dHNpZGUoZSxuKXtpLnVzZUVmZmVjdCgoZnVuY3Rpb24oKXtpZihlPT1udWxsfHxuPT1udWxsKXtyZXR1cm59dmFyIGxpc3RlbmVyPWZ1bmN0aW9uKHQpe2lmKCFlfHxlLmNvbnRhaW5zKHQudGFyZ2V0KSl7cmV0dXJufW4odCl9O3ZhciB0PWUuZ2V0Um9vdE5vZGUoKTt0LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIixsaXN0ZW5lcik7dC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLGxpc3RlbmVyKTtyZXR1cm4gZnVuY3Rpb24oKXt0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIixsaXN0ZW5lcik7dC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLGxpc3RlbmVyKX19KSxbbixlXSl9bi51c2VPbkNsaWNrT3V0c2lkZT11c2VPbkNsaWNrT3V0c2lkZX0sODY1OmZ1bmN0aW9uKGUsbix0KXt2YXIgcj10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7dmFyIGE9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLHQpO2lmKCFhfHwoXCJnZXRcImluIGE/IW4uX19lc01vZHVsZTphLndyaXRhYmxlfHxhLmNvbmZpZ3VyYWJsZSkpe2E9e2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gblt0XX19fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIsYSl9OmZ1bmN0aW9uKGUsbix0LHIpe2lmKHI9PT11bmRlZmluZWQpcj10O2Vbcl09blt0XX0pO3ZhciBhPXRoaXMmJnRoaXMuX19zZXRNb2R1bGVEZWZhdWx0fHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOnRydWUsdmFsdWU6bn0pfTpmdW5jdGlvbihlLG4pe2VbXCJkZWZhdWx0XCJdPW59KTt2YXIgbz10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciBuPXt9O2lmKGUhPW51bGwpZm9yKHZhciB0IGluIGUpaWYodCE9PVwiZGVmYXVsdFwiJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KSlyKG4sZSx0KTthKG4sZSk7cmV0dXJuIG59O24uX19lc01vZHVsZT10cnVlO24uQ2xvc2VJY29uPXZvaWQgMDt2YXIgaT1vKHQoNTIyKSk7dmFyIENsb3NlSWNvbj1mdW5jdGlvbigpe3JldHVybiBpLmNyZWF0ZUVsZW1lbnQoXCJzdmdcIix7d2lkdGg6XCIyNFwiLGhlaWdodDpcIjI0XCIsdmlld0JveDpcIjAgMCAyNCAyNFwiLGZpbGw6XCJub25lXCIseG1sbnM6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wifSxpLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIse2Q6XCJNMTggNkw2IDE4XCIsc3Ryb2tlOlwiY3VycmVudENvbG9yXCIsc3Ryb2tlV2lkdGg6XCIyXCIsc3Ryb2tlTGluZWNhcDpcInJvdW5kXCIsc3Ryb2tlTGluZWpvaW46XCJyb3VuZFwifSksaS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLHtkOlwiTTYgNkwxOCAxOFwiLHN0cm9rZTpcImN1cnJlbnRDb2xvclwiLHN0cm9rZVdpZHRoOlwiMlwiLHN0cm9rZUxpbmVjYXA6XCJyb3VuZFwiLHN0cm9rZUxpbmVqb2luOlwicm91bmRcIn0pKX07bi5DbG9zZUljb249Q2xvc2VJY29ufSw4ODQ6ZnVuY3Rpb24oZSxuLHQpe3ZhciByPXRoaXMmJnRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3R8fGZ1bmN0aW9uKGUsbil7aWYoT2JqZWN0LmRlZmluZVByb3BlcnR5KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcInJhd1wiLHt2YWx1ZTpufSl9ZWxzZXtlLnJhdz1ufXJldHVybiBlfTt2YXIgYT10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7dmFyIGE9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLHQpO2lmKCFhfHwoXCJnZXRcImluIGE/IW4uX19lc01vZHVsZTphLndyaXRhYmxlfHxhLmNvbmZpZ3VyYWJsZSkpe2E9e2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gblt0XX19fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIsYSl9OmZ1bmN0aW9uKGUsbix0LHIpe2lmKHI9PT11bmRlZmluZWQpcj10O2Vbcl09blt0XX0pO3ZhciBvPXRoaXMmJnRoaXMuX19zZXRNb2R1bGVEZWZhdWx0fHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOnRydWUsdmFsdWU6bn0pfTpmdW5jdGlvbihlLG4pe2VbXCJkZWZhdWx0XCJdPW59KTt2YXIgaT10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciBuPXt9O2lmKGUhPW51bGwpZm9yKHZhciB0IGluIGUpaWYodCE9PVwiZGVmYXVsdFwiJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KSlhKG4sZSx0KTtvKG4sZSk7cmV0dXJuIG59O24uX19lc01vZHVsZT10cnVlO24uQmFzZT12b2lkIDA7dmFyIGw9aSh0KDUyMikpO3ZhciBzPXQoOTEwKTtmdW5jdGlvbiBCYXNlKCl7cmV0dXJuIGwuY3JlYXRlRWxlbWVudChcInN0eWxlXCIsbnVsbCwoMCxzLm5vb3ApKHV8fCh1PXIoW1wiXFxuICAgICAgICA6aG9zdCB7XFxuICAgICAgICAgIC0tc2l6ZS1nYXAtaGFsZjogNHB4O1xcbiAgICAgICAgICAtLXNpemUtZ2FwOiA4cHg7XFxuICAgICAgICAgIC0tc2l6ZS1nYXAtZG91YmxlOiAxNnB4O1xcbiAgICAgICAgICAtLXNpemUtZ2FwLXRyaXBsZTogMjRweDtcXG4gICAgICAgICAgLS1zaXplLWdhcC1xdWFkOiAzMnB4O1xcblxcbiAgICAgICAgICAtLXNpemUtZm9udC1zbWFsbDogMTRweDtcXG4gICAgICAgICAgLS1zaXplLWZvbnQ6IDE2cHg7XFxuICAgICAgICAgIC0tc2l6ZS1mb250LWJpZzogMjBweDtcXG4gICAgICAgICAgLS1zaXplLWZvbnQtYmlnZ2VyOiAyNHB4O1xcblxcbiAgICAgICAgICAtLWNvbG9yLWFjY2VudHMtMTogIzgwODA4MDtcXG4gICAgICAgICAgLS1jb2xvci1hY2NlbnRzLTI6ICMyMjIyMjI7XFxuICAgICAgICAgIC0tY29sb3ItYWNjZW50cy0zOiAjNDA0MDQwO1xcblxcbiAgICAgICAgICAtLWZvbnQtc3RhY2stbW9ub3NwYWNlOiAnU0ZNb25vLVJlZ3VsYXInLCBDb25zb2xhcywgJ0xpYmVyYXRpb24gTW9ubycsXFxuICAgICAgICAgICAgTWVubG8sIENvdXJpZXIsIG1vbm9zcGFjZTtcXG5cXG4gICAgICAgICAgLS1jb2xvci1hbnNpLXNlbGVjdGlvbjogcmdiYSg5NSwgMTI2LCAxNTEsIDAuNDgpO1xcbiAgICAgICAgICAtLWNvbG9yLWFuc2ktYmc6ICMxMTExMTE7XFxuICAgICAgICAgIC0tY29sb3ItYW5zaS1mZzogI2NjY2NjYztcXG5cXG4gICAgICAgICAgLS1jb2xvci1hbnNpLXdoaXRlOiAjNzc3Nzc3O1xcbiAgICAgICAgICAtLWNvbG9yLWFuc2ktYmxhY2s6ICMxNDE0MTQ7XFxuICAgICAgICAgIC0tY29sb3ItYW5zaS1ibHVlOiAjMDBhYWZmO1xcbiAgICAgICAgICAtLWNvbG9yLWFuc2ktY3lhbjogIzg4ZGRmZjtcXG4gICAgICAgICAgLS1jb2xvci1hbnNpLWdyZWVuOiAjOThlYzY1O1xcbiAgICAgICAgICAtLWNvbG9yLWFuc2ktbWFnZW50YTogI2FhODhmZjtcXG4gICAgICAgICAgLS1jb2xvci1hbnNpLXJlZDogI2ZmNTU1NTtcXG4gICAgICAgICAgLS1jb2xvci1hbnNpLXllbGxvdzogI2ZmY2MzMztcXG4gICAgICAgICAgLS1jb2xvci1hbnNpLWJyaWdodC13aGl0ZTogI2ZmZmZmZjtcXG4gICAgICAgICAgLS1jb2xvci1hbnNpLWJyaWdodC1ibGFjazogIzc3Nzc3NztcXG4gICAgICAgICAgLS1jb2xvci1hbnNpLWJyaWdodC1ibHVlOiAjMzNiYmZmO1xcbiAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LWN5YW46ICNiYmVjZmY7XFxuICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtZ3JlZW46ICNiNmYyOTI7XFxuICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtbWFnZW50YTogI2NlYmJmZjtcXG4gICAgICAgICAgLS1jb2xvci1hbnNpLWJyaWdodC1yZWQ6ICNmZjg4ODg7XFxuICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQteWVsbG93OiAjZmZkOTY2O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLm1vbm8ge1xcbiAgICAgICAgICBmb250LWZhbWlseTogdmFyKC0tZm9udC1zdGFjay1tb25vc3BhY2UpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaDEsXFxuICAgICAgICBoMixcXG4gICAgICAgIGgzLFxcbiAgICAgICAgaDQsXFxuICAgICAgICBoNSxcXG4gICAgICAgIGg2IHtcXG4gICAgICAgICAgbWFyZ2luLWJvdHRvbTogdmFyKC0tc2l6ZS1nYXApO1xcbiAgICAgICAgICBmb250LXdlaWdodDogNTAwO1xcbiAgICAgICAgICBsaW5lLWhlaWdodDogMS41O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaDEge1xcbiAgICAgICAgICBmb250LXNpemU6IDQwcHg7XFxuICAgICAgICB9XFxuICAgICAgICBoMiB7XFxuICAgICAgICAgIGZvbnQtc2l6ZTogMzJweDtcXG4gICAgICAgIH1cXG4gICAgICAgIGgzIHtcXG4gICAgICAgICAgZm9udC1zaXplOiAyOHB4O1xcbiAgICAgICAgfVxcbiAgICAgICAgaDQge1xcbiAgICAgICAgICBmb250LXNpemU6IDI0cHg7XFxuICAgICAgICB9XFxuICAgICAgICBoNSB7XFxuICAgICAgICAgIGZvbnQtc2l6ZTogMjBweDtcXG4gICAgICAgIH1cXG4gICAgICAgIGg2IHtcXG4gICAgICAgICAgZm9udC1zaXplOiAxNnB4O1xcbiAgICAgICAgfVxcbiAgICAgIFwiXSxbXCJcXG4gICAgICAgIDpob3N0IHtcXG4gICAgICAgICAgLS1zaXplLWdhcC1oYWxmOiA0cHg7XFxuICAgICAgICAgIC0tc2l6ZS1nYXA6IDhweDtcXG4gICAgICAgICAgLS1zaXplLWdhcC1kb3VibGU6IDE2cHg7XFxuICAgICAgICAgIC0tc2l6ZS1nYXAtdHJpcGxlOiAyNHB4O1xcbiAgICAgICAgICAtLXNpemUtZ2FwLXF1YWQ6IDMycHg7XFxuXFxuICAgICAgICAgIC0tc2l6ZS1mb250LXNtYWxsOiAxNHB4O1xcbiAgICAgICAgICAtLXNpemUtZm9udDogMTZweDtcXG4gICAgICAgICAgLS1zaXplLWZvbnQtYmlnOiAyMHB4O1xcbiAgICAgICAgICAtLXNpemUtZm9udC1iaWdnZXI6IDI0cHg7XFxuXFxuICAgICAgICAgIC0tY29sb3ItYWNjZW50cy0xOiAjODA4MDgwO1xcbiAgICAgICAgICAtLWNvbG9yLWFjY2VudHMtMjogIzIyMjIyMjtcXG4gICAgICAgICAgLS1jb2xvci1hY2NlbnRzLTM6ICM0MDQwNDA7XFxuXFxuICAgICAgICAgIC0tZm9udC1zdGFjay1tb25vc3BhY2U6ICdTRk1vbm8tUmVndWxhcicsIENvbnNvbGFzLCAnTGliZXJhdGlvbiBNb25vJyxcXG4gICAgICAgICAgICBNZW5sbywgQ291cmllciwgbW9ub3NwYWNlO1xcblxcbiAgICAgICAgICAtLWNvbG9yLWFuc2ktc2VsZWN0aW9uOiByZ2JhKDk1LCAxMjYsIDE1MSwgMC40OCk7XFxuICAgICAgICAgIC0tY29sb3ItYW5zaS1iZzogIzExMTExMTtcXG4gICAgICAgICAgLS1jb2xvci1hbnNpLWZnOiAjY2NjY2NjO1xcblxcbiAgICAgICAgICAtLWNvbG9yLWFuc2ktd2hpdGU6ICM3Nzc3Nzc7XFxuICAgICAgICAgIC0tY29sb3ItYW5zaS1ibGFjazogIzE0MTQxNDtcXG4gICAgICAgICAgLS1jb2xvci1hbnNpLWJsdWU6ICMwMGFhZmY7XFxuICAgICAgICAgIC0tY29sb3ItYW5zaS1jeWFuOiAjODhkZGZmO1xcbiAgICAgICAgICAtLWNvbG9yLWFuc2ktZ3JlZW46ICM5OGVjNjU7XFxuICAgICAgICAgIC0tY29sb3ItYW5zaS1tYWdlbnRhOiAjYWE4OGZmO1xcbiAgICAgICAgICAtLWNvbG9yLWFuc2ktcmVkOiAjZmY1NTU1O1xcbiAgICAgICAgICAtLWNvbG9yLWFuc2kteWVsbG93OiAjZmZjYzMzO1xcbiAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LXdoaXRlOiAjZmZmZmZmO1xcbiAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LWJsYWNrOiAjNzc3Nzc3O1xcbiAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LWJsdWU6ICMzM2JiZmY7XFxuICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtY3lhbjogI2JiZWNmZjtcXG4gICAgICAgICAgLS1jb2xvci1hbnNpLWJyaWdodC1ncmVlbjogI2I2ZjI5MjtcXG4gICAgICAgICAgLS1jb2xvci1hbnNpLWJyaWdodC1tYWdlbnRhOiAjY2ViYmZmO1xcbiAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LXJlZDogI2ZmODg4ODtcXG4gICAgICAgICAgLS1jb2xvci1hbnNpLWJyaWdodC15ZWxsb3c6ICNmZmQ5NjY7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAubW9ubyB7XFxuICAgICAgICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LXN0YWNrLW1vbm9zcGFjZSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBoMSxcXG4gICAgICAgIGgyLFxcbiAgICAgICAgaDMsXFxuICAgICAgICBoNCxcXG4gICAgICAgIGg1LFxcbiAgICAgICAgaDYge1xcbiAgICAgICAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcCk7XFxuICAgICAgICAgIGZvbnQtd2VpZ2h0OiA1MDA7XFxuICAgICAgICAgIGxpbmUtaGVpZ2h0OiAxLjU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBoMSB7XFxuICAgICAgICAgIGZvbnQtc2l6ZTogNDBweDtcXG4gICAgICAgIH1cXG4gICAgICAgIGgyIHtcXG4gICAgICAgICAgZm9udC1zaXplOiAzMnB4O1xcbiAgICAgICAgfVxcbiAgICAgICAgaDMge1xcbiAgICAgICAgICBmb250LXNpemU6IDI4cHg7XFxuICAgICAgICB9XFxuICAgICAgICBoNCB7XFxuICAgICAgICAgIGZvbnQtc2l6ZTogMjRweDtcXG4gICAgICAgIH1cXG4gICAgICAgIGg1IHtcXG4gICAgICAgICAgZm9udC1zaXplOiAyMHB4O1xcbiAgICAgICAgfVxcbiAgICAgICAgaDYge1xcbiAgICAgICAgICBmb250LXNpemU6IDE2cHg7XFxuICAgICAgICB9XFxuICAgICAgXCJdKSkpKX1uLkJhc2U9QmFzZTt2YXIgdX0sNDY0OmZ1bmN0aW9uKGUsbix0KXt2YXIgcj10aGlzJiZ0aGlzLl9fbWFrZVRlbXBsYXRlT2JqZWN0fHxmdW5jdGlvbihlLG4pe2lmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJyYXdcIix7dmFsdWU6bn0pfWVsc2V7ZS5yYXc9bn1yZXR1cm4gZX07dmFyIGE9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsbix0LHIpe2lmKHI9PT11bmRlZmluZWQpcj10O3ZhciBhPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobix0KTtpZighYXx8KFwiZ2V0XCJpbiBhPyFuLl9fZXNNb2R1bGU6YS53cml0YWJsZXx8YS5jb25maWd1cmFibGUpKXthPXtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG5bdF19fX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLGEpfTpmdW5jdGlvbihlLG4sdCxyKXtpZihyPT09dW5kZWZpbmVkKXI9dDtlW3JdPW5bdF19KTt2YXIgbz10aGlzJiZ0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdHx8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImRlZmF1bHRcIix7ZW51bWVyYWJsZTp0cnVlLHZhbHVlOm59KX06ZnVuY3Rpb24oZSxuKXtlW1wiZGVmYXVsdFwiXT1ufSk7dmFyIGk9dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgbj17fTtpZihlIT1udWxsKWZvcih2YXIgdCBpbiBlKWlmKHQhPT1cImRlZmF1bHRcIiYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCkpYShuLGUsdCk7byhuLGUpO3JldHVybiBufTtuLl9fZXNNb2R1bGU9dHJ1ZTtuLkNvbXBvbmVudFN0eWxlcz12b2lkIDA7dmFyIGw9aSh0KDUyMikpO3ZhciBzPXQoMzk5KTt2YXIgdT10KDY1MSk7dmFyIGM9dCg1NDMpO3ZhciBmPXQoOTkzKTt2YXIgZD10KDQ4OCk7dmFyIHY9dCgxMjApO3ZhciBwPXQoOTM2KTt2YXIgbT10KDM1NSk7dmFyIGI9dCg0ODQpO3ZhciBnPXQoOTEwKTtmdW5jdGlvbiBDb21wb25lbnRTdHlsZXMoKXtyZXR1cm4gbC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIixudWxsLCgwLGcubm9vcCkoaHx8KGg9cihbXCJcXG4gICAgICAgIFwiLFwiXFxuICAgICAgICBcIixcIlxcbiAgICAgICAgXCIsXCJcXG4gICAgICAgIFwiLFwiXFxuICAgICAgICBcIixcIlxcbiAgICAgICAgXCIsXCJcXG4gICAgICAgIFxcbiAgICAgICAgXCIsXCJcXG4gICAgICAgIFwiLFwiXFxuICAgICAgICBcIixcIlxcbiAgICAgIFwiXSxbXCJcXG4gICAgICAgIFwiLFwiXFxuICAgICAgICBcIixcIlxcbiAgICAgICAgXCIsXCJcXG4gICAgICAgIFwiLFwiXFxuICAgICAgICBcIixcIlxcbiAgICAgICAgXCIsXCJcXG4gICAgICAgIFxcbiAgICAgICAgXCIsXCJcXG4gICAgICAgIFwiLFwiXFxuICAgICAgICBcIixcIlxcbiAgICAgIFwiXSkpLGYuc3R5bGVzLHYuc3R5bGVzLHUuc3R5bGVzLGMuc3R5bGVzLHMuc3R5bGVzLGQuc3R5bGVzLHAuc3R5bGVzLG0uc3R5bGVzLGIuc3R5bGVzKSl9bi5Db21wb25lbnRTdHlsZXM9Q29tcG9uZW50U3R5bGVzO3ZhciBofSw0OTU6ZnVuY3Rpb24oZSxuLHQpe3ZhciByPXRoaXMmJnRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3R8fGZ1bmN0aW9uKGUsbil7aWYoT2JqZWN0LmRlZmluZVByb3BlcnR5KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcInJhd1wiLHt2YWx1ZTpufSl9ZWxzZXtlLnJhdz1ufXJldHVybiBlfTt2YXIgYT10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7dmFyIGE9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLHQpO2lmKCFhfHwoXCJnZXRcImluIGE/IW4uX19lc01vZHVsZTphLndyaXRhYmxlfHxhLmNvbmZpZ3VyYWJsZSkpe2E9e2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gblt0XX19fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIsYSl9OmZ1bmN0aW9uKGUsbix0LHIpe2lmKHI9PT11bmRlZmluZWQpcj10O2Vbcl09blt0XX0pO3ZhciBvPXRoaXMmJnRoaXMuX19zZXRNb2R1bGVEZWZhdWx0fHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOnRydWUsdmFsdWU6bn0pfTpmdW5jdGlvbihlLG4pe2VbXCJkZWZhdWx0XCJdPW59KTt2YXIgaT10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciBuPXt9O2lmKGUhPW51bGwpZm9yKHZhciB0IGluIGUpaWYodCE9PVwiZGVmYXVsdFwiJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KSlhKG4sZSx0KTtvKG4sZSk7cmV0dXJuIG59O24uX19lc01vZHVsZT10cnVlO24uQ3NzUmVzZXQ9dm9pZCAwO3ZhciBsPWkodCg1MjIpKTt2YXIgcz10KDkxMCk7ZnVuY3Rpb24gQ3NzUmVzZXQoKXtyZXR1cm4gbC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIixudWxsLCgwLHMubm9vcCkodXx8KHU9cihbXCJcXG4gICAgICAgIDpob3N0IHtcXG4gICAgICAgICAgYWxsOiBpbml0aWFsO1xcblxcbiAgICAgICAgICAvKiB0aGUgZGlyZWN0aW9uIHByb3BlcnR5IGlzIG5vdCByZXNldCBieSAnYWxsJyAqL1xcbiAgICAgICAgICBkaXJlY3Rpb246IGx0cjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8qIVxcbiAgICAgICAgICogQm9vdHN0cmFwIFJlYm9vdCB2NC40LjEgKGh0dHBzOi8vZ2V0Ym9vdHN0cmFwLmNvbS8pXFxuICAgICAgICAgKiBDb3B5cmlnaHQgMjAxMS0yMDE5IFRoZSBCb290c3RyYXAgQXV0aG9yc1xcbiAgICAgICAgICogQ29weXJpZ2h0IDIwMTEtMjAxOSBUd2l0dGVyLCBJbmMuXFxuICAgICAgICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxcbiAgICAgICAgICogRm9ya2VkIGZyb20gTm9ybWFsaXplLmNzcywgbGljZW5zZWQgTUlUIChodHRwczovL2dpdGh1Yi5jb20vbmVjb2xhcy9ub3JtYWxpemUuY3NzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQpXFxuICAgICAgICAgKi9cXG4gICAgICAgICosXFxuICAgICAgICAqOjpiZWZvcmUsXFxuICAgICAgICAqOjphZnRlciB7XFxuICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgICAgICB9XFxuXFxuICAgICAgICA6aG9zdCB7XFxuICAgICAgICAgIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xcbiAgICAgICAgICBsaW5lLWhlaWdodDogMS4xNTtcXG4gICAgICAgICAgLXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OiAxMDAlO1xcbiAgICAgICAgICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBhcnRpY2xlLFxcbiAgICAgICAgYXNpZGUsXFxuICAgICAgICBmaWdjYXB0aW9uLFxcbiAgICAgICAgZmlndXJlLFxcbiAgICAgICAgZm9vdGVyLFxcbiAgICAgICAgaGVhZGVyLFxcbiAgICAgICAgaGdyb3VwLFxcbiAgICAgICAgbWFpbixcXG4gICAgICAgIG5hdixcXG4gICAgICAgIHNlY3Rpb24ge1xcbiAgICAgICAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIDpob3N0IHtcXG4gICAgICAgICAgbWFyZ2luOiAwO1xcbiAgICAgICAgICBmb250LWZhbWlseTogLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCAnU2Vnb2UgVUknLCBSb2JvdG8sXFxuICAgICAgICAgICAgJ0hlbHZldGljYSBOZXVlJywgQXJpYWwsICdOb3RvIFNhbnMnLCBzYW5zLXNlcmlmLFxcbiAgICAgICAgICAgICdBcHBsZSBDb2xvciBFbW9qaScsICdTZWdvZSBVSSBFbW9qaScsICdTZWdvZSBVSSBTeW1ib2wnLFxcbiAgICAgICAgICAgICdOb3RvIENvbG9yIEVtb2ppJztcXG4gICAgICAgICAgZm9udC1zaXplOiAxNnB4O1xcbiAgICAgICAgICBmb250LXdlaWdodDogNDAwO1xcbiAgICAgICAgICBsaW5lLWhlaWdodDogMS41O1xcbiAgICAgICAgICBjb2xvcjogIzIxMjUyOTtcXG4gICAgICAgICAgdGV4dC1hbGlnbjogbGVmdDtcXG4gICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIFt0YWJpbmRleD0nLTEnXTpmb2N1czpub3QoOmZvY3VzLXZpc2libGUpIHtcXG4gICAgICAgICAgb3V0bGluZTogMCAhaW1wb3J0YW50O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaHIge1xcbiAgICAgICAgICBib3gtc2l6aW5nOiBjb250ZW50LWJveDtcXG4gICAgICAgICAgaGVpZ2h0OiAwO1xcbiAgICAgICAgICBvdmVyZmxvdzogdmlzaWJsZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGgxLFxcbiAgICAgICAgaDIsXFxuICAgICAgICBoMyxcXG4gICAgICAgIGg0LFxcbiAgICAgICAgaDUsXFxuICAgICAgICBoNiB7XFxuICAgICAgICAgIG1hcmdpbi10b3A6IDA7XFxuICAgICAgICAgIG1hcmdpbi1ib3R0b206IDhweDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHAge1xcbiAgICAgICAgICBtYXJnaW4tdG9wOiAwO1xcbiAgICAgICAgICBtYXJnaW4tYm90dG9tOiAxNnB4O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgYWJiclt0aXRsZV0sXFxuICAgICAgICBhYmJyW2RhdGEtb3JpZ2luYWwtdGl0bGVdIHtcXG4gICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxuICAgICAgICAgIC13ZWJraXQtdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xcbiAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XFxuICAgICAgICAgIGN1cnNvcjogaGVscDtcXG4gICAgICAgICAgYm9yZGVyLWJvdHRvbTogMDtcXG4gICAgICAgICAgLXdlYmtpdC10ZXh0LWRlY29yYXRpb24tc2tpcC1pbms6IG5vbmU7XFxuICAgICAgICAgIHRleHQtZGVjb3JhdGlvbi1za2lwLWluazogbm9uZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGFkZHJlc3Mge1xcbiAgICAgICAgICBtYXJnaW4tYm90dG9tOiAxNnB4O1xcbiAgICAgICAgICBmb250LXN0eWxlOiBub3JtYWw7XFxuICAgICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgb2wsXFxuICAgICAgICB1bCxcXG4gICAgICAgIGRsIHtcXG4gICAgICAgICAgbWFyZ2luLXRvcDogMDtcXG4gICAgICAgICAgbWFyZ2luLWJvdHRvbTogMTZweDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIG9sIG9sLFxcbiAgICAgICAgdWwgdWwsXFxuICAgICAgICBvbCB1bCxcXG4gICAgICAgIHVsIG9sIHtcXG4gICAgICAgICAgbWFyZ2luLWJvdHRvbTogMDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGR0IHtcXG4gICAgICAgICAgZm9udC13ZWlnaHQ6IDcwMDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGRkIHtcXG4gICAgICAgICAgbWFyZ2luLWJvdHRvbTogOHB4O1xcbiAgICAgICAgICBtYXJnaW4tbGVmdDogMDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGJsb2NrcXVvdGUge1xcbiAgICAgICAgICBtYXJnaW46IDAgMCAxNnB4O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgYixcXG4gICAgICAgIHN0cm9uZyB7XFxuICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkZXI7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzbWFsbCB7XFxuICAgICAgICAgIGZvbnQtc2l6ZTogODAlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc3ViLFxcbiAgICAgICAgc3VwIHtcXG4gICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICAgICAgICBmb250LXNpemU6IDc1JTtcXG4gICAgICAgICAgbGluZS1oZWlnaHQ6IDA7XFxuICAgICAgICAgIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHN1YiB7XFxuICAgICAgICAgIGJvdHRvbTogLTAuMjVlbTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHN1cCB7XFxuICAgICAgICAgIHRvcDogLTAuNWVtO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgYSB7XFxuICAgICAgICAgIGNvbG9yOiAjMDA3YmZmO1xcbiAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgYTpob3ZlciB7XFxuICAgICAgICAgIGNvbG9yOiAjMDA1NmIzO1xcbiAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGE6bm90KFtocmVmXSkge1xcbiAgICAgICAgICBjb2xvcjogaW5oZXJpdDtcXG4gICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgYTpub3QoW2hyZWZdKTpob3ZlciB7XFxuICAgICAgICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBwcmUsXFxuICAgICAgICBjb2RlLFxcbiAgICAgICAga2JkLFxcbiAgICAgICAgc2FtcCB7XFxuICAgICAgICAgIGZvbnQtZmFtaWx5OiBTRk1vbm8tUmVndWxhciwgTWVubG8sIE1vbmFjbywgQ29uc29sYXMsXFxuICAgICAgICAgICAgJ0xpYmVyYXRpb24gTW9ubycsICdDb3VyaWVyIE5ldycsIG1vbm9zcGFjZTtcXG4gICAgICAgICAgZm9udC1zaXplOiAxZW07XFxuICAgICAgICB9XFxuXFxuICAgICAgICBwcmUge1xcbiAgICAgICAgICBtYXJnaW4tdG9wOiAwO1xcbiAgICAgICAgICBtYXJnaW4tYm90dG9tOiAxNnB4O1xcbiAgICAgICAgICBvdmVyZmxvdzogYXV0bztcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZpZ3VyZSB7XFxuICAgICAgICAgIG1hcmdpbjogMCAwIDE2cHg7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpbWcge1xcbiAgICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICAgICAgICBib3JkZXItc3R5bGU6IG5vbmU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzdmcge1xcbiAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGFibGUge1xcbiAgICAgICAgICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgY2FwdGlvbiB7XFxuICAgICAgICAgIHBhZGRpbmctdG9wOiAxMnB4O1xcbiAgICAgICAgICBwYWRkaW5nLWJvdHRvbTogMTJweDtcXG4gICAgICAgICAgY29sb3I6ICM2Yzc1N2Q7XFxuICAgICAgICAgIHRleHQtYWxpZ246IGxlZnQ7XFxuICAgICAgICAgIGNhcHRpb24tc2lkZTogYm90dG9tO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGgge1xcbiAgICAgICAgICB0ZXh0LWFsaWduOiBpbmhlcml0O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgbGFiZWwge1xcbiAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgICAgICAgIG1hcmdpbi1ib3R0b206IDhweDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGJ1dHRvbiB7XFxuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDA7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBidXR0b246Zm9jdXMge1xcbiAgICAgICAgICBvdXRsaW5lOiAxcHggZG90dGVkO1xcbiAgICAgICAgICBvdXRsaW5lOiA1cHggYXV0byAtd2Via2l0LWZvY3VzLXJpbmctY29sb3I7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpbnB1dCxcXG4gICAgICAgIGJ1dHRvbixcXG4gICAgICAgIHNlbGVjdCxcXG4gICAgICAgIG9wdGdyb3VwLFxcbiAgICAgICAgdGV4dGFyZWEge1xcbiAgICAgICAgICBtYXJnaW46IDA7XFxuICAgICAgICAgIGZvbnQtZmFtaWx5OiBpbmhlcml0O1xcbiAgICAgICAgICBmb250LXNpemU6IGluaGVyaXQ7XFxuICAgICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgYnV0dG9uLFxcbiAgICAgICAgaW5wdXQge1xcbiAgICAgICAgICBvdmVyZmxvdzogdmlzaWJsZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGJ1dHRvbixcXG4gICAgICAgIHNlbGVjdCB7XFxuICAgICAgICAgIHRleHQtdHJhbnNmb3JtOiBub25lO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc2VsZWN0IHtcXG4gICAgICAgICAgd29yZC13cmFwOiBub3JtYWw7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBidXR0b24sXFxuICAgICAgICBbdHlwZT0nYnV0dG9uJ10sXFxuICAgICAgICBbdHlwZT0ncmVzZXQnXSxcXG4gICAgICAgIFt0eXBlPSdzdWJtaXQnXSB7XFxuICAgICAgICAgIC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgYnV0dG9uOm5vdCg6ZGlzYWJsZWQpLFxcbiAgICAgICAgW3R5cGU9J2J1dHRvbiddOm5vdCg6ZGlzYWJsZWQpLFxcbiAgICAgICAgW3R5cGU9J3Jlc2V0J106bm90KDpkaXNhYmxlZCksXFxuICAgICAgICBbdHlwZT0nc3VibWl0J106bm90KDpkaXNhYmxlZCkge1xcbiAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBidXR0b246Oi1tb3otZm9jdXMtaW5uZXIsXFxuICAgICAgICBbdHlwZT0nYnV0dG9uJ106Oi1tb3otZm9jdXMtaW5uZXIsXFxuICAgICAgICBbdHlwZT0ncmVzZXQnXTo6LW1vei1mb2N1cy1pbm5lcixcXG4gICAgICAgIFt0eXBlPSdzdWJtaXQnXTo6LW1vei1mb2N1cy1pbm5lciB7XFxuICAgICAgICAgIHBhZGRpbmc6IDA7XFxuICAgICAgICAgIGJvcmRlci1zdHlsZTogbm9uZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlucHV0W3R5cGU9J3JhZGlvJ10sXFxuICAgICAgICBpbnB1dFt0eXBlPSdjaGVja2JveCddIHtcXG4gICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgcGFkZGluZzogMDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlucHV0W3R5cGU9J2RhdGUnXSxcXG4gICAgICAgIGlucHV0W3R5cGU9J3RpbWUnXSxcXG4gICAgICAgIGlucHV0W3R5cGU9J2RhdGV0aW1lLWxvY2FsJ10sXFxuICAgICAgICBpbnB1dFt0eXBlPSdtb250aCddIHtcXG4gICAgICAgICAgLXdlYmtpdC1hcHBlYXJhbmNlOiBsaXN0Ym94O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGV4dGFyZWEge1xcbiAgICAgICAgICBvdmVyZmxvdzogYXV0bztcXG4gICAgICAgICAgcmVzaXplOiB2ZXJ0aWNhbDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZpZWxkc2V0IHtcXG4gICAgICAgICAgbWluLXdpZHRoOiAwO1xcbiAgICAgICAgICBwYWRkaW5nOiAwO1xcbiAgICAgICAgICBtYXJnaW46IDA7XFxuICAgICAgICAgIGJvcmRlcjogMDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGxlZ2VuZCB7XFxuICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICAgICAgICB3aWR0aDogMTAwJTtcXG4gICAgICAgICAgbWF4LXdpZHRoOiAxMDAlO1xcbiAgICAgICAgICBwYWRkaW5nOiAwO1xcbiAgICAgICAgICBtYXJnaW4tYm90dG9tOiA4cHg7XFxuICAgICAgICAgIGZvbnQtc2l6ZTogMjRweDtcXG4gICAgICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7XFxuICAgICAgICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgICAgICAgICB3aGl0ZS1zcGFjZTogbm9ybWFsO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcHJvZ3Jlc3Mge1xcbiAgICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBbdHlwZT0nbnVtYmVyJ106Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24sXFxuICAgICAgICBbdHlwZT0nbnVtYmVyJ106Oi13ZWJraXQtb3V0ZXItc3Bpbi1idXR0b24ge1xcbiAgICAgICAgICBoZWlnaHQ6IGF1dG87XFxuICAgICAgICB9XFxuXFxuICAgICAgICBbdHlwZT0nc2VhcmNoJ10ge1xcbiAgICAgICAgICBvdXRsaW5lLW9mZnNldDogLTJweDtcXG4gICAgICAgICAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgW3R5cGU9J3NlYXJjaCddOjotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uIHtcXG4gICAgICAgICAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgOjotd2Via2l0LWZpbGUtdXBsb2FkLWJ1dHRvbiB7XFxuICAgICAgICAgIGZvbnQ6IGluaGVyaXQ7XFxuICAgICAgICAgIC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgb3V0cHV0IHtcXG4gICAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc3VtbWFyeSB7XFxuICAgICAgICAgIGRpc3BsYXk6IGxpc3QtaXRlbTtcXG4gICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGVtcGxhdGUge1xcbiAgICAgICAgICBkaXNwbGF5OiBub25lO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgW2hpZGRlbl0ge1xcbiAgICAgICAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XFxuICAgICAgICB9XFxuICAgICAgXCJdLFtcIlxcbiAgICAgICAgOmhvc3Qge1xcbiAgICAgICAgICBhbGw6IGluaXRpYWw7XFxuXFxuICAgICAgICAgIC8qIHRoZSBkaXJlY3Rpb24gcHJvcGVydHkgaXMgbm90IHJlc2V0IGJ5ICdhbGwnICovXFxuICAgICAgICAgIGRpcmVjdGlvbjogbHRyO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLyohXFxuICAgICAgICAgKiBCb290c3RyYXAgUmVib290IHY0LjQuMSAoaHR0cHM6Ly9nZXRib290c3RyYXAuY29tLylcXG4gICAgICAgICAqIENvcHlyaWdodCAyMDExLTIwMTkgVGhlIEJvb3RzdHJhcCBBdXRob3JzXFxuICAgICAgICAgKiBDb3B5cmlnaHQgMjAxMS0yMDE5IFR3aXR0ZXIsIEluYy5cXG4gICAgICAgICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXFxuICAgICAgICAgKiBGb3JrZWQgZnJvbSBOb3JtYWxpemUuY3NzLCBsaWNlbnNlZCBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS9uZWNvbGFzL25vcm1hbGl6ZS5jc3MvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZClcXG4gICAgICAgICAqL1xcbiAgICAgICAgKixcXG4gICAgICAgICo6OmJlZm9yZSxcXG4gICAgICAgICo6OmFmdGVyIHtcXG4gICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIDpob3N0IHtcXG4gICAgICAgICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XFxuICAgICAgICAgIGxpbmUtaGVpZ2h0OiAxLjE1O1xcbiAgICAgICAgICAtd2Via2l0LXRleHQtc2l6ZS1hZGp1c3Q6IDEwMCU7XFxuICAgICAgICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGFydGljbGUsXFxuICAgICAgICBhc2lkZSxcXG4gICAgICAgIGZpZ2NhcHRpb24sXFxuICAgICAgICBmaWd1cmUsXFxuICAgICAgICBmb290ZXIsXFxuICAgICAgICBoZWFkZXIsXFxuICAgICAgICBoZ3JvdXAsXFxuICAgICAgICBtYWluLFxcbiAgICAgICAgbmF2LFxcbiAgICAgICAgc2VjdGlvbiB7XFxuICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgOmhvc3Qge1xcbiAgICAgICAgICBtYXJnaW46IDA7XFxuICAgICAgICAgIGZvbnQtZmFtaWx5OiAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsICdTZWdvZSBVSScsIFJvYm90byxcXG4gICAgICAgICAgICAnSGVsdmV0aWNhIE5ldWUnLCBBcmlhbCwgJ05vdG8gU2FucycsIHNhbnMtc2VyaWYsXFxuICAgICAgICAgICAgJ0FwcGxlIENvbG9yIEVtb2ppJywgJ1NlZ29lIFVJIEVtb2ppJywgJ1NlZ29lIFVJIFN5bWJvbCcsXFxuICAgICAgICAgICAgJ05vdG8gQ29sb3IgRW1vamknO1xcbiAgICAgICAgICBmb250LXNpemU6IDE2cHg7XFxuICAgICAgICAgIGZvbnQtd2VpZ2h0OiA0MDA7XFxuICAgICAgICAgIGxpbmUtaGVpZ2h0OiAxLjU7XFxuICAgICAgICAgIGNvbG9yOiAjMjEyNTI5O1xcbiAgICAgICAgICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgW3RhYmluZGV4PSctMSddOmZvY3VzOm5vdCg6Zm9jdXMtdmlzaWJsZSkge1xcbiAgICAgICAgICBvdXRsaW5lOiAwICFpbXBvcnRhbnQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBociB7XFxuICAgICAgICAgIGJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xcbiAgICAgICAgICBoZWlnaHQ6IDA7XFxuICAgICAgICAgIG92ZXJmbG93OiB2aXNpYmxlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaDEsXFxuICAgICAgICBoMixcXG4gICAgICAgIGgzLFxcbiAgICAgICAgaDQsXFxuICAgICAgICBoNSxcXG4gICAgICAgIGg2IHtcXG4gICAgICAgICAgbWFyZ2luLXRvcDogMDtcXG4gICAgICAgICAgbWFyZ2luLWJvdHRvbTogOHB4O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcCB7XFxuICAgICAgICAgIG1hcmdpbi10b3A6IDA7XFxuICAgICAgICAgIG1hcmdpbi1ib3R0b206IDE2cHg7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBhYmJyW3RpdGxlXSxcXG4gICAgICAgIGFiYnJbZGF0YS1vcmlnaW5hbC10aXRsZV0ge1xcbiAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG4gICAgICAgICAgLXdlYmtpdC10ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XFxuICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDtcXG4gICAgICAgICAgY3Vyc29yOiBoZWxwO1xcbiAgICAgICAgICBib3JkZXItYm90dG9tOiAwO1xcbiAgICAgICAgICAtd2Via2l0LXRleHQtZGVjb3JhdGlvbi1za2lwLWluazogbm9uZTtcXG4gICAgICAgICAgdGV4dC1kZWNvcmF0aW9uLXNraXAtaW5rOiBub25lO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgYWRkcmVzcyB7XFxuICAgICAgICAgIG1hcmdpbi1ib3R0b206IDE2cHg7XFxuICAgICAgICAgIGZvbnQtc3R5bGU6IG5vcm1hbDtcXG4gICAgICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBvbCxcXG4gICAgICAgIHVsLFxcbiAgICAgICAgZGwge1xcbiAgICAgICAgICBtYXJnaW4tdG9wOiAwO1xcbiAgICAgICAgICBtYXJnaW4tYm90dG9tOiAxNnB4O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgb2wgb2wsXFxuICAgICAgICB1bCB1bCxcXG4gICAgICAgIG9sIHVsLFxcbiAgICAgICAgdWwgb2wge1xcbiAgICAgICAgICBtYXJnaW4tYm90dG9tOiAwO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZHQge1xcbiAgICAgICAgICBmb250LXdlaWdodDogNzAwO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZGQge1xcbiAgICAgICAgICBtYXJnaW4tYm90dG9tOiA4cHg7XFxuICAgICAgICAgIG1hcmdpbi1sZWZ0OiAwO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgYmxvY2txdW90ZSB7XFxuICAgICAgICAgIG1hcmdpbjogMCAwIDE2cHg7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBiLFxcbiAgICAgICAgc3Ryb25nIHtcXG4gICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGRlcjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHNtYWxsIHtcXG4gICAgICAgICAgZm9udC1zaXplOiA4MCU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzdWIsXFxuICAgICAgICBzdXAge1xcbiAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgICAgICAgIGZvbnQtc2l6ZTogNzUlO1xcbiAgICAgICAgICBsaW5lLWhlaWdodDogMDtcXG4gICAgICAgICAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc3ViIHtcXG4gICAgICAgICAgYm90dG9tOiAtMC4yNWVtO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc3VwIHtcXG4gICAgICAgICAgdG9wOiAtMC41ZW07XFxuICAgICAgICB9XFxuXFxuICAgICAgICBhIHtcXG4gICAgICAgICAgY29sb3I6ICMwMDdiZmY7XFxuICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBhOmhvdmVyIHtcXG4gICAgICAgICAgY29sb3I6ICMwMDU2YjM7XFxuICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgYTpub3QoW2hyZWZdKSB7XFxuICAgICAgICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBhOm5vdChbaHJlZl0pOmhvdmVyIHtcXG4gICAgICAgICAgY29sb3I6IGluaGVyaXQ7XFxuICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHByZSxcXG4gICAgICAgIGNvZGUsXFxuICAgICAgICBrYmQsXFxuICAgICAgICBzYW1wIHtcXG4gICAgICAgICAgZm9udC1mYW1pbHk6IFNGTW9uby1SZWd1bGFyLCBNZW5sbywgTW9uYWNvLCBDb25zb2xhcyxcXG4gICAgICAgICAgICAnTGliZXJhdGlvbiBNb25vJywgJ0NvdXJpZXIgTmV3JywgbW9ub3NwYWNlO1xcbiAgICAgICAgICBmb250LXNpemU6IDFlbTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHByZSB7XFxuICAgICAgICAgIG1hcmdpbi10b3A6IDA7XFxuICAgICAgICAgIG1hcmdpbi1ib3R0b206IDE2cHg7XFxuICAgICAgICAgIG92ZXJmbG93OiBhdXRvO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZmlndXJlIHtcXG4gICAgICAgICAgbWFyZ2luOiAwIDAgMTZweDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGltZyB7XFxuICAgICAgICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICAgICAgICAgIGJvcmRlci1zdHlsZTogbm9uZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHN2ZyB7XFxuICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgICAgICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0YWJsZSB7XFxuICAgICAgICAgIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBjYXB0aW9uIHtcXG4gICAgICAgICAgcGFkZGluZy10b3A6IDEycHg7XFxuICAgICAgICAgIHBhZGRpbmctYm90dG9tOiAxMnB4O1xcbiAgICAgICAgICBjb2xvcjogIzZjNzU3ZDtcXG4gICAgICAgICAgdGV4dC1hbGlnbjogbGVmdDtcXG4gICAgICAgICAgY2FwdGlvbi1zaWRlOiBib3R0b207XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aCB7XFxuICAgICAgICAgIHRleHQtYWxpZ246IGluaGVyaXQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBsYWJlbCB7XFxuICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgICAgICAgbWFyZ2luLWJvdHRvbTogOHB4O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgYnV0dG9uIHtcXG4gICAgICAgICAgYm9yZGVyLXJhZGl1czogMDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGJ1dHRvbjpmb2N1cyB7XFxuICAgICAgICAgIG91dGxpbmU6IDFweCBkb3R0ZWQ7XFxuICAgICAgICAgIG91dGxpbmU6IDVweCBhdXRvIC13ZWJraXQtZm9jdXMtcmluZy1jb2xvcjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlucHV0LFxcbiAgICAgICAgYnV0dG9uLFxcbiAgICAgICAgc2VsZWN0LFxcbiAgICAgICAgb3B0Z3JvdXAsXFxuICAgICAgICB0ZXh0YXJlYSB7XFxuICAgICAgICAgIG1hcmdpbjogMDtcXG4gICAgICAgICAgZm9udC1mYW1pbHk6IGluaGVyaXQ7XFxuICAgICAgICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcXG4gICAgICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBidXR0b24sXFxuICAgICAgICBpbnB1dCB7XFxuICAgICAgICAgIG92ZXJmbG93OiB2aXNpYmxlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgYnV0dG9uLFxcbiAgICAgICAgc2VsZWN0IHtcXG4gICAgICAgICAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzZWxlY3Qge1xcbiAgICAgICAgICB3b3JkLXdyYXA6IG5vcm1hbDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGJ1dHRvbixcXG4gICAgICAgIFt0eXBlPSdidXR0b24nXSxcXG4gICAgICAgIFt0eXBlPSdyZXNldCddLFxcbiAgICAgICAgW3R5cGU9J3N1Ym1pdCddIHtcXG4gICAgICAgICAgLXdlYmtpdC1hcHBlYXJhbmNlOiBidXR0b247XFxuICAgICAgICB9XFxuXFxuICAgICAgICBidXR0b246bm90KDpkaXNhYmxlZCksXFxuICAgICAgICBbdHlwZT0nYnV0dG9uJ106bm90KDpkaXNhYmxlZCksXFxuICAgICAgICBbdHlwZT0ncmVzZXQnXTpub3QoOmRpc2FibGVkKSxcXG4gICAgICAgIFt0eXBlPSdzdWJtaXQnXTpub3QoOmRpc2FibGVkKSB7XFxuICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGJ1dHRvbjo6LW1vei1mb2N1cy1pbm5lcixcXG4gICAgICAgIFt0eXBlPSdidXR0b24nXTo6LW1vei1mb2N1cy1pbm5lcixcXG4gICAgICAgIFt0eXBlPSdyZXNldCddOjotbW96LWZvY3VzLWlubmVyLFxcbiAgICAgICAgW3R5cGU9J3N1Ym1pdCddOjotbW96LWZvY3VzLWlubmVyIHtcXG4gICAgICAgICAgcGFkZGluZzogMDtcXG4gICAgICAgICAgYm9yZGVyLXN0eWxlOiBub25lO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaW5wdXRbdHlwZT0ncmFkaW8nXSxcXG4gICAgICAgIGlucHV0W3R5cGU9J2NoZWNrYm94J10ge1xcbiAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICBwYWRkaW5nOiAwO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaW5wdXRbdHlwZT0nZGF0ZSddLFxcbiAgICAgICAgaW5wdXRbdHlwZT0ndGltZSddLFxcbiAgICAgICAgaW5wdXRbdHlwZT0nZGF0ZXRpbWUtbG9jYWwnXSxcXG4gICAgICAgIGlucHV0W3R5cGU9J21vbnRoJ10ge1xcbiAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IGxpc3Rib3g7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0ZXh0YXJlYSB7XFxuICAgICAgICAgIG92ZXJmbG93OiBhdXRvO1xcbiAgICAgICAgICByZXNpemU6IHZlcnRpY2FsO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZmllbGRzZXQge1xcbiAgICAgICAgICBtaW4td2lkdGg6IDA7XFxuICAgICAgICAgIHBhZGRpbmc6IDA7XFxuICAgICAgICAgIG1hcmdpbjogMDtcXG4gICAgICAgICAgYm9yZGVyOiAwO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgbGVnZW5kIHtcXG4gICAgICAgICAgZGlzcGxheTogYmxvY2s7XFxuICAgICAgICAgIHdpZHRoOiAxMDAlO1xcbiAgICAgICAgICBtYXgtd2lkdGg6IDEwMCU7XFxuICAgICAgICAgIHBhZGRpbmc6IDA7XFxuICAgICAgICAgIG1hcmdpbi1ib3R0b206IDhweDtcXG4gICAgICAgICAgZm9udC1zaXplOiAyNHB4O1xcbiAgICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDtcXG4gICAgICAgICAgY29sb3I6IGluaGVyaXQ7XFxuICAgICAgICAgIHdoaXRlLXNwYWNlOiBub3JtYWw7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBwcm9ncmVzcyB7XFxuICAgICAgICAgIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIFt0eXBlPSdudW1iZXInXTo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbixcXG4gICAgICAgIFt0eXBlPSdudW1iZXInXTo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbiB7XFxuICAgICAgICAgIGhlaWdodDogYXV0bztcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIFt0eXBlPSdzZWFyY2gnXSB7XFxuICAgICAgICAgIG91dGxpbmUtb2Zmc2V0OiAtMnB4O1xcbiAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBbdHlwZT0nc2VhcmNoJ106Oi13ZWJraXQtc2VhcmNoLWRlY29yYXRpb24ge1xcbiAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICA6Oi13ZWJraXQtZmlsZS11cGxvYWQtYnV0dG9uIHtcXG4gICAgICAgICAgZm9udDogaW5oZXJpdDtcXG4gICAgICAgICAgLXdlYmtpdC1hcHBlYXJhbmNlOiBidXR0b247XFxuICAgICAgICB9XFxuXFxuICAgICAgICBvdXRwdXQge1xcbiAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzdW1tYXJ5IHtcXG4gICAgICAgICAgZGlzcGxheTogbGlzdC1pdGVtO1xcbiAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0ZW1wbGF0ZSB7XFxuICAgICAgICAgIGRpc3BsYXk6IG5vbmU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBbaGlkZGVuXSB7XFxuICAgICAgICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcXG4gICAgICAgIH1cXG4gICAgICBcIl0pKSkpfW4uQ3NzUmVzZXQ9Q3NzUmVzZXQ7dmFyIHV9LDk5NzpmdW5jdGlvbihlKXtlLmV4cG9ydHM9cmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9hbnNlclwiKX0sMjkyOmZ1bmN0aW9uKGUpe2UuZXhwb3J0cz1yZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy5lc2NhcGVcIil9LDcwOTpmdW5jdGlvbihlKXtlLmV4cG9ydHM9cmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9wbGF0Zm9ybVwiKX0sOTc0OmZ1bmN0aW9uKGUpe2UuZXhwb3J0cz1yZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3N0YWNrdHJhY2UtcGFyc2VyXCIpfSw1MTg6ZnVuY3Rpb24oZSl7ZS5leHBvcnRzPXJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvc3RyaXAtYW5zaVwiKX0sNTIyOmZ1bmN0aW9uKGUpe2UuZXhwb3J0cz1yZXF1aXJlKFwicmVhY3RcIil9LDI1NTpmdW5jdGlvbihlKXtlLmV4cG9ydHM9cmVxdWlyZShcInJlYWN0LWRvbVwiKX19O3ZhciBuPXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18odCl7dmFyIHI9blt0XTtpZihyIT09dW5kZWZpbmVkKXtyZXR1cm4gci5leHBvcnRzfXZhciBhPW5bdF09e2V4cG9ydHM6e319O3ZhciBvPXRydWU7dHJ5e2VbdF0uY2FsbChhLmV4cG9ydHMsYSxhLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7bz1mYWxzZX1maW5hbGx5e2lmKG8pZGVsZXRlIG5bdF19cmV0dXJuIGEuZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHQ9X19uY2N3cGNrX3JlcXVpcmVfXygyMDQpO21vZHVsZS5leHBvcnRzPXR9KSgpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/@next/react-dev-overlay/dist/client.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/add-base-path.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/client/add-base-path.js ***!
  \********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.addBasePath = addBasePath;\nvar _addPathPrefix = __webpack_require__(/*! ../shared/lib/router/utils/add-path-prefix */ \"./node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js\");\nvar _normalizeTrailingSlash = __webpack_require__(/*! ./normalize-trailing-slash */ \"./node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst basePath =  false || \"\";\nfunction addBasePath(path, required) {\n    if (false) {}\n    return (0, _normalizeTrailingSlash).normalizePathTrailingSlash((0, _addPathPrefix).addPathPrefix(path, basePath));\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=add-base-path.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9hZGQtYmFzZS1wYXRoLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELG1CQUFtQixHQUFHRTtBQUN0QixJQUFJQyxpQkFBaUJDLG1CQUFPQSxDQUFDLHVIQUE0QztBQUN6RSxJQUFJQywwQkFBMEJELG1CQUFPQSxDQUFDLCtGQUE0QjtBQUNsRSxNQUFNRSxXQUFXQyxNQUFrQyxJQUFJO0FBQ3ZELFNBQVNMLFlBQVlRLElBQUksRUFBRUMsUUFBUSxFQUFFO0lBQ2pDLElBQUlKLEtBQTBDLEVBQUUsRUFJL0M7SUFDRCxPQUFPLENBQUMsR0FBR0YsdUJBQXVCLEVBQUVRLDBCQUEwQixDQUFDLENBQUMsR0FBR1YsY0FBYyxFQUFFVyxhQUFhLENBQUNKLE1BQU1KO0FBQzNHO0FBRUEsSUFBSSxDQUFDLE9BQU9OLFFBQVFlLE9BQU8sS0FBSyxjQUFlLE9BQU9mLFFBQVFlLE9BQU8sS0FBSyxZQUFZZixRQUFRZSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9mLFFBQVFlLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktsQixPQUFPQyxjQUFjLENBQUNDLFFBQVFlLE9BQU8sRUFBRSxjQUFjO1FBQUVkLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPbUIsTUFBTSxDQUFDakIsUUFBUWUsT0FBTyxFQUFFZjtJQUMvQmtCLE9BQU9sQixPQUFPLEdBQUdBLFFBQVFlLE9BQU87QUFDbEMsQ0FBQyxDQUVELHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9hZGQtYmFzZS1wYXRoLmpzPzYxMzEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmFkZEJhc2VQYXRoID0gYWRkQmFzZVBhdGg7XG52YXIgX2FkZFBhdGhQcmVmaXggPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvYWRkLXBhdGgtcHJlZml4XCIpO1xudmFyIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoID0gcmVxdWlyZShcIi4vbm9ybWFsaXplLXRyYWlsaW5nLXNsYXNoXCIpO1xuY29uc3QgYmFzZVBhdGggPSBwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIHx8ICcnO1xuZnVuY3Rpb24gYWRkQmFzZVBhdGgocGF0aCwgcmVxdWlyZWQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX01BTlVBTF9DTElFTlRfQkFTRV9QQVRIKSB7XG4gICAgICAgIGlmICghcmVxdWlyZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoMCwgX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2gpLm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKCgwLCBfYWRkUGF0aFByZWZpeCkuYWRkUGF0aFByZWZpeChwYXRoLCBiYXNlUGF0aCkpO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGQtYmFzZS1wYXRoLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImFkZEJhc2VQYXRoIiwiX2FkZFBhdGhQcmVmaXgiLCJyZXF1aXJlIiwiX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2giLCJiYXNlUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfUk9VVEVSX0JBU0VQQVRIIiwicGF0aCIsInJlcXVpcmVkIiwiX19ORVhUX01BTlVBTF9DTElFTlRfQkFTRV9QQVRIIiwibm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2giLCJhZGRQYXRoUHJlZml4IiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/add-base-path.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/add-locale.js":
/*!*****************************************************!*\
  !*** ./node_modules/next/dist/client/add-locale.js ***!
  \*****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.addLocale = void 0;\nvar _normalizeTrailingSlash = __webpack_require__(/*! ./normalize-trailing-slash */ \"./node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst addLocale = function(path) {\n    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        args[_key - 1] = arguments[_key];\n    }\n    if (false) {}\n    return path;\n};\nexports.addLocale = addLocale;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=add-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9hZGQtbG9jYWxlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGlCQUFpQixHQUFHLEtBQUs7QUFDekIsSUFBSUcsMEJBQTBCQyxtQkFBT0EsQ0FBQywrRkFBNEI7QUFDbEUsTUFBTUYsWUFBWSxTQUFDRyxNQUFnQjtxQ0FBUEM7UUFBQUE7O0lBQ3hCLElBQUlDLEtBQStCLEVBQUUsRUFFcEM7SUFDRCxPQUFPRjtBQUNYO0FBQ0FMLGlCQUFpQixHQUFHRTtBQUVwQixJQUFJLENBQUMsT0FBT0YsUUFBUVcsT0FBTyxLQUFLLGNBQWUsT0FBT1gsUUFBUVcsT0FBTyxLQUFLLFlBQVlYLFFBQVFXLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT1gsUUFBUVcsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS2QsT0FBT0MsY0FBYyxDQUFDQyxRQUFRVyxPQUFPLEVBQUUsY0FBYztRQUFFVixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT2UsTUFBTSxDQUFDYixRQUFRVyxPQUFPLEVBQUVYO0lBQy9CYyxPQUFPZCxPQUFPLEdBQUdBLFFBQVFXLE9BQU87QUFDbEMsQ0FBQyxDQUVELHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9hZGQtbG9jYWxlLmpzP2UyZDkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmFkZExvY2FsZSA9IHZvaWQgMDtcbnZhciBfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCA9IHJlcXVpcmUoXCIuL25vcm1hbGl6ZS10cmFpbGluZy1zbGFzaFwiKTtcbmNvbnN0IGFkZExvY2FsZSA9IChwYXRoLCAuLi5hcmdzKT0+e1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIHJldHVybiAoMCwgX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2gpLm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKHJlcXVpcmUoJy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2FkZC1sb2NhbGUnKS5hZGRMb2NhbGUocGF0aCwgLi4uYXJncykpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn07XG5leHBvcnRzLmFkZExvY2FsZSA9IGFkZExvY2FsZTtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkLWxvY2FsZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJhZGRMb2NhbGUiLCJfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCIsInJlcXVpcmUiLCJwYXRoIiwiYXJncyIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfSTE4Tl9TVVBQT1JUIiwibm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2giLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/add-locale.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/detect-domain-locale.js":
/*!***************************************************************!*\
  !*** ./node_modules/next/dist/client/detect-domain-locale.js ***!
  \***************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.detectDomainLocale = void 0;\nconst detectDomainLocale = function() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    if (false) {}\n};\nexports.detectDomainLocale = detectDomainLocale;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=detect-domain-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXRlY3QtZG9tYWluLWxvY2FsZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCwwQkFBMEIsR0FBRyxLQUFLO0FBQ2xDLE1BQU1FLHFCQUFxQixXQUFXO3FDQUFQQztRQUFBQTs7SUFDM0IsSUFBSUMsS0FBK0IsRUFBRSxFQUVwQztBQUNMO0FBQ0FKLDBCQUEwQixHQUFHRTtBQUU3QixJQUFJLENBQUMsT0FBT0YsUUFBUVEsT0FBTyxLQUFLLGNBQWUsT0FBT1IsUUFBUVEsT0FBTyxLQUFLLFlBQVlSLFFBQVFRLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT1IsUUFBUVEsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS1gsT0FBT0MsY0FBYyxDQUFDQyxRQUFRUSxPQUFPLEVBQUUsY0FBYztRQUFFUCxPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT1ksTUFBTSxDQUFDVixRQUFRUSxPQUFPLEVBQUVSO0lBQy9CVyxPQUFPWCxPQUFPLEdBQUdBLFFBQVFRLE9BQU87QUFDbEMsQ0FBQyxDQUVELGdEQUFnRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXRlY3QtZG9tYWluLWxvY2FsZS5qcz8wM2I1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZXRlY3REb21haW5Mb2NhbGUgPSB2b2lkIDA7XG5jb25zdCBkZXRlY3REb21haW5Mb2NhbGUgPSAoLi4uYXJncyk9PntcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICByZXR1cm4gcmVxdWlyZSgnLi4vc2hhcmVkL2xpYi9pMThuL2RldGVjdC1kb21haW4tbG9jYWxlJykuZGV0ZWN0RG9tYWluTG9jYWxlKC4uLmFyZ3MpO1xuICAgIH1cbn07XG5leHBvcnRzLmRldGVjdERvbWFpbkxvY2FsZSA9IGRldGVjdERvbWFpbkxvY2FsZTtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGV0ZWN0LWRvbWFpbi1sb2NhbGUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGV0ZWN0RG9tYWluTG9jYWxlIiwiYXJncyIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfSTE4Tl9TVVBQT1JUIiwicmVxdWlyZSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/detect-domain-locale.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/dev/dev-build-watcher.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/dev-build-watcher.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = initializeBuildWatcher;\nvar _websocket = __webpack_require__(/*! ./error-overlay/websocket */ \"./node_modules/next/dist/client/dev/error-overlay/websocket.js\");\nfunction initializeBuildWatcher(toggleCallback) {\n    let position = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"bottom-right\";\n    const shadowHost = document.createElement(\"div\");\n    const [verticalProperty, horizontalProperty] = position.split(\"-\");\n    shadowHost.id = \"__next-build-watcher\";\n    // Make sure container is fixed and on a high zIndex so it shows\n    shadowHost.style.position = \"fixed\";\n    // Ensure container's position to be top or bottom (default)\n    shadowHost.style[verticalProperty] = \"10px\";\n    // Ensure container's position to be left or right (default)\n    shadowHost.style[horizontalProperty] = \"20px\";\n    shadowHost.style.width = 0;\n    shadowHost.style.height = 0;\n    shadowHost.style.zIndex = 99999;\n    document.body.appendChild(shadowHost);\n    let shadowRoot;\n    let prefix = \"\";\n    if (shadowHost.attachShadow) {\n        shadowRoot = shadowHost.attachShadow({\n            mode: \"open\"\n        });\n    } else {\n        // If attachShadow is undefined then the browser does not support\n        // the Shadow DOM, we need to prefix all the names so there\n        // will be no conflicts\n        shadowRoot = shadowHost;\n        prefix = \"__next-build-watcher-\";\n    }\n    // Container\n    const container = createContainer(prefix);\n    shadowRoot.appendChild(container);\n    // CSS\n    const css = createCss(prefix, {\n        horizontalProperty,\n        verticalProperty\n    });\n    shadowRoot.appendChild(css);\n    // State\n    let isVisible = false;\n    let isBuilding = false;\n    let timeoutId = null;\n    // Handle events\n    (0, _websocket).addMessageListener((event)=>{\n        // This is the heartbeat event\n        if (event.data === \"\\uD83D\\uDC93\") {\n            return;\n        }\n        try {\n            handleMessage(event);\n        } catch (e) {}\n    });\n    function handleMessage(event) {\n        const obj = typeof event === \"string\" ? {\n            action: event\n        } : JSON.parse(event.data);\n        // eslint-disable-next-line default-case\n        switch(obj.action){\n            case \"building\":\n                timeoutId && clearTimeout(timeoutId);\n                isVisible = true;\n                isBuilding = true;\n                updateContainer();\n                break;\n            case \"built\":\n            case \"sync\":\n                isBuilding = false;\n                // Wait for the fade out transition to complete\n                timeoutId = setTimeout(()=>{\n                    isVisible = false;\n                    updateContainer();\n                }, 100);\n                updateContainer();\n                break;\n        }\n    }\n    toggleCallback(handleMessage);\n    function updateContainer() {\n        if (isBuilding) {\n            container.classList.add(\"\".concat(prefix, \"building\"));\n        } else {\n            container.classList.remove(\"\".concat(prefix, \"building\"));\n        }\n        if (isVisible) {\n            container.classList.add(\"\".concat(prefix, \"visible\"));\n        } else {\n            container.classList.remove(\"\".concat(prefix, \"visible\"));\n        }\n    }\n}\nfunction createContainer(prefix) {\n    const container = document.createElement(\"div\");\n    container.id = \"\".concat(prefix, \"container\");\n    container.innerHTML = '\\n    <div id=\"'.concat(prefix, 'icon-wrapper\">\\n      <svg viewBox=\"0 0 226 200\">\\n        <defs>\\n          <linearGradient\\n            x1=\"114.720775%\"\\n            y1=\"181.283245%\"\\n            x2=\"39.5399306%\"\\n            y2=\"100%\"\\n            id=\"').concat(prefix, 'linear-gradient\"\\n          >\\n            <stop stop-color=\"#000000\" offset=\"0%\" />\\n            <stop stop-color=\"#FFFFFF\" offset=\"100%\" />\\n          </linearGradient>\\n        </defs>\\n        <g id=\"').concat(prefix, 'icon-group\" fill=\"none\" stroke=\"url(#').concat(prefix, 'linear-gradient)\" stroke-width=\"18\">\\n          <path d=\"M113,5.08219117 L4.28393801,197.5 L221.716062,197.5 L113,5.08219117 Z\" />\\n        </g>\\n      </svg>\\n    </div>\\n  ');\n    return container;\n}\nfunction createCss(prefix, param) {\n    let { horizontalProperty , verticalProperty  } = param;\n    const css = document.createElement(\"style\");\n    css.textContent = \"\\n    #\".concat(prefix, \"container {\\n      position: absolute;\\n      \").concat(verticalProperty, \": 10px;\\n      \").concat(horizontalProperty, \": 30px;\\n\\n      border-radius: 3px;\\n      background: #000;\\n      color: #fff;\\n      font: initial;\\n      cursor: initial;\\n      letter-spacing: initial;\\n      text-shadow: initial;\\n      text-transform: initial;\\n      visibility: initial;\\n\\n      padding: 7px 10px 8px 10px;\\n      align-items: center;\\n      box-shadow: 0 11px 40px 0 rgba(0, 0, 0, 0.25), 0 2px 10px 0 rgba(0, 0, 0, 0.12);\\n\\n      display: none;\\n      opacity: 0;\\n      transition: opacity 0.1s ease, \").concat(verticalProperty, \" 0.1s ease;\\n      animation: \").concat(prefix, \"fade-in 0.1s ease-in-out;\\n    }\\n\\n    #\").concat(prefix, \"container.\").concat(prefix, \"visible {\\n      display: flex;\\n    }\\n\\n    #\").concat(prefix, \"container.\").concat(prefix, \"building {\\n      \").concat(verticalProperty, \": 20px;\\n      opacity: 1;\\n    }\\n\\n    #\").concat(prefix, \"icon-wrapper {\\n      width: 16px;\\n      height: 16px;\\n    }\\n\\n    #\").concat(prefix, \"icon-wrapper > svg {\\n      width: 100%;\\n      height: 100%;\\n    }\\n\\n    #\").concat(prefix, \"icon-group {\\n      animation: \").concat(prefix, \"strokedash 1s ease-in-out both infinite;\\n    }\\n\\n    @keyframes \").concat(prefix, \"fade-in {\\n      from {\\n        \").concat(verticalProperty, \": 10px;\\n        opacity: 0;\\n      }\\n      to {\\n        \").concat(verticalProperty, \": 20px;\\n        opacity: 1;\\n      }\\n    }\\n\\n    @keyframes \").concat(prefix, \"strokedash {\\n      0% {\\n        stroke-dasharray: 0 226;\\n      }\\n      80%,\\n      100% {\\n        stroke-dasharray: 659 226;\\n      }\\n    }\\n  \");\n    return css;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=dev-build-watcher.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvZGV2LWJ1aWxkLXdhdGNoZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsa0JBQWUsR0FBR0c7QUFDbEIsSUFBSUMsYUFBYUMsbUJBQU9BLENBQUMsaUdBQTJCO0FBQ3BELFNBQVNGLHVCQUF1QkcsY0FBYyxFQUE2QjtRQUEzQkMsV0FBQUEsaUVBQVcsY0FBYztJQUNyRSxNQUFNQyxhQUFhQyxTQUFTQyxhQUFhLENBQUM7SUFDMUMsTUFBTSxDQUFDQyxrQkFBa0JDLG1CQUFtQixHQUFHTCxTQUFTTSxLQUFLLENBQUM7SUFDOURMLFdBQVdNLEVBQUUsR0FBRztJQUNoQixnRUFBZ0U7SUFDaEVOLFdBQVdPLEtBQUssQ0FBQ1IsUUFBUSxHQUFHO0lBQzVCLDREQUE0RDtJQUM1REMsV0FBV08sS0FBSyxDQUFDSixpQkFBaUIsR0FBRztJQUNyQyw0REFBNEQ7SUFDNURILFdBQVdPLEtBQUssQ0FBQ0gsbUJBQW1CLEdBQUc7SUFDdkNKLFdBQVdPLEtBQUssQ0FBQ0MsS0FBSyxHQUFHO0lBQ3pCUixXQUFXTyxLQUFLLENBQUNFLE1BQU0sR0FBRztJQUMxQlQsV0FBV08sS0FBSyxDQUFDRyxNQUFNLEdBQUc7SUFDMUJULFNBQVNVLElBQUksQ0FBQ0MsV0FBVyxDQUFDWjtJQUMxQixJQUFJYTtJQUNKLElBQUlDLFNBQVM7SUFDYixJQUFJZCxXQUFXZSxZQUFZLEVBQUU7UUFDekJGLGFBQWFiLFdBQVdlLFlBQVksQ0FBQztZQUNqQ0MsTUFBTTtRQUNWO0lBQ0osT0FBTztRQUNILGlFQUFpRTtRQUNqRSwyREFBMkQ7UUFDM0QsdUJBQXVCO1FBQ3ZCSCxhQUFhYjtRQUNiYyxTQUFTO0lBQ2IsQ0FBQztJQUNELFlBQVk7SUFDWixNQUFNRyxZQUFZQyxnQkFBZ0JKO0lBQ2xDRCxXQUFXRCxXQUFXLENBQUNLO0lBQ3ZCLE1BQU07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UUUsT0FBTyxLQUFLLFlBQVlGLFFBQVFFLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT0YsUUFBUUUsT0FBTyxDQUFDK0MsVUFBVSxLQUFLLGFBQWE7SUFDcktuRCxPQUFPQyxjQUFjLENBQUNDLFFBQVFFLE9BQU8sRUFBRSxjQUFjO1FBQUVELE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPb0QsTUFBTSxDQUFDbEQsUUFBUUUsT0FBTyxFQUFFRjtJQUMvQm1ELE9BQU9uRCxPQUFPLEdBQUdBLFFBQVFFLE9BQU87QUFDbEMsQ0FBQyxDQUVELDZDQUE2QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvZGV2LWJ1aWxkLXdhdGNoZXIuanM/N2IzNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGluaXRpYWxpemVCdWlsZFdhdGNoZXI7XG52YXIgX3dlYnNvY2tldCA9IHJlcXVpcmUoXCIuL2Vycm9yLW92ZXJsYXkvd2Vic29ja2V0XCIpO1xuZnVuY3Rpb24gaW5pdGlhbGl6ZUJ1aWxkV2F0Y2hlcih0b2dnbGVDYWxsYmFjaywgcG9zaXRpb24gPSAnYm90dG9tLXJpZ2h0Jykge1xuICAgIGNvbnN0IHNoYWRvd0hvc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb25zdCBbdmVydGljYWxQcm9wZXJ0eSwgaG9yaXpvbnRhbFByb3BlcnR5XSA9IHBvc2l0aW9uLnNwbGl0KCctJyk7XG4gICAgc2hhZG93SG9zdC5pZCA9ICdfX25leHQtYnVpbGQtd2F0Y2hlcic7XG4gICAgLy8gTWFrZSBzdXJlIGNvbnRhaW5lciBpcyBmaXhlZCBhbmQgb24gYSBoaWdoIHpJbmRleCBzbyBpdCBzaG93c1xuICAgIHNoYWRvd0hvc3Quc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgIC8vIEVuc3VyZSBjb250YWluZXIncyBwb3NpdGlvbiB0byBiZSB0b3Agb3IgYm90dG9tIChkZWZhdWx0KVxuICAgIHNoYWRvd0hvc3Quc3R5bGVbdmVydGljYWxQcm9wZXJ0eV0gPSAnMTBweCc7XG4gICAgLy8gRW5zdXJlIGNvbnRhaW5lcidzIHBvc2l0aW9uIHRvIGJlIGxlZnQgb3IgcmlnaHQgKGRlZmF1bHQpXG4gICAgc2hhZG93SG9zdC5zdHlsZVtob3Jpem9udGFsUHJvcGVydHldID0gJzIwcHgnO1xuICAgIHNoYWRvd0hvc3Quc3R5bGUud2lkdGggPSAwO1xuICAgIHNoYWRvd0hvc3Quc3R5bGUuaGVpZ2h0ID0gMDtcbiAgICBzaGFkb3dIb3N0LnN0eWxlLnpJbmRleCA9IDk5OTk5O1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2hhZG93SG9zdCk7XG4gICAgbGV0IHNoYWRvd1Jvb3Q7XG4gICAgbGV0IHByZWZpeCA9ICcnO1xuICAgIGlmIChzaGFkb3dIb3N0LmF0dGFjaFNoYWRvdykge1xuICAgICAgICBzaGFkb3dSb290ID0gc2hhZG93SG9zdC5hdHRhY2hTaGFkb3coe1xuICAgICAgICAgICAgbW9kZTogJ29wZW4nXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIGF0dGFjaFNoYWRvdyBpcyB1bmRlZmluZWQgdGhlbiB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0XG4gICAgICAgIC8vIHRoZSBTaGFkb3cgRE9NLCB3ZSBuZWVkIHRvIHByZWZpeCBhbGwgdGhlIG5hbWVzIHNvIHRoZXJlXG4gICAgICAgIC8vIHdpbGwgYmUgbm8gY29uZmxpY3RzXG4gICAgICAgIHNoYWRvd1Jvb3QgPSBzaGFkb3dIb3N0O1xuICAgICAgICBwcmVmaXggPSAnX19uZXh0LWJ1aWxkLXdhdGNoZXItJztcbiAgICB9XG4gICAgLy8gQ29udGFpbmVyXG4gICAgY29uc3QgY29udGFpbmVyID0gY3JlYXRlQ29udGFpbmVyKHByZWZpeCk7XG4gICAgc2hhZG93Um9vdC5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgIC8vIENTU1xuICAgIGNvbnN0IGNzcyA9IGNyZWF0ZUNzcyhwcmVmaXgsIHtcbiAgICAgICAgaG9yaXpvbnRhbFByb3BlcnR5LFxuICAgICAgICB2ZXJ0aWNhbFByb3BlcnR5XG4gICAgfSk7XG4gICAgc2hhZG93Um9vdC5hcHBlbmRDaGlsZChjc3MpO1xuICAgIC8vIFN0YXRlXG4gICAgbGV0IGlzVmlzaWJsZSA9IGZhbHNlO1xuICAgIGxldCBpc0J1aWxkaW5nID0gZmFsc2U7XG4gICAgbGV0IHRpbWVvdXRJZCA9IG51bGw7XG4gICAgLy8gSGFuZGxlIGV2ZW50c1xuICAgICgwLCBfd2Vic29ja2V0KS5hZGRNZXNzYWdlTGlzdGVuZXIoKGV2ZW50KT0+e1xuICAgICAgICAvLyBUaGlzIGlzIHRoZSBoZWFydGJlYXQgZXZlbnRcbiAgICAgICAgaWYgKGV2ZW50LmRhdGEgPT09ICdcXHVEODNEXFx1REM5MycpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaGFuZGxlTWVzc2FnZShldmVudCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShldmVudCkge1xuICAgICAgICBjb25zdCBvYmogPSB0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnID8ge1xuICAgICAgICAgICAgYWN0aW9uOiBldmVudFxuICAgICAgICB9IDogSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlZmF1bHQtY2FzZVxuICAgICAgICBzd2l0Y2gob2JqLmFjdGlvbil7XG4gICAgICAgICAgICBjYXNlICdidWlsZGluZyc6XG4gICAgICAgICAgICAgICAgdGltZW91dElkICYmIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAgICAgICAgIGlzVmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaXNCdWlsZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdXBkYXRlQ29udGFpbmVyKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdidWlsdCc6XG4gICAgICAgICAgICBjYXNlICdzeW5jJzpcbiAgICAgICAgICAgICAgICBpc0J1aWxkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gV2FpdCBmb3IgdGhlIGZhZGUgb3V0IHRyYW5zaXRpb24gdG8gY29tcGxldGVcbiAgICAgICAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgICAgIGlzVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVDb250YWluZXIoKTtcbiAgICAgICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUNvbnRhaW5lcigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvZ2dsZUNhbGxiYWNrKGhhbmRsZU1lc3NhZ2UpO1xuICAgIGZ1bmN0aW9uIHVwZGF0ZUNvbnRhaW5lcigpIHtcbiAgICAgICAgaWYgKGlzQnVpbGRpbmcpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKGAke3ByZWZpeH1idWlsZGluZ2ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoYCR7cHJlZml4fWJ1aWxkaW5nYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVmlzaWJsZSkge1xuICAgICAgICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoYCR7cHJlZml4fXZpc2libGVgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKGAke3ByZWZpeH12aXNpYmxlYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVDb250YWluZXIocHJlZml4KSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmlkID0gYCR7cHJlZml4fWNvbnRhaW5lcmA7XG4gICAgY29udGFpbmVyLmlubmVySFRNTCA9IGBcbiAgICA8ZGl2IGlkPVwiJHtwcmVmaXh9aWNvbi13cmFwcGVyXCI+XG4gICAgICA8c3ZnIHZpZXdCb3g9XCIwIDAgMjI2IDIwMFwiPlxuICAgICAgICA8ZGVmcz5cbiAgICAgICAgICA8bGluZWFyR3JhZGllbnRcbiAgICAgICAgICAgIHgxPVwiMTE0LjcyMDc3NSVcIlxuICAgICAgICAgICAgeTE9XCIxODEuMjgzMjQ1JVwiXG4gICAgICAgICAgICB4Mj1cIjM5LjUzOTkzMDYlXCJcbiAgICAgICAgICAgIHkyPVwiMTAwJVwiXG4gICAgICAgICAgICBpZD1cIiR7cHJlZml4fWxpbmVhci1ncmFkaWVudFwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgPHN0b3Agc3RvcC1jb2xvcj1cIiMwMDAwMDBcIiBvZmZzZXQ9XCIwJVwiIC8+XG4gICAgICAgICAgICA8c3RvcCBzdG9wLWNvbG9yPVwiI0ZGRkZGRlwiIG9mZnNldD1cIjEwMCVcIiAvPlxuICAgICAgICAgIDwvbGluZWFyR3JhZGllbnQ+XG4gICAgICAgIDwvZGVmcz5cbiAgICAgICAgPGcgaWQ9XCIke3ByZWZpeH1pY29uLWdyb3VwXCIgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJ1cmwoIyR7cHJlZml4fWxpbmVhci1ncmFkaWVudClcIiBzdHJva2Utd2lkdGg9XCIxOFwiPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMTEzLDUuMDgyMTkxMTcgTDQuMjgzOTM4MDEsMTk3LjUgTDIyMS43MTYwNjIsMTk3LjUgTDExMyw1LjA4MjE5MTE3IFpcIiAvPlxuICAgICAgICA8L2c+XG4gICAgICA8L3N2Zz5cbiAgICA8L2Rpdj5cbiAgYDtcbiAgICByZXR1cm4gY29udGFpbmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlQ3NzKHByZWZpeCwgeyBob3Jpem9udGFsUHJvcGVydHkgLCB2ZXJ0aWNhbFByb3BlcnR5ICB9KSB7XG4gICAgY29uc3QgY3NzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBjc3MudGV4dENvbnRlbnQgPSBgXG4gICAgIyR7cHJlZml4fWNvbnRhaW5lciB7XG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAke3ZlcnRpY2FsUHJvcGVydHl9OiAxMHB4O1xuICAgICAgJHtob3Jpem9udGFsUHJvcGVydHl9OiAzMHB4O1xuXG4gICAgICBib3JkZXItcmFkaXVzOiAzcHg7XG4gICAgICBiYWNrZ3JvdW5kOiAjMDAwO1xuICAgICAgY29sb3I6ICNmZmY7XG4gICAgICBmb250OiBpbml0aWFsO1xuICAgICAgY3Vyc29yOiBpbml0aWFsO1xuICAgICAgbGV0dGVyLXNwYWNpbmc6IGluaXRpYWw7XG4gICAgICB0ZXh0LXNoYWRvdzogaW5pdGlhbDtcbiAgICAgIHRleHQtdHJhbnNmb3JtOiBpbml0aWFsO1xuICAgICAgdmlzaWJpbGl0eTogaW5pdGlhbDtcblxuICAgICAgcGFkZGluZzogN3B4IDEwcHggOHB4IDEwcHg7XG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgYm94LXNoYWRvdzogMCAxMXB4IDQwcHggMCByZ2JhKDAsIDAsIDAsIDAuMjUpLCAwIDJweCAxMHB4IDAgcmdiYSgwLCAwLCAwLCAwLjEyKTtcblxuICAgICAgZGlzcGxheTogbm9uZTtcbiAgICAgIG9wYWNpdHk6IDA7XG4gICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMXMgZWFzZSwgJHt2ZXJ0aWNhbFByb3BlcnR5fSAwLjFzIGVhc2U7XG4gICAgICBhbmltYXRpb246ICR7cHJlZml4fWZhZGUtaW4gMC4xcyBlYXNlLWluLW91dDtcbiAgICB9XG5cbiAgICAjJHtwcmVmaXh9Y29udGFpbmVyLiR7cHJlZml4fXZpc2libGUge1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICB9XG5cbiAgICAjJHtwcmVmaXh9Y29udGFpbmVyLiR7cHJlZml4fWJ1aWxkaW5nIHtcbiAgICAgICR7dmVydGljYWxQcm9wZXJ0eX06IDIwcHg7XG4gICAgICBvcGFjaXR5OiAxO1xuICAgIH1cblxuICAgICMke3ByZWZpeH1pY29uLXdyYXBwZXIge1xuICAgICAgd2lkdGg6IDE2cHg7XG4gICAgICBoZWlnaHQ6IDE2cHg7XG4gICAgfVxuXG4gICAgIyR7cHJlZml4fWljb24td3JhcHBlciA+IHN2ZyB7XG4gICAgICB3aWR0aDogMTAwJTtcbiAgICAgIGhlaWdodDogMTAwJTtcbiAgICB9XG5cbiAgICAjJHtwcmVmaXh9aWNvbi1ncm91cCB7XG4gICAgICBhbmltYXRpb246ICR7cHJlZml4fXN0cm9rZWRhc2ggMXMgZWFzZS1pbi1vdXQgYm90aCBpbmZpbml0ZTtcbiAgICB9XG5cbiAgICBAa2V5ZnJhbWVzICR7cHJlZml4fWZhZGUtaW4ge1xuICAgICAgZnJvbSB7XG4gICAgICAgICR7dmVydGljYWxQcm9wZXJ0eX06IDEwcHg7XG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgICB9XG4gICAgICB0byB7XG4gICAgICAgICR7dmVydGljYWxQcm9wZXJ0eX06IDIwcHg7XG4gICAgICAgIG9wYWNpdHk6IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgQGtleWZyYW1lcyAke3ByZWZpeH1zdHJva2VkYXNoIHtcbiAgICAgIDAlIHtcbiAgICAgICAgc3Ryb2tlLWRhc2hhcnJheTogMCAyMjY7XG4gICAgICB9XG4gICAgICA4MCUsXG4gICAgICAxMDAlIHtcbiAgICAgICAgc3Ryb2tlLWRhc2hhcnJheTogNjU5IDIyNjtcbiAgICAgIH1cbiAgICB9XG4gIGA7XG4gICAgcmV0dXJuIGNzcztcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGV2LWJ1aWxkLXdhdGNoZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdCIsImluaXRpYWxpemVCdWlsZFdhdGNoZXIiLCJfd2Vic29ja2V0IiwicmVxdWlyZSIsInRvZ2dsZUNhbGxiYWNrIiwicG9zaXRpb24iLCJzaGFkb3dIb3N0IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwidmVydGljYWxQcm9wZXJ0eSIsImhvcml6b250YWxQcm9wZXJ0eSIsInNwbGl0IiwiaWQiLCJzdHlsZSIsIndpZHRoIiwiaGVpZ2h0IiwiekluZGV4IiwiYm9keSIsImFwcGVuZENoaWxkIiwic2hhZG93Um9vdCIsInByZWZpeCIsImF0dGFjaFNoYWRvdyIsIm1vZGUiLCJjb250YWluZXIiLCJjcmVhdGVDb250YWluZXIiLCJjc3MiLCJjcmVhdGVDc3MiLCJpc1Zpc2libGUiLCJpc0J1aWxkaW5nIiwidGltZW91dElkIiwiYWRkTWVzc2FnZUxpc3RlbmVyIiwiZXZlbnQiLCJkYXRhIiwiaGFuZGxlTWVzc2FnZSIsImUiLCJvYmoiLCJhY3Rpb24iLCJKU09OIiwicGFyc2UiLCJjbGVhclRpbWVvdXQiLCJ1cGRhdGVDb250YWluZXIiLCJzZXRUaW1lb3V0IiwiY2xhc3NMaXN0IiwiYWRkIiwicmVtb3ZlIiwiaW5uZXJIVE1MIiwidGV4dENvbnRlbnQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/dev/dev-build-watcher.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/dev/error-overlay/format-webpack-messages.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/error-overlay/format-webpack-messages.js ***!
  \************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _stripAnsi = _interop_require_default(__webpack_require__(/*! next/dist/compiled/strip-ansi */ \"./node_modules/next/dist/compiled/strip-ansi/index.js\"));\n// This file is based on https://github.com/facebook/create-react-app/blob/7b1a32be6ec9f99a6c9a3c66813f3ac09c4736b9/packages/react-dev-utils/formatWebpackMessages.js\n// It's been edited to remove chalk and CRA-specific logic\nconst friendlySyntaxErrorLabel = \"Syntax error:\";\nconst WEBPACK_BREAKING_CHANGE_POLYFILLS = \"\\n\\nBREAKING CHANGE: webpack < 5 used to include polyfills for node.js core modules by default.\";\nfunction isLikelyASyntaxError(message) {\n    return (0, _stripAnsi).default(message).indexOf(friendlySyntaxErrorLabel) !== -1;\n}\nlet hadMissingSassError = false;\n// Cleans up webpack error messages.\nfunction formatMessage(message, verbose, importTraceNote) {\n    // TODO: Replace this once webpack 5 is stable\n    if (typeof message === \"object\" && message.message) {\n        const filteredModuleTrace = message.moduleTrace && message.moduleTrace.filter((trace)=>!/next-(middleware|client-pages|edge-function)-loader\\.js/.test(trace.originName));\n        let body = message.message;\n        const breakingChangeIndex = body.indexOf(WEBPACK_BREAKING_CHANGE_POLYFILLS);\n        if (breakingChangeIndex >= 0) {\n            body = body.slice(0, breakingChangeIndex);\n        }\n        message = (message.moduleName ? (0, _stripAnsi).default(message.moduleName) + \"\\n\" : \"\") + (message.file ? (0, _stripAnsi).default(message.file) + \"\\n\" : \"\") + body + (message.details && verbose ? \"\\n\" + message.details : \"\") + (filteredModuleTrace && filteredModuleTrace.length && verbose ? (importTraceNote || \"\\n\\nImport trace for requested module:\") + filteredModuleTrace.map((trace)=>\"\\n\".concat(trace.moduleName)).join(\"\") : \"\") + (message.stack && verbose ? \"\\n\" + message.stack : \"\");\n    }\n    let lines = message.split(\"\\n\");\n    // Strip Webpack-added headers off errors/warnings\n    // https://github.com/webpack/webpack/blob/master/lib/ModuleError.js\n    lines = lines.filter((line)=>!/Module [A-z ]+\\(from/.test(line));\n    // Transform parsing error into syntax error\n    // TODO: move this to our ESLint formatter?\n    lines = lines.map((line)=>{\n        const parsingError = /Line (\\d+):(?:(\\d+):)?\\s*Parsing error: (.+)$/.exec(line);\n        if (!parsingError) {\n            return line;\n        }\n        const [, errorLine, errorColumn, errorMessage] = parsingError;\n        return \"\".concat(friendlySyntaxErrorLabel, \" \").concat(errorMessage, \" (\").concat(errorLine, \":\").concat(errorColumn, \")\");\n    });\n    message = lines.join(\"\\n\");\n    // Smoosh syntax errors (commonly found in CSS)\n    message = message.replace(/SyntaxError\\s+\\((\\d+):(\\d+)\\)\\s*(.+?)\\n/g, \"\".concat(friendlySyntaxErrorLabel, \" $3 ($1:$2)\\n\"));\n    // Clean up export errors\n    message = message.replace(/^.*export '(.+?)' was not found in '(.+?)'.*$/gm, \"Attempted import error: '$1' is not exported from '$2'.\");\n    message = message.replace(/^.*export 'default' \\(imported as '(.+?)'\\) was not found in '(.+?)'.*$/gm, \"Attempted import error: '$2' does not contain a default export (imported as '$1').\");\n    message = message.replace(/^.*export '(.+?)' \\(imported as '(.+?)'\\) was not found in '(.+?)'.*$/gm, \"Attempted import error: '$1' is not exported from '$3' (imported as '$2').\");\n    lines = message.split(\"\\n\");\n    // Remove leading newline\n    if (lines.length > 2 && lines[1].trim() === \"\") {\n        lines.splice(1, 1);\n    }\n    // Cleans up verbose \"module not found\" messages for files and packages.\n    if (lines[1] && lines[1].indexOf(\"Module not found: \") === 0) {\n        lines = [\n            lines[0],\n            lines[1].replace(\"Error: \", \"\").replace(\"Module not found: Cannot find file:\", \"Cannot find file:\"),\n            ...lines.slice(2)\n        ];\n    }\n    // Add helpful message for users trying to use Sass for the first time\n    if (lines[1] && lines[1].match(/Cannot find module.+sass/)) {\n        // ./file.module.scss (<<loader info>>) => ./file.module.scss\n        const firstLine = lines[0].split(\"!\");\n        lines[0] = firstLine[firstLine.length - 1];\n        lines[1] = \"To use Next.js' built-in Sass support, you first need to install `sass`.\\n\";\n        lines[1] += \"Run `npm i sass` or `yarn add sass` inside your workspace.\\n\";\n        lines[1] += \"\\nLearn more: https://nextjs.org/docs/messages/install-sass\";\n        // dispose of unhelpful stack trace\n        lines = lines.slice(0, 2);\n        hadMissingSassError = true;\n    } else if (hadMissingSassError && message.match(/(sass-loader|resolve-url-loader: CSS error)/)) {\n        // dispose of unhelpful stack trace following missing sass module\n        lines = [];\n    }\n    if (!verbose) {\n        message = lines.join(\"\\n\");\n        // Internal stacks are generally useless so we strip them... with the\n        // exception of stacks containing `webpack:` because they're normally\n        // from user code generated by Webpack. For more information see\n        // https://github.com/facebook/create-react-app/pull/1050\n        message = message.replace(/^\\s*at\\s((?!webpack:).)*:\\d+:\\d+[\\s)]*(\\n|$)/gm, \"\") // at ... ...:x:y\n        ;\n        message = message.replace(/^\\s*at\\s<anonymous>(\\n|$)/gm, \"\") // at <anonymous>\n        ;\n        lines = message.split(\"\\n\");\n    }\n    // Remove duplicated newlines\n    lines = lines.filter((line, index, arr)=>index === 0 || line.trim() !== \"\" || line.trim() !== arr[index - 1].trim());\n    // Reassemble the message\n    message = lines.join(\"\\n\");\n    return message.trim();\n}\nfunction formatWebpackMessages(json, verbose) {\n    const formattedErrors = json.errors.map(function(message) {\n        let importTraceNote;\n        if (message && message.message && /Font loader error:/.test(message.message)) {\n            return message.message.slice(message.message.indexOf(\"Font loader error:\"));\n        }\n        return formatMessage(message, verbose, importTraceNote);\n    });\n    const formattedWarnings = json.warnings.map(function(message) {\n        return formatMessage(message, verbose);\n    });\n    const result = _extends({}, json, {\n        errors: formattedErrors,\n        warnings: formattedWarnings\n    });\n    if (!verbose && result.errors.some(isLikelyASyntaxError)) {\n        // If there are any syntax errors, show just them.\n        result.errors = result.errors.filter(isLikelyASyntaxError);\n        result.warnings = [];\n    }\n    return result;\n}\nmodule.exports = formatWebpackMessages;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=format-webpack-messages.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvZXJyb3Itb3ZlcmxheS9mb3JtYXQtd2VicGFjay1tZXNzYWdlcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLFdBQVdDLG1IQUErQztBQUM5RCxJQUFJRSwyQkFBMkJGLG1KQUErRDtBQUM5RixJQUFJRyxhQUFhRCx5QkFBeUJGLG1CQUFPQSxDQUFDLDRGQUErQjtBQUNqRixxS0FBcUs7QUFDckssMERBQTBEO0FBQzFELE1BQU1JLDJCQUEyQjtBQUNqQyxNQUFNQyxvQ0FBb0M7QUFDMUMsU0FBU0MscUJBQXFCQyxPQUFPLEVBQUU7SUFDbkMsT0FBTyxDQUFDLEdBQUdKLFVBQVUsRUFBRUYsT0FBTyxDQUFDTSxTQUFTQyxPQUFPLENBQUNKLDhCQUE4QixDQUFDO0FBQ25GO0FBQ0EsSUFBSUssc0JBQXNCLEtBQUs7QUFDL0Isb0NBQW9DO0FBQ3BDLFNBQVNDLGNBQWNILE9BQU8sRUFBRUksT0FBTyxFQUFFQyxlQUFlLEVBQUU7SUFDdEQsOENBQThDO0lBQzlDLElBQUksT0FBT0wsWUFBWSxZQUFZQSxRQUFRQSxPQUFPLEVBQUU7UUFDaEQsTUFBTU0sc0JBQXNCTixRQUFRTyxXQUFXLElBQUlQLFFBQVFPLFdBQVcsQ0FBQ0MsTUFBTSxDQUFDLENBQUNDLFFBQVEsQ0FBQywwREFBMERDLElBQUksQ0FBQ0QsTUFBTUUsVUFBVTtRQUN2SyxJQUFJQyxPQUFPWixRQUFRQSxPQUFPO1FBQzFCLE1BQU1hLHNCQUFzQkQsS0FBS1gsT0FBTyxDQUFDSDtRQUN6QyxJQUFJZSx1QkFBdUIsR0FBRztZQUMxQkQsT0FBT0EsS0FBS0UsS0FBSyxDQUFDLEdBQUdEO1FBQ3pCLENBQUM7UUFDRGIsVUFBVSxDQUFDQSxRQUFRZSxVQUFVLEdBQUcsQ0FBQyxHQUFHbkIsVUFBVSxFQUFFRixPQUFPLENBQUNNLFFBQVFlLFVBQVUsSUFBSSxPQUFPLEVBQUUsSUFBS2YsQ0FBQUEsUUFBUWdCLElBQUksR0FBRyxD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QUc4QyxNQUFNO1FBQzlCRSxRQUFRRDtRQUNSRyxVQUFVRDtJQUNkO0lBQ0EsSUFBSSxDQUFDckMsV0FBV3VDLE9BQU9ILE1BQU0sQ0FBQ0ksSUFBSSxDQUFDN0MsdUJBQXVCO1FBQ3RELGtEQUFrRDtRQUNsRDRDLE9BQU9ILE1BQU0sR0FBR0csT0FBT0gsTUFBTSxDQUFDaEMsTUFBTSxDQUFDVDtRQUNyQzRDLE9BQU9ELFFBQVEsR0FBRyxFQUFFO0lBQ3hCLENBQUM7SUFDRCxPQUFPQztBQUNYO0FBQ0FFLE9BQU9DLE9BQU8sR0FBR1Q7QUFFakIsSUFBSSxDQUFDLE9BQU9TLFFBQVFwRCxPQUFPLEtBQUssY0FBZSxPQUFPb0QsUUFBUXBELE9BQU8sS0FBSyxZQUFZb0QsUUFBUXBELE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT29ELFFBQVFwRCxPQUFPLENBQUNxRCxVQUFVLEtBQUssYUFBYTtJQUNyS0MsT0FBT0MsY0FBYyxDQUFDSCxRQUFRcEQsT0FBTyxFQUFFLGNBQWM7UUFBRXdELE9BQU8sSUFBSTtJQUFDO0lBQ25FRixPQUFPRyxNQUFNLENBQUNMLFFBQVFwRCxPQUFPLEVBQUVvRDtJQUMvQkQsT0FBT0MsT0FBTyxHQUFHQSxRQUFRcEQsT0FBTztBQUNsQyxDQUFDLENBRUQsbURBQW1EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2Rldi9lcnJvci1vdmVybGF5L2Zvcm1hdC13ZWJwYWNrLW1lc3NhZ2VzLmpzPzc1ZWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX2V4dGVuZHMgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9fZXh0ZW5kcy5qc1wiKS5kZWZhdWx0O1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5qc1wiKS5kZWZhdWx0O1xudmFyIF9zdHJpcEFuc2kgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9zdHJpcC1hbnNpXCIpKTtcbi8vIFRoaXMgZmlsZSBpcyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svY3JlYXRlLXJlYWN0LWFwcC9ibG9iLzdiMWEzMmJlNmVjOWY5OWE2YzlhM2M2NjgxM2YzYWMwOWM0NzM2YjkvcGFja2FnZXMvcmVhY3QtZGV2LXV0aWxzL2Zvcm1hdFdlYnBhY2tNZXNzYWdlcy5qc1xuLy8gSXQncyBiZWVuIGVkaXRlZCB0byByZW1vdmUgY2hhbGsgYW5kIENSQS1zcGVjaWZpYyBsb2dpY1xuY29uc3QgZnJpZW5kbHlTeW50YXhFcnJvckxhYmVsID0gJ1N5bnRheCBlcnJvcjonO1xuY29uc3QgV0VCUEFDS19CUkVBS0lOR19DSEFOR0VfUE9MWUZJTExTID0gJ1xcblxcbkJSRUFLSU5HIENIQU5HRTogd2VicGFjayA8IDUgdXNlZCB0byBpbmNsdWRlIHBvbHlmaWxscyBmb3Igbm9kZS5qcyBjb3JlIG1vZHVsZXMgYnkgZGVmYXVsdC4nO1xuZnVuY3Rpb24gaXNMaWtlbHlBU3ludGF4RXJyb3IobWVzc2FnZSkge1xuICAgIHJldHVybiAoMCwgX3N0cmlwQW5zaSkuZGVmYXVsdChtZXNzYWdlKS5pbmRleE9mKGZyaWVuZGx5U3ludGF4RXJyb3JMYWJlbCkgIT09IC0xO1xufVxubGV0IGhhZE1pc3NpbmdTYXNzRXJyb3IgPSBmYWxzZTtcbi8vIENsZWFucyB1cCB3ZWJwYWNrIGVycm9yIG1lc3NhZ2VzLlxuZnVuY3Rpb24gZm9ybWF0TWVzc2FnZShtZXNzYWdlLCB2ZXJib3NlLCBpbXBvcnRUcmFjZU5vdGUpIHtcbiAgICAvLyBUT0RPOiBSZXBsYWNlIHRoaXMgb25jZSB3ZWJwYWNrIDUgaXMgc3RhYmxlXG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnb2JqZWN0JyAmJiBtZXNzYWdlLm1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgZmlsdGVyZWRNb2R1bGVUcmFjZSA9IG1lc3NhZ2UubW9kdWxlVHJhY2UgJiYgbWVzc2FnZS5tb2R1bGVUcmFjZS5maWx0ZXIoKHRyYWNlKT0+IS9uZXh0LShtaWRkbGV3YXJlfGNsaWVudC1wYWdlc3xlZGdlLWZ1bmN0aW9uKS1sb2FkZXJcXC5qcy8udGVzdCh0cmFjZS5vcmlnaW5OYW1lKSk7XG4gICAgICAgIGxldCBib2R5ID0gbWVzc2FnZS5tZXNzYWdlO1xuICAgICAgICBjb25zdCBicmVha2luZ0NoYW5nZUluZGV4ID0gYm9keS5pbmRleE9mKFdFQlBBQ0tfQlJFQUtJTkdfQ0hBTkdFX1BPTFlGSUxMUyk7XG4gICAgICAgIGlmIChicmVha2luZ0NoYW5nZUluZGV4ID49IDApIHtcbiAgICAgICAgICAgIGJvZHkgPSBib2R5LnNsaWNlKDAsIGJyZWFraW5nQ2hhbmdlSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2UgPSAobWVzc2FnZS5tb2R1bGVOYW1lID8gKDAsIF9zdHJpcEFuc2kpLmRlZmF1bHQobWVzc2FnZS5tb2R1bGVOYW1lKSArICdcXG4nIDogJycpICsgKG1lc3NhZ2UuZmlsZSA/ICgwLCBfc3RyaXBBbnNpKS5kZWZhdWx0KG1lc3NhZ2UuZmlsZSkgKyAnXFxuJyA6ICcnKSArIGJvZHkgKyAobWVzc2FnZS5kZXRhaWxzICYmIHZlcmJvc2UgPyAnXFxuJyArIG1lc3NhZ2UuZGV0YWlscyA6ICcnKSArIChmaWx0ZXJlZE1vZHVsZVRyYWNlICYmIGZpbHRlcmVkTW9kdWxlVHJhY2UubGVuZ3RoICYmIHZlcmJvc2UgPyAoaW1wb3J0VHJhY2VOb3RlIHx8ICdcXG5cXG5JbXBvcnQgdHJhY2UgZm9yIHJlcXVlc3RlZCBtb2R1bGU6JykgKyBmaWx0ZXJlZE1vZHVsZVRyYWNlLm1hcCgodHJhY2UpPT5gXFxuJHt0cmFjZS5tb2R1bGVOYW1lfWApLmpvaW4oJycpIDogJycpICsgKG1lc3NhZ2Uuc3RhY2sgJiYgdmVyYm9zZSA/ICdcXG4nICsgbWVzc2FnZS5zdGFjayA6ICcnKTtcbiAgICB9XG4gICAgbGV0IGxpbmVzID0gbWVzc2FnZS5zcGxpdCgnXFxuJyk7XG4gICAgLy8gU3RyaXAgV2VicGFjay1hZGRlZCBoZWFkZXJzIG9mZiBlcnJvcnMvd2FybmluZ3NcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrL2Jsb2IvbWFzdGVyL2xpYi9Nb2R1bGVFcnJvci5qc1xuICAgIGxpbmVzID0gbGluZXMuZmlsdGVyKChsaW5lKT0+IS9Nb2R1bGUgW0EteiBdK1xcKGZyb20vLnRlc3QobGluZSkpO1xuICAgIC8vIFRyYW5zZm9ybSBwYXJzaW5nIGVycm9yIGludG8gc3ludGF4IGVycm9yXG4gICAgLy8gVE9ETzogbW92ZSB0aGlzIHRvIG91ciBFU0xpbnQgZm9ybWF0dGVyP1xuICAgIGxpbmVzID0gbGluZXMubWFwKChsaW5lKT0+e1xuICAgICAgICBjb25zdCBwYXJzaW5nRXJyb3IgPSAvTGluZSAoXFxkKyk6KD86KFxcZCspOik/XFxzKlBhcnNpbmcgZXJyb3I6ICguKykkLy5leGVjKGxpbmUpO1xuICAgICAgICBpZiAoIXBhcnNpbmdFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgWywgZXJyb3JMaW5lLCBlcnJvckNvbHVtbiwgZXJyb3JNZXNzYWdlXSA9IHBhcnNpbmdFcnJvcjtcbiAgICAgICAgcmV0dXJuIGAke2ZyaWVuZGx5U3ludGF4RXJyb3JMYWJlbH0gJHtlcnJvck1lc3NhZ2V9ICgke2Vycm9yTGluZX06JHtlcnJvckNvbHVtbn0pYDtcbiAgICB9KTtcbiAgICBtZXNzYWdlID0gbGluZXMuam9pbignXFxuJyk7XG4gICAgLy8gU21vb3NoIHN5bnRheCBlcnJvcnMgKGNvbW1vbmx5IGZvdW5kIGluIENTUylcbiAgICBtZXNzYWdlID0gbWVzc2FnZS5yZXBsYWNlKC9TeW50YXhFcnJvclxccytcXCgoXFxkKyk6KFxcZCspXFwpXFxzKiguKz8pXFxuL2csIGAke2ZyaWVuZGx5U3ludGF4RXJyb3JMYWJlbH0gJDMgKCQxOiQyKVxcbmApO1xuICAgIC8vIENsZWFuIHVwIGV4cG9ydCBlcnJvcnNcbiAgICBtZXNzYWdlID0gbWVzc2FnZS5yZXBsYWNlKC9eLipleHBvcnQgJyguKz8pJyB3YXMgbm90IGZvdW5kIGluICcoLis/KScuKiQvZ20sIGBBdHRlbXB0ZWQgaW1wb3J0IGVycm9yOiAnJDEnIGlzIG5vdCBleHBvcnRlZCBmcm9tICckMicuYCk7XG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZSgvXi4qZXhwb3J0ICdkZWZhdWx0JyBcXChpbXBvcnRlZCBhcyAnKC4rPyknXFwpIHdhcyBub3QgZm91bmQgaW4gJyguKz8pJy4qJC9nbSwgYEF0dGVtcHRlZCBpbXBvcnQgZXJyb3I6ICckMicgZG9lcyBub3QgY29udGFpbiBhIGRlZmF1bHQgZXhwb3J0IChpbXBvcnRlZCBhcyAnJDEnKS5gKTtcbiAgICBtZXNzYWdlID0gbWVzc2FnZS5yZXBsYWNlKC9eLipleHBvcnQgJyguKz8pJyBcXChpbXBvcnRlZCBhcyAnKC4rPyknXFwpIHdhcyBub3QgZm91bmQgaW4gJyguKz8pJy4qJC9nbSwgYEF0dGVtcHRlZCBpbXBvcnQgZXJyb3I6ICckMScgaXMgbm90IGV4cG9ydGVkIGZyb20gJyQzJyAoaW1wb3J0ZWQgYXMgJyQyJykuYCk7XG4gICAgbGluZXMgPSBtZXNzYWdlLnNwbGl0KCdcXG4nKTtcbiAgICAvLyBSZW1vdmUgbGVhZGluZyBuZXdsaW5lXG4gICAgaWYgKGxpbmVzLmxlbmd0aCA+IDIgJiYgbGluZXNbMV0udHJpbSgpID09PSAnJykge1xuICAgICAgICBsaW5lcy5zcGxpY2UoMSwgMSk7XG4gICAgfVxuICAgIC8vIENsZWFucyB1cCB2ZXJib3NlIFwibW9kdWxlIG5vdCBmb3VuZFwiIG1lc3NhZ2VzIGZvciBmaWxlcyBhbmQgcGFja2FnZXMuXG4gICAgaWYgKGxpbmVzWzFdICYmIGxpbmVzWzFdLmluZGV4T2YoJ01vZHVsZSBub3QgZm91bmQ6ICcpID09PSAwKSB7XG4gICAgICAgIGxpbmVzID0gW1xuICAgICAgICAgICAgbGluZXNbMF0sXG4gICAgICAgICAgICBsaW5lc1sxXS5yZXBsYWNlKCdFcnJvcjogJywgJycpLnJlcGxhY2UoJ01vZHVsZSBub3QgZm91bmQ6IENhbm5vdCBmaW5kIGZpbGU6JywgJ0Nhbm5vdCBmaW5kIGZpbGU6JyksXG4gICAgICAgICAgICAuLi5saW5lcy5zbGljZSgyKSwgXG4gICAgICAgIF07XG4gICAgfVxuICAgIC8vIEFkZCBoZWxwZnVsIG1lc3NhZ2UgZm9yIHVzZXJzIHRyeWluZyB0byB1c2UgU2FzcyBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICBpZiAobGluZXNbMV0gJiYgbGluZXNbMV0ubWF0Y2goL0Nhbm5vdCBmaW5kIG1vZHVsZS4rc2Fzcy8pKSB7XG4gICAgICAgIC8vIC4vZmlsZS5tb2R1bGUuc2NzcyAoPDxsb2FkZXIgaW5mbz4+KSA9PiAuL2ZpbGUubW9kdWxlLnNjc3NcbiAgICAgICAgY29uc3QgZmlyc3RMaW5lID0gbGluZXNbMF0uc3BsaXQoJyEnKTtcbiAgICAgICAgbGluZXNbMF0gPSBmaXJzdExpbmVbZmlyc3RMaW5lLmxlbmd0aCAtIDFdO1xuICAgICAgICBsaW5lc1sxXSA9IFwiVG8gdXNlIE5leHQuanMnIGJ1aWx0LWluIFNhc3Mgc3VwcG9ydCwgeW91IGZpcnN0IG5lZWQgdG8gaW5zdGFsbCBgc2Fzc2AuXFxuXCI7XG4gICAgICAgIGxpbmVzWzFdICs9ICdSdW4gYG5wbSBpIHNhc3NgIG9yIGB5YXJuIGFkZCBzYXNzYCBpbnNpZGUgeW91ciB3b3Jrc3BhY2UuXFxuJztcbiAgICAgICAgbGluZXNbMV0gKz0gJ1xcbkxlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2luc3RhbGwtc2Fzcyc7XG4gICAgICAgIC8vIGRpc3Bvc2Ugb2YgdW5oZWxwZnVsIHN0YWNrIHRyYWNlXG4gICAgICAgIGxpbmVzID0gbGluZXMuc2xpY2UoMCwgMik7XG4gICAgICAgIGhhZE1pc3NpbmdTYXNzRXJyb3IgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoaGFkTWlzc2luZ1Nhc3NFcnJvciAmJiBtZXNzYWdlLm1hdGNoKC8oc2Fzcy1sb2FkZXJ8cmVzb2x2ZS11cmwtbG9hZGVyOiBDU1MgZXJyb3IpLykpIHtcbiAgICAgICAgLy8gZGlzcG9zZSBvZiB1bmhlbHBmdWwgc3RhY2sgdHJhY2UgZm9sbG93aW5nIG1pc3Npbmcgc2FzcyBtb2R1bGVcbiAgICAgICAgbGluZXMgPSBbXTtcbiAgICB9XG4gICAgaWYgKCF2ZXJib3NlKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBsaW5lcy5qb2luKCdcXG4nKTtcbiAgICAgICAgLy8gSW50ZXJuYWwgc3RhY2tzIGFyZSBnZW5lcmFsbHkgdXNlbGVzcyBzbyB3ZSBzdHJpcCB0aGVtLi4uIHdpdGggdGhlXG4gICAgICAgIC8vIGV4Y2VwdGlvbiBvZiBzdGFja3MgY29udGFpbmluZyBgd2VicGFjazpgIGJlY2F1c2UgdGhleSdyZSBub3JtYWxseVxuICAgICAgICAvLyBmcm9tIHVzZXIgY29kZSBnZW5lcmF0ZWQgYnkgV2VicGFjay4gRm9yIG1vcmUgaW5mb3JtYXRpb24gc2VlXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9jcmVhdGUtcmVhY3QtYXBwL3B1bGwvMTA1MFxuICAgICAgICBtZXNzYWdlID0gbWVzc2FnZS5yZXBsYWNlKC9eXFxzKmF0XFxzKCg/IXdlYnBhY2s6KS4pKjpcXGQrOlxcZCtbXFxzKV0qKFxcbnwkKS9nbSwgJycpIC8vIGF0IC4uLiAuLi46eDp5XG4gICAgICAgIDtcbiAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZSgvXlxccyphdFxcczxhbm9ueW1vdXM+KFxcbnwkKS9nbSwgJycpIC8vIGF0IDxhbm9ueW1vdXM+XG4gICAgICAgIDtcbiAgICAgICAgbGluZXMgPSBtZXNzYWdlLnNwbGl0KCdcXG4nKTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGR1cGxpY2F0ZWQgbmV3bGluZXNcbiAgICBsaW5lcyA9IGxpbmVzLmZpbHRlcigobGluZSwgaW5kZXgsIGFycik9PmluZGV4ID09PSAwIHx8IGxpbmUudHJpbSgpICE9PSAnJyB8fCBsaW5lLnRyaW0oKSAhPT0gYXJyW2luZGV4IC0gMV0udHJpbSgpKTtcbiAgICAvLyBSZWFzc2VtYmxlIHRoZSBtZXNzYWdlXG4gICAgbWVzc2FnZSA9IGxpbmVzLmpvaW4oJ1xcbicpO1xuICAgIHJldHVybiBtZXNzYWdlLnRyaW0oKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFdlYnBhY2tNZXNzYWdlcyhqc29uLCB2ZXJib3NlKSB7XG4gICAgY29uc3QgZm9ybWF0dGVkRXJyb3JzID0ganNvbi5lcnJvcnMubWFwKGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgbGV0IGltcG9ydFRyYWNlTm90ZTtcbiAgICAgICAgaWYgKG1lc3NhZ2UgJiYgbWVzc2FnZS5tZXNzYWdlICYmIC9Gb250IGxvYWRlciBlcnJvcjovLnRlc3QobWVzc2FnZS5tZXNzYWdlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2UubWVzc2FnZS5zbGljZShtZXNzYWdlLm1lc3NhZ2UuaW5kZXhPZignRm9udCBsb2FkZXIgZXJyb3I6JykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXRNZXNzYWdlKG1lc3NhZ2UsIHZlcmJvc2UsIGltcG9ydFRyYWNlTm90ZSk7XG4gICAgfSk7XG4gICAgY29uc3QgZm9ybWF0dGVkV2FybmluZ3MgPSBqc29uLndhcm5pbmdzLm1hcChmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXRNZXNzYWdlKG1lc3NhZ2UsIHZlcmJvc2UpO1xuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IF9leHRlbmRzKHt9LCBqc29uLCB7XG4gICAgICAgIGVycm9yczogZm9ybWF0dGVkRXJyb3JzLFxuICAgICAgICB3YXJuaW5nczogZm9ybWF0dGVkV2FybmluZ3NcbiAgICB9KTtcbiAgICBpZiAoIXZlcmJvc2UgJiYgcmVzdWx0LmVycm9ycy5zb21lKGlzTGlrZWx5QVN5bnRheEVycm9yKSkge1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgYW55IHN5bnRheCBlcnJvcnMsIHNob3cganVzdCB0aGVtLlxuICAgICAgICByZXN1bHQuZXJyb3JzID0gcmVzdWx0LmVycm9ycy5maWx0ZXIoaXNMaWtlbHlBU3ludGF4RXJyb3IpO1xuICAgICAgICByZXN1bHQud2FybmluZ3MgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbm1vZHVsZS5leHBvcnRzID0gZm9ybWF0V2VicGFja01lc3NhZ2VzO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtYXQtd2VicGFjay1tZXNzYWdlcy5qcy5tYXAiXSwibmFtZXMiOlsiX2V4dGVuZHMiLCJyZXF1aXJlIiwiZGVmYXVsdCIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsIl9zdHJpcEFuc2kiLCJmcmllbmRseVN5bnRheEVycm9yTGFiZWwiLCJXRUJQQUNLX0JSRUFLSU5HX0NIQU5HRV9QT0xZRklMTFMiLCJpc0xpa2VseUFTeW50YXhFcnJvciIsIm1lc3NhZ2UiLCJpbmRleE9mIiwiaGFkTWlzc2luZ1Nhc3NFcnJvciIsImZvcm1hdE1lc3NhZ2UiLCJ2ZXJib3NlIiwiaW1wb3J0VHJhY2VOb3RlIiwiZmlsdGVyZWRNb2R1bGVUcmFjZSIsIm1vZHVsZVRyYWNlIiwiZmlsdGVyIiwidHJhY2UiLCJ0ZXN0Iiwib3JpZ2luTmFtZSIsImJvZHkiLCJicmVha2luZ0NoYW5nZUluZGV4Iiwic2xpY2UiLCJtb2R1bGVOYW1lIiwiZmlsZSIsImRldGFpbHMiLCJsZW5ndGgiLCJtYXAiLCJqb2luIiwic3RhY2siLCJsaW5lcyIsInNwbGl0IiwibGluZSIsInBhcnNpbmdFcnJvciIsImV4ZWMiLCJlcnJvckxpbmUiLCJlcnJvckNvbHVtbiIsImVycm9yTWVzc2FnZSIsInJlcGxhY2UiLCJ0cmltIiwic3BsaWNlIiwibWF0Y2giLCJmaXJzdExpbmUiLCJpbmRleCIsImFyciIsImZvcm1hdFdlYnBhY2tNZXNzYWdlcyIsImpzb24iLCJmb3JtYXR0ZWRFcnJvcnMiLCJlcnJvcnMiLCJmb3JtYXR0ZWRXYXJuaW5ncyIsIndhcm5pbmdzIiwicmVzdWx0Iiwic29tZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsImFzc2lnbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/dev/error-overlay/format-webpack-messages.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/dev/error-overlay/hot-dev-client.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/error-overlay/hot-dev-client.js ***!
  \***************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = connect;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _client = __webpack_require__(/*! next/dist/compiled/@next/react-dev-overlay/dist/client */ \"./node_modules/next/dist/compiled/@next/react-dev-overlay/dist/client.js\");\nvar _stripAnsi = _interop_require_default(__webpack_require__(/*! next/dist/compiled/strip-ansi */ \"./node_modules/next/dist/compiled/strip-ansi/index.js\"));\nvar _websocket = __webpack_require__(/*! ./websocket */ \"./node_modules/next/dist/client/dev/error-overlay/websocket.js\");\nvar _formatWebpackMessages = _interop_require_default(__webpack_require__(/*! ./format-webpack-messages */ \"./node_modules/next/dist/client/dev/error-overlay/format-webpack-messages.js\"));\nfunction connect() {\n    (0, _client).register();\n    (0, _websocket).addMessageListener((event)=>{\n        if (event.data.indexOf(\"action\") === -1) return;\n        try {\n            processMessage(event);\n        } catch (ex) {\n            console.warn(\"Invalid HMR message: \" + event.data + \"\\n\", ex);\n        }\n    });\n    return {\n        subscribeToHmrEvent (handler) {\n            customHmrEventHandler = handler;\n        },\n        onUnrecoverableError () {\n            hadRuntimeError = true;\n        }\n    };\n}\n// This alternative WebpackDevServer combines the functionality of:\n// https://github.com/webpack/webpack-dev-server/blob/webpack-1/client/index.js\n// https://github.com/webpack/webpack/blob/webpack-1/hot/dev-server.js\n// It only supports their simplest configuration (hot updates on same server).\n// It makes some opinionated choices on top, like adding a syntax error overlay\n// that looks similar to our console output. The error overlay is inspired by:\n// https://github.com/glenjamin/webpack-hot-middleware\nwindow.__nextDevClientId = Math.round(Math.random() * 100 + Date.now());\nlet hadRuntimeError = false;\nlet customHmrEventHandler;\n// Remember some state related to hot module replacement.\nvar isFirstCompilation = true;\nvar mostRecentCompilationHash = null;\nvar hasCompileErrors = false;\nfunction clearOutdatedErrors() {\n    // Clean up outdated compile errors, if any.\n    if (typeof console !== \"undefined\" && typeof console.clear === \"function\") {\n        if (hasCompileErrors) {\n            console.clear();\n        }\n    }\n}\n// Successful compilation.\nfunction handleSuccess() {\n    clearOutdatedErrors();\n    const isHotUpdate = !isFirstCompilation || window.__NEXT_DATA__.page !== \"/_error\" && isUpdateAvailable();\n    isFirstCompilation = false;\n    hasCompileErrors = false;\n    // Attempt to apply hot updates or reload.\n    if (isHotUpdate) {\n        tryApplyUpdates(onBeforeFastRefresh, onFastRefresh);\n    }\n}\n// Compilation with warnings (e.g. ESLint).\nfunction handleWarnings(warnings) {\n    clearOutdatedErrors();\n    const isHotUpdate = !isFirstCompilation;\n    isFirstCompilation = false;\n    hasCompileErrors = false;\n    function printWarnings() {\n        // Print warnings to the console.\n        const formatted = (0, _formatWebpackMessages).default({\n            warnings: warnings,\n            errors: []\n        });\n        if (typeof console !== \"undefined\" && typeof console.warn === \"function\") {\n            var ref;\n            for(let i = 0; i < ((ref = formatted.warnings) == null ? void 0 : ref.length); i++){\n                if (i === 5) {\n                    console.warn(\"There were more warnings in other files.\\n\" + \"You can find a complete log in the terminal.\");\n                    break;\n                }\n                console.warn((0, _stripAnsi).default(formatted.warnings[i]));\n            }\n        }\n    }\n    printWarnings();\n    // Attempt to apply hot updates or reload.\n    if (isHotUpdate) {\n        tryApplyUpdates(onBeforeFastRefresh, onFastRefresh);\n    }\n}\n// Compilation with errors (e.g. syntax error or missing modules).\nfunction handleErrors(errors) {\n    clearOutdatedErrors();\n    isFirstCompilation = false;\n    hasCompileErrors = true;\n    // \"Massage\" webpack messages.\n    var formatted = (0, _formatWebpackMessages).default({\n        errors: errors,\n        warnings: []\n    });\n    // Only show the first error.\n    (0, _client).onBuildError(formatted.errors[0]);\n    // Also log them to the console.\n    if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n        for(var i = 0; i < formatted.errors.length; i++){\n            console.error((0, _stripAnsi).default(formatted.errors[i]));\n        }\n    }\n    // Do not attempt to reload now.\n    // We will reload on next success instead.\n    if (false) {}\n}\nlet startLatency = undefined;\nfunction onBeforeFastRefresh(hasUpdates) {\n    if (hasUpdates) {\n        // Only trigger a pending state if we have updates to apply\n        // (cf. onFastRefresh)\n        (0, _client).onBeforeRefresh();\n    }\n}\nfunction onFastRefresh(hasUpdates) {\n    (0, _client).onBuildOk();\n    if (hasUpdates) {\n        // Only complete a pending state if we applied updates\n        // (cf. onBeforeFastRefresh)\n        (0, _client).onRefresh();\n    }\n    if (startLatency) {\n        const endLatency = Date.now();\n        const latency = endLatency - startLatency;\n        console.log(\"[Fast Refresh] done in \".concat(latency, \"ms\"));\n        (0, _websocket).sendMessage(JSON.stringify({\n            event: \"client-hmr-latency\",\n            id: window.__nextDevClientId,\n            startTime: startLatency,\n            endTime: endLatency\n        }));\n        if (self.__NEXT_HMR_LATENCY_CB) {\n            self.__NEXT_HMR_LATENCY_CB(latency);\n        }\n    }\n}\n// There is a newer version of the code available.\nfunction handleAvailableHash(hash) {\n    // Update last known compilation hash.\n    mostRecentCompilationHash = hash;\n}\n// Handle messages from the server.\nfunction processMessage(e) {\n    const obj = JSON.parse(e.data);\n    switch(obj.action){\n        case \"building\":\n            {\n                startLatency = Date.now();\n                console.log(\"[Fast Refresh] rebuilding\");\n                break;\n            }\n        case \"built\":\n        case \"sync\":\n            {\n                if (obj.hash) {\n                    handleAvailableHash(obj.hash);\n                }\n                const { errors , warnings  } = obj;\n                const hasErrors = Boolean(errors && errors.length);\n                if (hasErrors) {\n                    (0, _websocket).sendMessage(JSON.stringify({\n                        event: \"client-error\",\n                        errorCount: errors.length,\n                        clientId: window.__nextDevClientId\n                    }));\n                    return handleErrors(errors);\n                }\n                const hasWarnings = Boolean(warnings && warnings.length);\n                if (hasWarnings) {\n                    (0, _websocket).sendMessage(JSON.stringify({\n                        event: \"client-warning\",\n                        warningCount: warnings.length,\n                        clientId: window.__nextDevClientId\n                    }));\n                    return handleWarnings(warnings);\n                }\n                (0, _websocket).sendMessage(JSON.stringify({\n                    event: \"client-success\",\n                    clientId: window.__nextDevClientId\n                }));\n                return handleSuccess();\n            }\n        case \"serverComponentChanges\":\n            {\n                // Server component changes don't apply to `pages`.\n                return;\n            }\n        default:\n            {\n                if (customHmrEventHandler) {\n                    customHmrEventHandler(obj);\n                    break;\n                }\n                break;\n            }\n    }\n}\n// Is there a newer version of this code available?\nfunction isUpdateAvailable() {\n    /* globals __webpack_hash__ */ // __webpack_hash__ is the hash of the current compilation.\n    // It's a global variable injected by Webpack.\n    return mostRecentCompilationHash !== __webpack_require__.h();\n}\n// Webpack disallows updates in other states.\nfunction canApplyUpdates() {\n    return module.hot.status() === \"idle\";\n}\nfunction afterApplyUpdates(fn) {\n    if (canApplyUpdates()) {\n        fn();\n    } else {\n        function handler(status) {\n            if (status === \"idle\") {\n                module.hot.removeStatusHandler(handler);\n                fn();\n            }\n        }\n        module.hot.addStatusHandler(handler);\n    }\n}\n// Attempt to update code on the fly, fall back to a hard reload.\nfunction tryApplyUpdates(onBeforeHotUpdate, onHotUpdateSuccess) {\n    if (false) {}\n    if (!isUpdateAvailable() || !canApplyUpdates()) {\n        (0, _client).onBuildOk();\n        return;\n    }\n    function handleApplyUpdates(err, updatedModules) {\n        if (err || hadRuntimeError || !updatedModules) {\n            if (err) {\n                console.warn(\"[Fast Refresh] performing full reload\\n\\n\" + \"Fast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React rendering tree.\\n\" + \"You might have a file which exports a React component but also exports a value that is imported by a non-React component file.\\n\" + \"Consider migrating the non-React component export to a separate file and importing it into both files.\\n\\n\" + \"It is also possible the parent component of the component you edited is a class component, which disables Fast Refresh.\\n\" + \"Fast Refresh requires at least one parent function component in your React tree.\");\n            } else if (hadRuntimeError) {\n                console.warn(\"[Fast Refresh] performing full reload because your application had an unrecoverable error\");\n            }\n            performFullReload(err);\n            return;\n        }\n        const hasUpdates = Boolean(updatedModules.length);\n        if (typeof onHotUpdateSuccess === \"function\") {\n            // Maybe we want to do something.\n            onHotUpdateSuccess(hasUpdates);\n        }\n        if (isUpdateAvailable()) {\n            // While we were updating, there was a new update! Do it again.\n            // However, this time, don't trigger a pending refresh state.\n            tryApplyUpdates(hasUpdates ? undefined : onBeforeHotUpdate, hasUpdates ? _client.onBuildOk : onHotUpdateSuccess);\n        } else {\n            (0, _client).onBuildOk();\n            if (false) {}\n        }\n    }\n    // https://webpack.js.org/api/hot-module-replacement/#check\n    module.hot.check(/* autoApply */ false).then((updatedModules)=>{\n        if (typeof onBeforeHotUpdate === \"function\") {\n            const hasUpdates = Boolean(updatedModules.length);\n            onBeforeHotUpdate(hasUpdates);\n        }\n        return module.hot.apply();\n    }).then((updatedModules)=>{\n        handleApplyUpdates(null, updatedModules);\n    }, (err)=>{\n        handleApplyUpdates(err, null);\n    });\n}\nfunction performFullReload(err) {\n    const stackTrace = err && (err.stack && err.stack.split(\"\\n\").slice(0, 5).join(\"\\n\") || err.message || err + \"\");\n    (0, _websocket).sendMessage(JSON.stringify({\n        event: \"client-full-reload\",\n        stackTrace\n    }));\n    window.location.reload();\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=hot-dev-client.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvZXJyb3Itb3ZlcmxheS9ob3QtZGV2LWNsaWVudC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxrQkFBZSxHQUFHRztBQUNsQixJQUFJQywyQkFBMkJDLG1KQUErRDtBQUM5RixJQUFJQyxVQUFVRCxtQkFBT0EsQ0FBQyx3SUFBd0Q7QUFDOUUsSUFBSUUsYUFBYUgseUJBQXlCQyxtQkFBT0EsQ0FBQyw0RkFBK0I7QUFDakYsSUFBSUcsYUFBYUgsbUJBQU9BLENBQUMsbUZBQWE7QUFDdEMsSUFBSUkseUJBQXlCTCx5QkFBeUJDLG1CQUFPQSxDQUFDLCtHQUEyQjtBQUN6RixTQUFTRixVQUFVO0lBQ2QsSUFBR0csT0FBTyxFQUFFSSxRQUFRO0lBQ3BCLElBQUdGLFVBQVUsRUFBRUcsa0JBQWtCLENBQUMsQ0FBQ0MsUUFBUTtRQUN4QyxJQUFJQSxNQUFNQyxJQUFJLENBQUNDLE9BQU8sQ0FBQyxjQUFjLENBQUMsR0FBRztRQUN6QyxJQUFJO1lBQ0FDLGVBQWVIO1FBQ25CLEVBQUUsT0FBT0ksSUFBSTtZQUNUQyxRQUFRQyxJQUFJLENBQUMsMEJBQTBCTixNQUFNQyxJQUFJLEdBQUcsTUFBTUc7UUFDOUQ7SUFDSjtJQUNBLE9BQU87UUFDSEcscUJBQXFCQyxPQUFPLEVBQUU7WUFDMUJDLHdCQUF3QkQ7UUFDNUI7UUFDQUUsd0JBQXdCO1lBQ3BCQyxrQkFBa0IsSUFBSTtRQUMxQjtJQUNKO0FBQ0o7QUFDQSxtRUFBbUU7QUFDbkUsK0VBQStFO0FBQy9FLHNFQUFzRTtBQUN0RSw4RUFBOEU7QUFDOUUsK0VBQStFO0FBQy9FLDhFQUE4RTtBQUM5RSxzREFBc0Q7QUFDdERDLE9BQU9DLGlCQUFpQixHQUFHQyxLQUFLQyxLQUFLLENBQUNELEtBQUtFLE1BQU0sS0FBSyxNQUFNQyxLQUFLQyxHQUFHO0FBQ3BFLElBQUlQLGtC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MENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2Rldi9lcnJvci1vdmVybGF5L2hvdC1kZXYtY2xpZW50LmpzPzE2MDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBjb25uZWN0O1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5qc1wiKS5kZWZhdWx0O1xudmFyIF9jbGllbnQgPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2Rpc3QvY2xpZW50XCIpO1xudmFyIF9zdHJpcEFuc2kgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9zdHJpcC1hbnNpXCIpKTtcbnZhciBfd2Vic29ja2V0ID0gcmVxdWlyZShcIi4vd2Vic29ja2V0XCIpO1xudmFyIF9mb3JtYXRXZWJwYWNrTWVzc2FnZXMgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcIi4vZm9ybWF0LXdlYnBhY2stbWVzc2FnZXNcIikpO1xuZnVuY3Rpb24gY29ubmVjdCgpIHtcbiAgICAoMCwgX2NsaWVudCkucmVnaXN0ZXIoKTtcbiAgICAoMCwgX3dlYnNvY2tldCkuYWRkTWVzc2FnZUxpc3RlbmVyKChldmVudCk9PntcbiAgICAgICAgaWYgKGV2ZW50LmRhdGEuaW5kZXhPZignYWN0aW9uJykgPT09IC0xKSByZXR1cm47XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcm9jZXNzTWVzc2FnZShldmVudCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgSE1SIG1lc3NhZ2U6ICcgKyBldmVudC5kYXRhICsgJ1xcbicsIGV4KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1YnNjcmliZVRvSG1yRXZlbnQgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGN1c3RvbUhtckV2ZW50SGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgIH0sXG4gICAgICAgIG9uVW5yZWNvdmVyYWJsZUVycm9yICgpIHtcbiAgICAgICAgICAgIGhhZFJ1bnRpbWVFcnJvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xufVxuLy8gVGhpcyBhbHRlcm5hdGl2ZSBXZWJwYWNrRGV2U2VydmVyIGNvbWJpbmVzIHRoZSBmdW5jdGlvbmFsaXR5IG9mOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay1kZXYtc2VydmVyL2Jsb2Ivd2VicGFjay0xL2NsaWVudC9pbmRleC5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay9ibG9iL3dlYnBhY2stMS9ob3QvZGV2LXNlcnZlci5qc1xuLy8gSXQgb25seSBzdXBwb3J0cyB0aGVpciBzaW1wbGVzdCBjb25maWd1cmF0aW9uIChob3QgdXBkYXRlcyBvbiBzYW1lIHNlcnZlcikuXG4vLyBJdCBtYWtlcyBzb21lIG9waW5pb25hdGVkIGNob2ljZXMgb24gdG9wLCBsaWtlIGFkZGluZyBhIHN5bnRheCBlcnJvciBvdmVybGF5XG4vLyB0aGF0IGxvb2tzIHNpbWlsYXIgdG8gb3VyIGNvbnNvbGUgb3V0cHV0LiBUaGUgZXJyb3Igb3ZlcmxheSBpcyBpbnNwaXJlZCBieTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGVuamFtaW4vd2VicGFjay1ob3QtbWlkZGxld2FyZVxud2luZG93Ll9fbmV4dERldkNsaWVudElkID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMTAwICsgRGF0ZS5ub3coKSk7XG5sZXQgaGFkUnVudGltZUVycm9yID0gZmFsc2U7XG5sZXQgY3VzdG9tSG1yRXZlbnRIYW5kbGVyO1xuLy8gUmVtZW1iZXIgc29tZSBzdGF0ZSByZWxhdGVkIHRvIGhvdCBtb2R1bGUgcmVwbGFjZW1lbnQuXG52YXIgaXNGaXJzdENvbXBpbGF0aW9uID0gdHJ1ZTtcbnZhciBtb3N0UmVjZW50Q29tcGlsYXRpb25IYXNoID0gbnVsbDtcbnZhciBoYXNDb21waWxlRXJyb3JzID0gZmFsc2U7XG5mdW5jdGlvbiBjbGVhck91dGRhdGVkRXJyb3JzKCkge1xuICAgIC8vIENsZWFuIHVwIG91dGRhdGVkIGNvbXBpbGUgZXJyb3JzLCBpZiBhbnkuXG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5jbGVhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAoaGFzQ29tcGlsZUVycm9ycykge1xuICAgICAgICAgICAgY29uc29sZS5jbGVhcigpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gU3VjY2Vzc2Z1bCBjb21waWxhdGlvbi5cbmZ1bmN0aW9uIGhhbmRsZVN1Y2Nlc3MoKSB7XG4gICAgY2xlYXJPdXRkYXRlZEVycm9ycygpO1xuICAgIGNvbnN0IGlzSG90VXBkYXRlID0gIWlzRmlyc3RDb21waWxhdGlvbiB8fCB3aW5kb3cuX19ORVhUX0RBVEFfXy5wYWdlICE9PSAnL19lcnJvcicgJiYgaXNVcGRhdGVBdmFpbGFibGUoKTtcbiAgICBpc0ZpcnN0Q29tcGlsYXRpb24gPSBmYWxzZTtcbiAgICBoYXNDb21waWxlRXJyb3JzID0gZmFsc2U7XG4gICAgLy8gQXR0ZW1wdCB0byBhcHBseSBob3QgdXBkYXRlcyBvciByZWxvYWQuXG4gICAgaWYgKGlzSG90VXBkYXRlKSB7XG4gICAgICAgIHRyeUFwcGx5VXBkYXRlcyhvbkJlZm9yZUZhc3RSZWZyZXNoLCBvbkZhc3RSZWZyZXNoKTtcbiAgICB9XG59XG4vLyBDb21waWxhdGlvbiB3aXRoIHdhcm5pbmdzIChlLmcuIEVTTGludCkuXG5mdW5jdGlvbiBoYW5kbGVXYXJuaW5ncyh3YXJuaW5ncykge1xuICAgIGNsZWFyT3V0ZGF0ZWRFcnJvcnMoKTtcbiAgICBjb25zdCBpc0hvdFVwZGF0ZSA9ICFpc0ZpcnN0Q29tcGlsYXRpb247XG4gICAgaXNGaXJzdENvbXBpbGF0aW9uID0gZmFsc2U7XG4gICAgaGFzQ29tcGlsZUVycm9ycyA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIHByaW50V2FybmluZ3MoKSB7XG4gICAgICAgIC8vIFByaW50IHdhcm5pbmdzIHRvIHRoZSBjb25zb2xlLlxuICAgICAgICBjb25zdCBmb3JtYXR0ZWQgPSAoMCwgX2Zvcm1hdFdlYnBhY2tNZXNzYWdlcykuZGVmYXVsdCh7XG4gICAgICAgICAgICB3YXJuaW5nczogd2FybmluZ3MsXG4gICAgICAgICAgICBlcnJvcnM6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLndhcm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciByZWY7XG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgKChyZWYgPSBmb3JtYXR0ZWQud2FybmluZ3MpID09IG51bGwgPyB2b2lkIDAgOiByZWYubGVuZ3RoKTsgaSsrKXtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gNSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoZXJlIHdlcmUgbW9yZSB3YXJuaW5ncyBpbiBvdGhlciBmaWxlcy5cXG4nICsgJ1lvdSBjYW4gZmluZCBhIGNvbXBsZXRlIGxvZyBpbiB0aGUgdGVybWluYWwuJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oKDAsIF9zdHJpcEFuc2kpLmRlZmF1bHQoZm9ybWF0dGVkLndhcm5pbmdzW2ldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJpbnRXYXJuaW5ncygpO1xuICAgIC8vIEF0dGVtcHQgdG8gYXBwbHkgaG90IHVwZGF0ZXMgb3IgcmVsb2FkLlxuICAgIGlmIChpc0hvdFVwZGF0ZSkge1xuICAgICAgICB0cnlBcHBseVVwZGF0ZXMob25CZWZvcmVGYXN0UmVmcmVzaCwgb25GYXN0UmVmcmVzaCk7XG4gICAgfVxufVxuLy8gQ29tcGlsYXRpb24gd2l0aCBlcnJvcnMgKGUuZy4gc3ludGF4IGVycm9yIG9yIG1pc3NpbmcgbW9kdWxlcykuXG5mdW5jdGlvbiBoYW5kbGVFcnJvcnMoZXJyb3JzKSB7XG4gICAgY2xlYXJPdXRkYXRlZEVycm9ycygpO1xuICAgIGlzRmlyc3RDb21waWxhdGlvbiA9IGZhbHNlO1xuICAgIGhhc0NvbXBpbGVFcnJvcnMgPSB0cnVlO1xuICAgIC8vIFwiTWFzc2FnZVwiIHdlYnBhY2sgbWVzc2FnZXMuXG4gICAgdmFyIGZvcm1hdHRlZCA9ICgwLCBfZm9ybWF0V2VicGFja01lc3NhZ2VzKS5kZWZhdWx0KHtcbiAgICAgICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgICAgIHdhcm5pbmdzOiBbXVxuICAgIH0pO1xuICAgIC8vIE9ubHkgc2hvdyB0aGUgZmlyc3QgZXJyb3IuXG4gICAgKDAsIF9jbGllbnQpLm9uQnVpbGRFcnJvcihmb3JtYXR0ZWQuZXJyb3JzWzBdKTtcbiAgICAvLyBBbHNvIGxvZyB0aGVtIHRvIHRoZSBjb25zb2xlLlxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGZvcm1hdHRlZC5lcnJvcnMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcigoMCwgX3N0cmlwQW5zaSkuZGVmYXVsdChmb3JtYXR0ZWQuZXJyb3JzW2ldKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRG8gbm90IGF0dGVtcHQgdG8gcmVsb2FkIG5vdy5cbiAgICAvLyBXZSB3aWxsIHJlbG9hZCBvbiBuZXh0IHN1Y2Nlc3MgaW5zdGVhZC5cbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1RFU1RfTU9ERSkge1xuICAgICAgICBpZiAoc2VsZi5fX05FWFRfSE1SX0NCKSB7XG4gICAgICAgICAgICBzZWxmLl9fTkVYVF9ITVJfQ0IoZm9ybWF0dGVkLmVycm9yc1swXSk7XG4gICAgICAgICAgICBzZWxmLl9fTkVYVF9ITVJfQ0IgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxubGV0IHN0YXJ0TGF0ZW5jeSA9IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIG9uQmVmb3JlRmFzdFJlZnJlc2goaGFzVXBkYXRlcykge1xuICAgIGlmIChoYXNVcGRhdGVzKSB7XG4gICAgICAgIC8vIE9ubHkgdHJpZ2dlciBhIHBlbmRpbmcgc3RhdGUgaWYgd2UgaGF2ZSB1cGRhdGVzIHRvIGFwcGx5XG4gICAgICAgIC8vIChjZi4gb25GYXN0UmVmcmVzaClcbiAgICAgICAgKDAsIF9jbGllbnQpLm9uQmVmb3JlUmVmcmVzaCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG9uRmFzdFJlZnJlc2goaGFzVXBkYXRlcykge1xuICAgICgwLCBfY2xpZW50KS5vbkJ1aWxkT2soKTtcbiAgICBpZiAoaGFzVXBkYXRlcykge1xuICAgICAgICAvLyBPbmx5IGNvbXBsZXRlIGEgcGVuZGluZyBzdGF0ZSBpZiB3ZSBhcHBsaWVkIHVwZGF0ZXNcbiAgICAgICAgLy8gKGNmLiBvbkJlZm9yZUZhc3RSZWZyZXNoKVxuICAgICAgICAoMCwgX2NsaWVudCkub25SZWZyZXNoKCk7XG4gICAgfVxuICAgIGlmIChzdGFydExhdGVuY3kpIHtcbiAgICAgICAgY29uc3QgZW5kTGF0ZW5jeSA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IGxhdGVuY3kgPSBlbmRMYXRlbmN5IC0gc3RhcnRMYXRlbmN5O1xuICAgICAgICBjb25zb2xlLmxvZyhgW0Zhc3QgUmVmcmVzaF0gZG9uZSBpbiAke2xhdGVuY3l9bXNgKTtcbiAgICAgICAgKDAsIF93ZWJzb2NrZXQpLnNlbmRNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIGV2ZW50OiAnY2xpZW50LWhtci1sYXRlbmN5JyxcbiAgICAgICAgICAgIGlkOiB3aW5kb3cuX19uZXh0RGV2Q2xpZW50SWQsXG4gICAgICAgICAgICBzdGFydFRpbWU6IHN0YXJ0TGF0ZW5jeSxcbiAgICAgICAgICAgIGVuZFRpbWU6IGVuZExhdGVuY3lcbiAgICAgICAgfSkpO1xuICAgICAgICBpZiAoc2VsZi5fX05FWFRfSE1SX0xBVEVOQ1lfQ0IpIHtcbiAgICAgICAgICAgIHNlbGYuX19ORVhUX0hNUl9MQVRFTkNZX0NCKGxhdGVuY3kpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gVGhlcmUgaXMgYSBuZXdlciB2ZXJzaW9uIG9mIHRoZSBjb2RlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIGhhbmRsZUF2YWlsYWJsZUhhc2goaGFzaCkge1xuICAgIC8vIFVwZGF0ZSBsYXN0IGtub3duIGNvbXBpbGF0aW9uIGhhc2guXG4gICAgbW9zdFJlY2VudENvbXBpbGF0aW9uSGFzaCA9IGhhc2g7XG59XG4vLyBIYW5kbGUgbWVzc2FnZXMgZnJvbSB0aGUgc2VydmVyLlxuZnVuY3Rpb24gcHJvY2Vzc01lc3NhZ2UoZSkge1xuICAgIGNvbnN0IG9iaiA9IEpTT04ucGFyc2UoZS5kYXRhKTtcbiAgICBzd2l0Y2gob2JqLmFjdGlvbil7XG4gICAgICAgIGNhc2UgJ2J1aWxkaW5nJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdGFydExhdGVuY3kgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbRmFzdCBSZWZyZXNoXSByZWJ1aWxkaW5nJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2J1aWx0JzpcbiAgICAgICAgY2FzZSAnc3luYyc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5oYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUF2YWlsYWJsZUhhc2gob2JqLmhhc2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IGVycm9ycyAsIHdhcm5pbmdzICB9ID0gb2JqO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc0Vycm9ycyA9IEJvb2xlYW4oZXJyb3JzICYmIGVycm9ycy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChoYXNFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF93ZWJzb2NrZXQpLnNlbmRNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiAnY2xpZW50LWVycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ291bnQ6IGVycm9ycy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRJZDogd2luZG93Ll9fbmV4dERldkNsaWVudElkXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9ycyhlcnJvcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBoYXNXYXJuaW5ncyA9IEJvb2xlYW4od2FybmluZ3MgJiYgd2FybmluZ3MubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzV2FybmluZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF93ZWJzb2NrZXQpLnNlbmRNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiAnY2xpZW50LXdhcm5pbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybmluZ0NvdW50OiB3YXJuaW5ncy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRJZDogd2luZG93Ll9fbmV4dERldkNsaWVudElkXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVdhcm5pbmdzKHdhcm5pbmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKDAsIF93ZWJzb2NrZXQpLnNlbmRNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6ICdjbGllbnQtc3VjY2VzcycsXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudElkOiB3aW5kb3cuX19uZXh0RGV2Q2xpZW50SWRcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVN1Y2Nlc3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnc2VydmVyQ29tcG9uZW50Q2hhbmdlcyc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gU2VydmVyIGNvbXBvbmVudCBjaGFuZ2VzIGRvbid0IGFwcGx5IHRvIGBwYWdlc2AuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChjdXN0b21IbXJFdmVudEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tSG1yRXZlbnRIYW5kbGVyKG9iaik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICB9XG59XG4vLyBJcyB0aGVyZSBhIG5ld2VyIHZlcnNpb24gb2YgdGhpcyBjb2RlIGF2YWlsYWJsZT9cbmZ1bmN0aW9uIGlzVXBkYXRlQXZhaWxhYmxlKCkge1xuICAgIC8qIGdsb2JhbHMgX193ZWJwYWNrX2hhc2hfXyAqLyAvLyBfX3dlYnBhY2tfaGFzaF9fIGlzIHRoZSBoYXNoIG9mIHRoZSBjdXJyZW50IGNvbXBpbGF0aW9uLlxuICAgIC8vIEl0J3MgYSBnbG9iYWwgdmFyaWFibGUgaW5qZWN0ZWQgYnkgV2VicGFjay5cbiAgICByZXR1cm4gbW9zdFJlY2VudENvbXBpbGF0aW9uSGFzaCAhPT0gX193ZWJwYWNrX2hhc2hfXztcbn1cbi8vIFdlYnBhY2sgZGlzYWxsb3dzIHVwZGF0ZXMgaW4gb3RoZXIgc3RhdGVzLlxuZnVuY3Rpb24gY2FuQXBwbHlVcGRhdGVzKCkge1xuICAgIHJldHVybiBtb2R1bGUuaG90LnN0YXR1cygpID09PSAnaWRsZSc7XG59XG5mdW5jdGlvbiBhZnRlckFwcGx5VXBkYXRlcyhmbikge1xuICAgIGlmIChjYW5BcHBseVVwZGF0ZXMoKSkge1xuICAgICAgICBmbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZXIoc3RhdHVzKSB7XG4gICAgICAgICAgICBpZiAoc3RhdHVzID09PSAnaWRsZScpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LnJlbW92ZVN0YXR1c0hhbmRsZXIoaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtb2R1bGUuaG90LmFkZFN0YXR1c0hhbmRsZXIoaGFuZGxlcik7XG4gICAgfVxufVxuLy8gQXR0ZW1wdCB0byB1cGRhdGUgY29kZSBvbiB0aGUgZmx5LCBmYWxsIGJhY2sgdG8gYSBoYXJkIHJlbG9hZC5cbmZ1bmN0aW9uIHRyeUFwcGx5VXBkYXRlcyhvbkJlZm9yZUhvdFVwZGF0ZSwgb25Ib3RVcGRhdGVTdWNjZXNzKSB7XG4gICAgaWYgKCFtb2R1bGUuaG90KSB7XG4gICAgICAgIC8vIEhvdE1vZHVsZVJlcGxhY2VtZW50UGx1Z2luIGlzIG5vdCBpbiBXZWJwYWNrIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0hvdE1vZHVsZVJlcGxhY2VtZW50UGx1Z2luIGlzIG5vdCBpbiBXZWJwYWNrIGNvbmZpZ3VyYXRpb24uJyk7XG4gICAgICAgIC8vIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWlzVXBkYXRlQXZhaWxhYmxlKCkgfHwgIWNhbkFwcGx5VXBkYXRlcygpKSB7XG4gICAgICAgICgwLCBfY2xpZW50KS5vbkJ1aWxkT2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVBcHBseVVwZGF0ZXMoZXJyLCB1cGRhdGVkTW9kdWxlcykge1xuICAgICAgICBpZiAoZXJyIHx8IGhhZFJ1bnRpbWVFcnJvciB8fCAhdXBkYXRlZE1vZHVsZXMpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tGYXN0IFJlZnJlc2hdIHBlcmZvcm1pbmcgZnVsbCByZWxvYWRcXG5cXG4nICsgXCJGYXN0IFJlZnJlc2ggd2lsbCBwZXJmb3JtIGEgZnVsbCByZWxvYWQgd2hlbiB5b3UgZWRpdCBhIGZpbGUgdGhhdCdzIGltcG9ydGVkIGJ5IG1vZHVsZXMgb3V0c2lkZSBvZiB0aGUgUmVhY3QgcmVuZGVyaW5nIHRyZWUuXFxuXCIgKyAnWW91IG1pZ2h0IGhhdmUgYSBmaWxlIHdoaWNoIGV4cG9ydHMgYSBSZWFjdCBjb21wb25lbnQgYnV0IGFsc28gZXhwb3J0cyBhIHZhbHVlIHRoYXQgaXMgaW1wb3J0ZWQgYnkgYSBub24tUmVhY3QgY29tcG9uZW50IGZpbGUuXFxuJyArICdDb25zaWRlciBtaWdyYXRpbmcgdGhlIG5vbi1SZWFjdCBjb21wb25lbnQgZXhwb3J0IHRvIGEgc2VwYXJhdGUgZmlsZSBhbmQgaW1wb3J0aW5nIGl0IGludG8gYm90aCBmaWxlcy5cXG5cXG4nICsgJ0l0IGlzIGFsc28gcG9zc2libGUgdGhlIHBhcmVudCBjb21wb25lbnQgb2YgdGhlIGNvbXBvbmVudCB5b3UgZWRpdGVkIGlzIGEgY2xhc3MgY29tcG9uZW50LCB3aGljaCBkaXNhYmxlcyBGYXN0IFJlZnJlc2guXFxuJyArICdGYXN0IFJlZnJlc2ggcmVxdWlyZXMgYXQgbGVhc3Qgb25lIHBhcmVudCBmdW5jdGlvbiBjb21wb25lbnQgaW4geW91ciBSZWFjdCB0cmVlLicpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChoYWRSdW50aW1lRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tGYXN0IFJlZnJlc2hdIHBlcmZvcm1pbmcgZnVsbCByZWxvYWQgYmVjYXVzZSB5b3VyIGFwcGxpY2F0aW9uIGhhZCBhbiB1bnJlY292ZXJhYmxlIGVycm9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwZXJmb3JtRnVsbFJlbG9hZChlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhc1VwZGF0ZXMgPSBCb29sZWFuKHVwZGF0ZWRNb2R1bGVzLmxlbmd0aCk7XG4gICAgICAgIGlmICh0eXBlb2Ygb25Ib3RVcGRhdGVTdWNjZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBNYXliZSB3ZSB3YW50IHRvIGRvIHNvbWV0aGluZy5cbiAgICAgICAgICAgIG9uSG90VXBkYXRlU3VjY2VzcyhoYXNVcGRhdGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVcGRhdGVBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgLy8gV2hpbGUgd2Ugd2VyZSB1cGRhdGluZywgdGhlcmUgd2FzIGEgbmV3IHVwZGF0ZSEgRG8gaXQgYWdhaW4uXG4gICAgICAgICAgICAvLyBIb3dldmVyLCB0aGlzIHRpbWUsIGRvbid0IHRyaWdnZXIgYSBwZW5kaW5nIHJlZnJlc2ggc3RhdGUuXG4gICAgICAgICAgICB0cnlBcHBseVVwZGF0ZXMoaGFzVXBkYXRlcyA/IHVuZGVmaW5lZCA6IG9uQmVmb3JlSG90VXBkYXRlLCBoYXNVcGRhdGVzID8gX2NsaWVudC5vbkJ1aWxkT2sgOiBvbkhvdFVwZGF0ZVN1Y2Nlc3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgKDAsIF9jbGllbnQpLm9uQnVpbGRPaygpO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9URVNUX01PREUpIHtcbiAgICAgICAgICAgICAgICBhZnRlckFwcGx5VXBkYXRlcygoKT0+e1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fX05FWFRfSE1SX0NCKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9fTkVYVF9ITVJfQ0IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX19ORVhUX0hNUl9DQiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBodHRwczovL3dlYnBhY2suanMub3JnL2FwaS9ob3QtbW9kdWxlLXJlcGxhY2VtZW50LyNjaGVja1xuICAgIG1vZHVsZS5ob3QuY2hlY2soLyogYXV0b0FwcGx5ICovIGZhbHNlKS50aGVuKCh1cGRhdGVkTW9kdWxlcyk9PntcbiAgICAgICAgaWYgKHR5cGVvZiBvbkJlZm9yZUhvdFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc3QgaGFzVXBkYXRlcyA9IEJvb2xlYW4odXBkYXRlZE1vZHVsZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIG9uQmVmb3JlSG90VXBkYXRlKGhhc1VwZGF0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2R1bGUuaG90LmFwcGx5KCk7XG4gICAgfSkudGhlbigodXBkYXRlZE1vZHVsZXMpPT57XG4gICAgICAgIGhhbmRsZUFwcGx5VXBkYXRlcyhudWxsLCB1cGRhdGVkTW9kdWxlcyk7XG4gICAgfSwgKGVycik9PntcbiAgICAgICAgaGFuZGxlQXBwbHlVcGRhdGVzKGVyciwgbnVsbCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBwZXJmb3JtRnVsbFJlbG9hZChlcnIpIHtcbiAgICBjb25zdCBzdGFja1RyYWNlID0gZXJyICYmIChlcnIuc3RhY2sgJiYgZXJyLnN0YWNrLnNwbGl0KCdcXG4nKS5zbGljZSgwLCA1KS5qb2luKCdcXG4nKSB8fCBlcnIubWVzc2FnZSB8fCBlcnIgKyAnJyk7XG4gICAgKDAsIF93ZWJzb2NrZXQpLnNlbmRNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgZXZlbnQ6ICdjbGllbnQtZnVsbC1yZWxvYWQnLFxuICAgICAgICBzdGFja1RyYWNlXG4gICAgfSkpO1xuICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG90LWRldi1jbGllbnQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdCIsImNvbm5lY3QiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJyZXF1aXJlIiwiX2NsaWVudCIsIl9zdHJpcEFuc2kiLCJfd2Vic29ja2V0IiwiX2Zvcm1hdFdlYnBhY2tNZXNzYWdlcyIsInJlZ2lzdGVyIiwiYWRkTWVzc2FnZUxpc3RlbmVyIiwiZXZlbnQiLCJkYXRhIiwiaW5kZXhPZiIsInByb2Nlc3NNZXNzYWdlIiwiZXgiLCJjb25zb2xlIiwid2FybiIsInN1YnNjcmliZVRvSG1yRXZlbnQiLCJoYW5kbGVyIiwiY3VzdG9tSG1yRXZlbnRIYW5kbGVyIiwib25VbnJlY292ZXJhYmxlRXJyb3IiLCJoYWRSdW50aW1lRXJyb3IiLCJ3aW5kb3ciLCJfX25leHREZXZDbGllbnRJZCIsIk1hdGgiLCJyb3VuZCIsInJhbmRvbSIsIkRhdGUiLCJub3ciLCJpc0ZpcnN0Q29tcGlsYXRpb24iLCJtb3N0UmVjZW50Q29tcGlsYXRpb25IYXNoIiwiaGFzQ29tcGlsZUVycm9ycyIsImNsZWFyT3V0ZGF0ZWRFcnJvcnMiLCJjbGVhciIsImhhbmRsZVN1Y2Nlc3MiLCJpc0hvdFVwZGF0ZSIsIl9fTkVYVF9EQVRBX18iLCJwYWdlIiwiaXNVcGRhdGVBdmFpbGFibGUiLCJ0cnlBcHBseVVwZGF0ZXMiLCJvbkJlZm9yZUZhc3RSZWZyZXNoIiwib25GYXN0UmVmcmVzaCIsImhhbmRsZVdhcm5pbmdzIiwid2FybmluZ3MiLCJwcmludFdhcm5pbmdzIiwiZm9ybWF0dGVkIiwiZXJyb3JzIiwicmVmIiwiaSIsImxlbmd0aCIsImhhbmRsZUVycm9ycyIsIm9uQnVpbGRFcnJvciIsImVycm9yIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9URVNUX01PREUiLCJzZWxmIiwiX19ORVhUX0hNUl9DQiIsInN0YXJ0TGF0ZW5jeSIsInVuZGVmaW5lZCIsImhhc1VwZGF0ZXMiLCJvbkJlZm9yZVJlZnJlc2giLCJvbkJ1aWxkT2siLCJvblJlZnJlc2giLCJlbmRMYXRlbmN5IiwibGF0ZW5jeSIsImxvZyIsInNlbmRNZXNzYWdlIiwiSlNPTiIsInN0cmluZ2lmeSIsImlkIiwic3RhcnRUaW1lIiwiZW5kVGltZSIsIl9fTkVYVF9ITVJfTEFURU5DWV9DQiIsImhhbmRsZUF2YWlsYWJsZUhhc2giLCJoYXNoIiwiZSIsIm9iaiIsInBhcnNlIiwiYWN0aW9uIiwiaGFzRXJyb3JzIiwiQm9vbGVhbiIsImVycm9yQ291bnQiLCJjbGllbnRJZCIsImhhc1dhcm5pbmdzIiwid2FybmluZ0NvdW50IiwiX193ZWJwYWNrX2hhc2hfXyIsImNhbkFwcGx5VXBkYXRlcyIsIm1vZHVsZSIsImhvdCIsInN0YXR1cyIsImFmdGVyQXBwbHlVcGRhdGVzIiwiZm4iLCJyZW1vdmVTdGF0dXNIYW5kbGVyIiwiYWRkU3RhdHVzSGFuZGxlciIsIm9uQmVmb3JlSG90VXBkYXRlIiwib25Ib3RVcGRhdGVTdWNjZXNzIiwiaGFuZGxlQXBwbHlVcGRhdGVzIiwiZXJyIiwidXBkYXRlZE1vZHVsZXMiLCJwZXJmb3JtRnVsbFJlbG9hZCIsImNoZWNrIiwidGhlbiIsImFwcGx5Iiwic3RhY2tUcmFjZSIsInN0YWNrIiwic3BsaXQiLCJzbGljZSIsImpvaW4iLCJtZXNzYWdlIiwibG9jYXRpb24iLCJyZWxvYWQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/dev/error-overlay/hot-dev-client.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/dev/error-overlay/websocket.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/error-overlay/websocket.js ***!
  \**********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.addMessageListener = addMessageListener;\nexports.sendMessage = sendMessage;\nexports.connectHMR = connectHMR;\nlet source;\nconst eventCallbacks = [];\nlet lastActivity = Date.now();\nfunction getSocketProtocol(assetPrefix) {\n    let protocol = location.protocol;\n    try {\n        // assetPrefix is a url\n        protocol = new URL(assetPrefix).protocol;\n    } catch (_) {}\n    return protocol === \"http:\" ? \"ws\" : \"wss\";\n}\nfunction addMessageListener(cb) {\n    eventCallbacks.push(cb);\n}\nfunction sendMessage(data) {\n    if (!source || source.readyState !== source.OPEN) return;\n    return source.send(data);\n}\nfunction connectHMR(options) {\n    if (!options.timeout) {\n        options.timeout = 5 * 1000;\n    }\n    function init() {\n        if (source) source.close();\n        function handleOnline() {\n            if (options.log) console.log(\"[HMR] connected\");\n            lastActivity = Date.now();\n        }\n        function handleMessage(event) {\n            lastActivity = Date.now();\n            eventCallbacks.forEach((cb)=>{\n                cb(event);\n            });\n        }\n        let timer;\n        function handleDisconnect() {\n            clearInterval(timer);\n            source.close();\n            setTimeout(init, options.timeout);\n        }\n        timer = setInterval(function() {\n            if (Date.now() - lastActivity > options.timeout) {\n                handleDisconnect();\n            }\n        }, options.timeout / 2);\n        const { hostname , port  } = location;\n        const protocol = getSocketProtocol(options.assetPrefix || \"\");\n        const assetPrefix = options.assetPrefix.replace(/^\\/+/, \"\");\n        let url = \"\".concat(protocol, \"://\").concat(hostname, \":\").concat(port).concat(assetPrefix ? \"/\".concat(assetPrefix) : \"\");\n        if (assetPrefix.startsWith(\"http\")) {\n            url = \"\".concat(protocol, \"://\").concat(assetPrefix.split(\"://\")[1]);\n        }\n        source = new window.WebSocket(\"\".concat(url).concat(options.path));\n        source.onopen = handleOnline;\n        source.onerror = handleDisconnect;\n        source.onmessage = handleMessage;\n    }\n    init();\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=websocket.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvZXJyb3Itb3ZlcmxheS93ZWJzb2NrZXQuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsMEJBQTBCLEdBQUdFO0FBQzdCRixtQkFBbUIsR0FBR0c7QUFDdEJILGtCQUFrQixHQUFHSTtBQUNyQixJQUFJQztBQUNKLE1BQU1DLGlCQUFpQixFQUFFO0FBQ3pCLElBQUlDLGVBQWVDLEtBQUtDLEdBQUc7QUFDM0IsU0FBU0Msa0JBQWtCQyxXQUFXLEVBQUU7SUFDcEMsSUFBSUMsV0FBV0MsU0FBU0QsUUFBUTtJQUNoQyxJQUFJO1FBQ0EsdUJBQXVCO1FBQ3ZCQSxXQUFXLElBQUlFLElBQUlILGFBQWFDLFFBQVE7SUFDNUMsRUFBRSxPQUFPRyxHQUFHLENBQUM7SUFDYixPQUFPSCxhQUFhLFVBQVUsT0FBTyxLQUFLO0FBQzlDO0FBQ0EsU0FBU1YsbUJBQW1CYyxFQUFFLEVBQUU7SUFDNUJWLGVBQWVXLElBQUksQ0FBQ0Q7QUFDeEI7QUFDQSxTQUFTYixZQUFZZSxJQUFJLEVBQUU7SUFDdkIsSUFBSSxDQUFDYixVQUFVQSxPQUFPYyxVQUFVLEtBQUtkLE9BQU9lLElBQUksRUFBRTtJQUNsRCxPQUFPZixPQUFPZ0IsSUFBSSxDQUFDSDtBQUN2QjtBQUNBLFNBQVNkLFdBQVdrQixPQUFPLEVBQUU7SUFDekIsSUFBSSxDQUFDQSxRQUFRQyxPQUFPLEVBQUU7UUFDbEJELFFBQVFDLE9BQU8sR0FBRyxJQUFJO0lBQzFCLENBQUM7SUFDRCxTQUFTQyxPQUFPO1FBQ1osSUFBSW5CLFFBQVFBLE9BQU9vQixLQUFLO1FBQ3hCLFNBQVNDLGVBQWU7WUFDcEIsSUFBSUosUUFBUUssR0FBRyxFQUFFQyxRQUFRRCxHQUFHLENBQUM7WUFDN0JwQixlQUFlQyxLQUFLQyxHQUFHO1FBQzNCO1FBQ0EsU0FBU29CLGNBQWNDLEtBQUssRUFBRTtZQUMxQnZCLGVBQWVDLEtBQUtDLEdBQUc7WUFDdkJILGVBQWV5QixPQUFPLENBQUMsQ0FBQ2YsS0FBSztnQkFDekJBLEdBQUdjO1lBQ1A7UUFDSjtRQUNBLElBQUlFO1FBQ0osU0FBU0MsbUJBQW1CO1lBQ3hCQyxjQUFjRjtZQUNkM0IsT0FBT29CLEtBQUs7WUFDWlUsV0FBV1gsTUFBTUYsUUFBUUMsT0FBTztRQUNwQztRQUNBUyxRQUFRSSxZQUFZLFdBQVc7WUFDM0IsSUFBSTVCLEtBQUtDLEdBQUcsS0FBS0YsZUFBZWUsUUFBUUMsT0FBTyxFQUFFO2dCQUM3Q1U7WUFDSixDQUFDO1FBQ0wsR0FBR1gsUUFBUUMsT0FBTyxHQUFHO1FBQ3JCLE1BQU0sRUFBRWMsU0FBUSxFQUFHQyxLQUFJLEVBQUcsR0FBR3pCO1FBQzdCLE1BQU1ELFdBQVdGLGtCQUFrQlksUUFBUVgsV0FBVyxJQUFJO1FBQzFELE1BQU1BLGNBQWNXLFFBQVFYLFdBQVcsQ0FBQzRCLE9BQU8sQ0FBQyxRQUFRO1FBQ3hELElBQUlDLE1BQU0sR0FBaUJILE9BQWR6QixVQUFTLE9BQWlCMEIsT0FBWkQsVUFBUyxLQUFVMUIsT0FBUDJCLE1BQTRDLE9BQXJDM0IsY0FBYyxJQUFnQixPQUFaQSxlQUFnQixFQUFFO1FBQ2xGLElBQUlBLFlBQVk4QixVQUFVLENBQUMsU0FBUztZQUNoQ0QsTUFBTSxHQUFpQjdCLE9BQWRDLFVBQVMsT0FBaUMsT0FBNUJELFlBQVkrQixLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUU7UUFDdEQsQ0FBQztRQUNEckMsU0FBUyxJQUFJc0MsT0FBT0MsU0FBUyxDQUFDLEdBQVN0QixPQUFOa0IsS0FBbUIsT0FBYmxCLFFBQVF1QixJQUFJO1FBQ25EeEMsT0FBT3lDLE1BQU0sR0FBR3BCO1FBQ2hCckIsT0FBTzBDLE9BQU8sR0FBR2Q7UUFDakI1QixPQUFPMkMsU0FBUyxHQUFHbkI7SUFDdkI7SUFDQUw7QUFDSjtBQUVBLElBQUksQ0FBQyxPQUFPeEIsUUFBUWlELE9BQU8sS0FBSyxjQUFlLE9BQU9qRCxRQUFRaUQsT0FBTyxLQUFLLFlBQVlqRCxRQUFRaUQsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPakQsUUFBUWlELE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktwRCxPQUFPQyxjQUFjLENBQUNDLFFBQVFpRCxPQUFPLEVBQUUsY0FBYztRQUFFaEQsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9xRCxNQUFNLENBQUNuRCxRQUFRaUQsT0FBTyxFQUFFakQ7SUFDL0JvRCxPQUFPcEQsT0FBTyxHQUFHQSxRQUFRaUQsT0FBTztBQUNsQyxDQUFDLENBRUQscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2Rldi9lcnJvci1vdmVybGF5L3dlYnNvY2tldC5qcz9hOWJlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5hZGRNZXNzYWdlTGlzdGVuZXIgPSBhZGRNZXNzYWdlTGlzdGVuZXI7XG5leHBvcnRzLnNlbmRNZXNzYWdlID0gc2VuZE1lc3NhZ2U7XG5leHBvcnRzLmNvbm5lY3RITVIgPSBjb25uZWN0SE1SO1xubGV0IHNvdXJjZTtcbmNvbnN0IGV2ZW50Q2FsbGJhY2tzID0gW107XG5sZXQgbGFzdEFjdGl2aXR5ID0gRGF0ZS5ub3coKTtcbmZ1bmN0aW9uIGdldFNvY2tldFByb3RvY29sKGFzc2V0UHJlZml4KSB7XG4gICAgbGV0IHByb3RvY29sID0gbG9jYXRpb24ucHJvdG9jb2w7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gYXNzZXRQcmVmaXggaXMgYSB1cmxcbiAgICAgICAgcHJvdG9jb2wgPSBuZXcgVVJMKGFzc2V0UHJlZml4KS5wcm90b2NvbDtcbiAgICB9IGNhdGNoIChfKSB7fVxuICAgIHJldHVybiBwcm90b2NvbCA9PT0gJ2h0dHA6JyA/ICd3cycgOiAnd3NzJztcbn1cbmZ1bmN0aW9uIGFkZE1lc3NhZ2VMaXN0ZW5lcihjYikge1xuICAgIGV2ZW50Q2FsbGJhY2tzLnB1c2goY2IpO1xufVxuZnVuY3Rpb24gc2VuZE1lc3NhZ2UoZGF0YSkge1xuICAgIGlmICghc291cmNlIHx8IHNvdXJjZS5yZWFkeVN0YXRlICE9PSBzb3VyY2UuT1BFTikgcmV0dXJuO1xuICAgIHJldHVybiBzb3VyY2Uuc2VuZChkYXRhKTtcbn1cbmZ1bmN0aW9uIGNvbm5lY3RITVIob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy50aW1lb3V0KSB7XG4gICAgICAgIG9wdGlvbnMudGltZW91dCA9IDUgKiAxMDAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICBpZiAoc291cmNlKSBzb3VyY2UuY2xvc2UoKTtcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlT25saW5lKCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9nKSBjb25zb2xlLmxvZygnW0hNUl0gY29ubmVjdGVkJyk7XG4gICAgICAgICAgICBsYXN0QWN0aXZpdHkgPSBEYXRlLm5vdygpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UoZXZlbnQpIHtcbiAgICAgICAgICAgIGxhc3RBY3Rpdml0eSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBldmVudENhbGxiYWNrcy5mb3JFYWNoKChjYik9PntcbiAgICAgICAgICAgICAgICBjYihldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGltZXI7XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZURpc2Nvbm5lY3QoKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRpbWVyKTtcbiAgICAgICAgICAgIHNvdXJjZS5jbG9zZSgpO1xuICAgICAgICAgICAgc2V0VGltZW91dChpbml0LCBvcHRpb25zLnRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIGxhc3RBY3Rpdml0eSA+IG9wdGlvbnMudGltZW91dCkge1xuICAgICAgICAgICAgICAgIGhhbmRsZURpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgb3B0aW9ucy50aW1lb3V0IC8gMik7XG4gICAgICAgIGNvbnN0IHsgaG9zdG5hbWUgLCBwb3J0ICB9ID0gbG9jYXRpb247XG4gICAgICAgIGNvbnN0IHByb3RvY29sID0gZ2V0U29ja2V0UHJvdG9jb2wob3B0aW9ucy5hc3NldFByZWZpeCB8fCAnJyk7XG4gICAgICAgIGNvbnN0IGFzc2V0UHJlZml4ID0gb3B0aW9ucy5hc3NldFByZWZpeC5yZXBsYWNlKC9eXFwvKy8sICcnKTtcbiAgICAgICAgbGV0IHVybCA9IGAke3Byb3RvY29sfTovLyR7aG9zdG5hbWV9OiR7cG9ydH0ke2Fzc2V0UHJlZml4ID8gYC8ke2Fzc2V0UHJlZml4fWAgOiAnJ31gO1xuICAgICAgICBpZiAoYXNzZXRQcmVmaXguc3RhcnRzV2l0aCgnaHR0cCcpKSB7XG4gICAgICAgICAgICB1cmwgPSBgJHtwcm90b2NvbH06Ly8ke2Fzc2V0UHJlZml4LnNwbGl0KCc6Ly8nKVsxXX1gO1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZSA9IG5ldyB3aW5kb3cuV2ViU29ja2V0KGAke3VybH0ke29wdGlvbnMucGF0aH1gKTtcbiAgICAgICAgc291cmNlLm9ub3BlbiA9IGhhbmRsZU9ubGluZTtcbiAgICAgICAgc291cmNlLm9uZXJyb3IgPSBoYW5kbGVEaXNjb25uZWN0O1xuICAgICAgICBzb3VyY2Uub25tZXNzYWdlID0gaGFuZGxlTWVzc2FnZTtcbiAgICB9XG4gICAgaW5pdCgpO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWJzb2NrZXQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiYWRkTWVzc2FnZUxpc3RlbmVyIiwic2VuZE1lc3NhZ2UiLCJjb25uZWN0SE1SIiwic291cmNlIiwiZXZlbnRDYWxsYmFja3MiLCJsYXN0QWN0aXZpdHkiLCJEYXRlIiwibm93IiwiZ2V0U29ja2V0UHJvdG9jb2wiLCJhc3NldFByZWZpeCIsInByb3RvY29sIiwibG9jYXRpb24iLCJVUkwiLCJfIiwiY2IiLCJwdXNoIiwiZGF0YSIsInJlYWR5U3RhdGUiLCJPUEVOIiwic2VuZCIsIm9wdGlvbnMiLCJ0aW1lb3V0IiwiaW5pdCIsImNsb3NlIiwiaGFuZGxlT25saW5lIiwibG9nIiwiY29uc29sZSIsImhhbmRsZU1lc3NhZ2UiLCJldmVudCIsImZvckVhY2giLCJ0aW1lciIsImhhbmRsZURpc2Nvbm5lY3QiLCJjbGVhckludGVydmFsIiwic2V0VGltZW91dCIsInNldEludGVydmFsIiwiaG9zdG5hbWUiLCJwb3J0IiwicmVwbGFjZSIsInVybCIsInN0YXJ0c1dpdGgiLCJzcGxpdCIsIndpbmRvdyIsIldlYlNvY2tldCIsInBhdGgiLCJvbm9wZW4iLCJvbmVycm9yIiwib25tZXNzYWdlIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/dev/error-overlay/websocket.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/dev/fouc.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/client/dev/fouc.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.displayContent = displayContent;\n// This wrapper function is used to safely select the best available function\n// to schedule removal of the no-FOUC styles workaround. requestAnimationFrame\n// is the ideal choice, but when used in iframes, there are no guarantees that\n// the callback will actually be called, which could stall the promise returned\n// from displayContent.\n//\n// See: https://www.vector-logic.com/blog/posts/on-request-animation-frame-and-embedded-iframes\nconst safeCallbackQueue = (callback)=>{\n    if (window.requestAnimationFrame && window.self === window.top) {\n        window.requestAnimationFrame(callback);\n    } else {\n        window.setTimeout(callback);\n    }\n};\nfunction displayContent() {\n    return new Promise((resolve)=>{\n        safeCallbackQueue(function() {\n            for(var x = document.querySelectorAll(\"[data-next-hide-fouc]\"), i = x.length; i--;){\n                x[i].parentNode.removeChild(x[i]);\n            }\n            resolve();\n        });\n    });\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=fouc.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvZm91Yy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxzQkFBc0IsR0FBR0U7QUFDekIsNkVBQTZFO0FBQzdFLDhFQUE4RTtBQUM5RSw4RUFBOEU7QUFDOUUsK0VBQStFO0FBQy9FLHVCQUF1QjtBQUN2QixFQUFFO0FBQ0YsK0ZBQStGO0FBQy9GLE1BQU1DLG9CQUFvQixDQUFDQyxXQUFXO0lBQ2xDLElBQUlDLE9BQU9DLHFCQUFxQixJQUFJRCxPQUFPRSxJQUFJLEtBQUtGLE9BQU9HLEdBQUcsRUFBRTtRQUM1REgsT0FBT0MscUJBQXFCLENBQUNGO0lBQ2pDLE9BQU87UUFDSEMsT0FBT0ksVUFBVSxDQUFDTDtJQUN0QixDQUFDO0FBQ0w7QUFDQSxTQUFTRixpQkFBaUI7SUFDdEIsT0FBTyxJQUFJUSxRQUFRLENBQUNDLFVBQVU7UUFDMUJSLGtCQUFrQixXQUFXO1lBQ3pCLElBQUksSUFBSVMsSUFBSUMsU0FBU0MsZ0JBQWdCLENBQUMsMEJBQTBCQyxJQUFJSCxFQUFFSSxNQUFNLEVBQUVELEtBQUs7Z0JBQy9FSCxDQUFDLENBQUNHLEVBQUUsQ0FBQ0UsVUFBVSxDQUFDQyxXQUFXLENBQUNOLENBQUMsQ0FBQ0csRUFBRTtZQUNwQztZQUNBSjtRQUNKO0lBQ0o7QUFDSjtBQUVBLElBQUksQ0FBQyxPQUFPWCxRQUFRbUIsT0FBTyxLQUFLLGNBQWUsT0FBT25CLFFBQVFtQixPQUFPLEtBQUssWUFBWW5CLFFBQVFtQixPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9uQixRQUFRbUIsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS3RCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUW1CLE9BQU8sRUFBRSxjQUFjO1FBQUVsQixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT3VCLE1BQU0sQ0FBQ3JCLFFBQVFtQixPQUFPLEVBQUVuQjtJQUMvQnNCLE9BQU90QixPQUFPLEdBQUdBLFFBQVFtQixPQUFPO0FBQ2xDLENBQUMsQ0FFRCxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvZGV2L2ZvdWMuanM/MDA4NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGlzcGxheUNvbnRlbnQgPSBkaXNwbGF5Q29udGVudDtcbi8vIFRoaXMgd3JhcHBlciBmdW5jdGlvbiBpcyB1c2VkIHRvIHNhZmVseSBzZWxlY3QgdGhlIGJlc3QgYXZhaWxhYmxlIGZ1bmN0aW9uXG4vLyB0byBzY2hlZHVsZSByZW1vdmFsIG9mIHRoZSBuby1GT1VDIHN0eWxlcyB3b3JrYXJvdW5kLiByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbi8vIGlzIHRoZSBpZGVhbCBjaG9pY2UsIGJ1dCB3aGVuIHVzZWQgaW4gaWZyYW1lcywgdGhlcmUgYXJlIG5vIGd1YXJhbnRlZXMgdGhhdFxuLy8gdGhlIGNhbGxiYWNrIHdpbGwgYWN0dWFsbHkgYmUgY2FsbGVkLCB3aGljaCBjb3VsZCBzdGFsbCB0aGUgcHJvbWlzZSByZXR1cm5lZFxuLy8gZnJvbSBkaXNwbGF5Q29udGVudC5cbi8vXG4vLyBTZWU6IGh0dHBzOi8vd3d3LnZlY3Rvci1sb2dpYy5jb20vYmxvZy9wb3N0cy9vbi1yZXF1ZXN0LWFuaW1hdGlvbi1mcmFtZS1hbmQtZW1iZWRkZWQtaWZyYW1lc1xuY29uc3Qgc2FmZUNhbGxiYWNrUXVldWUgPSAoY2FsbGJhY2spPT57XG4gICAgaWYgKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgJiYgd2luZG93LnNlbGYgPT09IHdpbmRvdy50b3ApIHtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2spO1xuICAgIH1cbn07XG5mdW5jdGlvbiBkaXNwbGF5Q29udGVudCgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpPT57XG4gICAgICAgIHNhZmVDYWxsYmFja1F1ZXVlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm9yKHZhciB4ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtbmV4dC1oaWRlLWZvdWNdJyksIGkgPSB4Lmxlbmd0aDsgaS0tOyl7XG4gICAgICAgICAgICAgICAgeFtpXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHhbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm91Yy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkaXNwbGF5Q29udGVudCIsInNhZmVDYWxsYmFja1F1ZXVlIiwiY2FsbGJhY2siLCJ3aW5kb3ciLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzZWxmIiwidG9wIiwic2V0VGltZW91dCIsIlByb21pc2UiLCJyZXNvbHZlIiwieCIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvckFsbCIsImkiLCJsZW5ndGgiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/dev/fouc.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/dev/on-demand-entries-client.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/on-demand-entries-client.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\nvar _async_to_generator = (__webpack_require__(/*! @swc/helpers/lib/_async_to_generator.js */ \"./node_modules/@swc/helpers/lib/_async_to_generator.js\")[\"default\"]);\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _router = _interop_require_default(__webpack_require__(/*! next/router */ \"./node_modules/next/router.js\"));\nvar _websocket = __webpack_require__(/*! ./error-overlay/websocket */ \"./node_modules/next/dist/client/dev/error-overlay/websocket.js\");\nvar _default = _async_to_generator(function*(page) {\n    if (page) {\n        // in AMP the router isn't initialized on the client and\n        // client-transitions don't occur so ping initial page\n        setInterval(()=>{\n            (0, _websocket).sendMessage(JSON.stringify({\n                event: \"ping\",\n                page\n            }));\n        }, 2500);\n    } else {\n        _router.default.ready(()=>{\n            setInterval(()=>{\n                // when notFound: true is returned we should use the notFoundPage\n                // as the Router.pathname will point to the 404 page but we want\n                // to ping the source page that returned notFound: true instead\n                const notFoundSrcPage = self.__NEXT_DATA__.notFoundSrcPage;\n                const pathname = (_router.default.pathname === \"/404\" || _router.default.pathname === \"/_error\") && notFoundSrcPage ? notFoundSrcPage : _router.default.pathname;\n                (0, _websocket).sendMessage(JSON.stringify({\n                    event: \"ping\",\n                    page: pathname\n                }));\n            }, 2500);\n        });\n    }\n    (0, _websocket).addMessageListener((event)=>{\n        if (event.data.indexOf(\"{\") === -1) return;\n        try {\n            const payload = JSON.parse(event.data);\n            // don't attempt fetching the page if we're already showing\n            // the dev overlay as this can cause the error to be triggered\n            // repeatedly\n            if (payload.event === \"pong\" && payload.invalid && !self.__NEXT_DATA__.err) {\n                // Payload can be invalid even if the page does exist.\n                // So, we check if it can be created.\n                fetch(location.href, {\n                    credentials: \"same-origin\"\n                }).then((pageRes)=>{\n                    if (pageRes.status === 200) {\n                        // Page exists now, reload\n                        location.reload();\n                    } else {\n                        // Page doesn't exist\n                        if (self.__NEXT_DATA__.page === _router.default.pathname && _router.default.pathname !== \"/_error\") {\n                            // We are still on the page,\n                            // reload to show 404 error page\n                            location.reload();\n                        }\n                    }\n                });\n            }\n        } catch (err) {\n            console.error(\"on-demand-entries failed to parse response\", err);\n        }\n    });\n});\nexports[\"default\"] = _default;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=on-demand-entries-client.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvb24tZGVtYW5kLWVudHJpZXMtY2xpZW50LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGtCQUFlLEdBQUcsS0FBSztBQUN2QixJQUFJRyxzQkFBc0JDLHlJQUEwRDtBQUNwRixJQUFJQywyQkFBMkJELG1KQUErRDtBQUM5RixJQUFJRSxVQUFVRCx5QkFBeUJELG1CQUFPQSxDQUFDLGtEQUFhO0FBQzVELElBQUlHLGFBQWFILG1CQUFPQSxDQUFDLGlHQUEyQjtBQUNwRCxJQUFJSSxXQUFXTCxvQkFBb0IsVUFBVU0sSUFBSSxFQUFFO0lBQy9DLElBQUlBLE1BQU07UUFDTix3REFBd0Q7UUFDeEQsc0RBQXNEO1FBQ3REQyxZQUFZLElBQUk7WUFDWCxJQUFHSCxVQUFVLEVBQUVJLFdBQVcsQ0FBQ0MsS0FBS0MsU0FBUyxDQUFDO2dCQUN2Q0MsT0FBTztnQkFDUEw7WUFDSjtRQUNKLEdBQUc7SUFDUCxPQUFPO1FBQ0hILFFBQVFKLE9BQU8sQ0FBQ2EsS0FBSyxDQUFDLElBQUk7WUFDdEJMLFlBQVksSUFBSTtnQkFDWixpRUFBaUU7Z0JBQ2pFLGdFQUFnRTtnQkFDaEUsK0RBQStEO2dCQUMvRCxNQUFNTSxrQkFBa0JDLEtBQUtDLGFBQWEsQ0FBQ0YsZUFBZTtnQkFDMUQsTUFBTUcsV0FBVyxDQUFDYixRQUFRSixPQUFPLENBQUNpQixRQUFRLEtBQUssVUFBVWIsUUFBUUosT0FBTyxDQUFDaUIsUUFBUSxLQUFLLFNBQVEsS0FBTUgsa0JBQWtCQSxrQkFBa0JWLFFBQVFKLE9BQU8sQ0FBQ2lCLFFBQVE7Z0JBQy9KLElBQUdaLFVBQVUsRUFBRUksV0FBVyxDQUFDQyxLQUFLQyxTQUFTLENBQUM7b0JBQ3ZDQyxPQUFPO29CQUNQTCxNQUFNVTtnQkFDVjtZQUNKLEdBQUc7UUFDUDtJQUNKLENBQUM7SUFDQSxJQUFHWixVQUFVLEVBQUVhLGtCQUFrQixDQUFDLENBQUNOLFFBQVE7UUFDeEMsSUFBSUEsTUFBTU8sSUFBSSxDQUFDQyxPQUFPLENBQUMsU0FBUyxDQUFDLEdBQUc7UUFDcEMsSUFBSTtZQUNBLE1BQU1DLFVBQVVYLEtBQUtZLEtBQUssQ0FBQ1YsTUFBTU8sSUFBSTtZQUNyQywyREFBMkQ7WUFDM0QsOERBQThEO1lBQzlELGFBQWE7WUFDYixJQUFJRSxRQUFRVCxLQUFLLEtBQUssVUFBVVMsUUFBUUUsT0FBTyxJQUFJLENBQUNSLEtBQUtDLGFBQWEsQ0FBQ1EsR0FBRyxFQUFFO2dCQUN4RSxzREFBc0Q7Z0JBQ3RELHFDQUFxQztnQkFDckNDLE1BQU1DLFNBQVNDLElBQUksRUFBRTtvQkFDakJDLGFBQWE7Z0JBQ2pCLEdBQUdDLElBQUksQ0FBQyxDQUFDQyxVQUFVO29CQUNmLElBQUlBLFFBQVFDLE1BQU0sS0FBSyxLQUFLO3dCQUN4QiwwQkFBMEI7d0JBQzFCTCxTQUFTTSxNQUFNO29CQUNuQixPQUFPO3dCQUNILHFCQUFxQjt3QkFDckIsSUFBSWpCLEtBQUtDLGFBQWEsQ0FBQ1QsSUFBSSxLQUFLSCxRQUFRSixPQUFPLENBQUNpQixRQUFRLElBQUliLFFBQVFKLE9BQU8sQ0FBQ2lCLFFBQVEsS0FBSyxXQUFXOzRCQUNoRyw0QkFBNEI7NEJBQzVCLGdDQUFnQzs0QkFDaENTLFNBQVNNLE1BQU07d0JBQ25CLENBQUM7b0JBQ0wsQ0FBQztnQkFDTDtZQUNKLENBQUM7UUFDTCxFQUFFLE9BQU9SLEtBQUs7WUFDVlMsUUFBUUMsS0FBSyxDQUFDLDhDQUE4Q1Y7UUFDaEU7SUFDSjtBQUNKO0FBQ0ExQixrQkFBZSxHQUFHUTtBQUVsQixJQUFJLENBQUMsT0FBT1IsUUFBUUUsT0FBTyxLQUFLLGNBQWUsT0FBT0YsUUFBUUUsT0FBTyxLQUFLLFlBQVlGLFFBQVFFLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT0YsUUFBUUUsT0FBTyxDQUFDbUMsVUFBVSxLQUFLLGFBQWE7SUFDckt2QyxPQUFPQyxjQUFjLENBQUNDLFFBQVFFLE9BQU8sRUFBRSxjQUFjO1FBQUVELE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPd0MsTUFBTSxDQUFDdEMsUUFBUUUsT0FBTyxFQUFFRjtJQUMvQnVDLE9BQU92QyxPQUFPLEdBQUdBLFFBQVFFLE9BQU87QUFDbEMsQ0FBQyxDQUVELG9EQUFvRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvb24tZGVtYW5kLWVudHJpZXMtY2xpZW50LmpzPzg0NWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX2FzeW5jX3RvX2dlbmVyYXRvciA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19hc3luY190b19nZW5lcmF0b3IuanNcIikuZGVmYXVsdDtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuanNcIikuZGVmYXVsdDtcbnZhciBfcm91dGVyID0gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KHJlcXVpcmUoXCJuZXh0L3JvdXRlclwiKSk7XG52YXIgX3dlYnNvY2tldCA9IHJlcXVpcmUoXCIuL2Vycm9yLW92ZXJsYXkvd2Vic29ja2V0XCIpO1xudmFyIF9kZWZhdWx0ID0gX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbioocGFnZSkge1xuICAgIGlmIChwYWdlKSB7XG4gICAgICAgIC8vIGluIEFNUCB0aGUgcm91dGVyIGlzbid0IGluaXRpYWxpemVkIG9uIHRoZSBjbGllbnQgYW5kXG4gICAgICAgIC8vIGNsaWVudC10cmFuc2l0aW9ucyBkb24ndCBvY2N1ciBzbyBwaW5nIGluaXRpYWwgcGFnZVxuICAgICAgICBzZXRJbnRlcnZhbCgoKT0+e1xuICAgICAgICAgICAgKDAsIF93ZWJzb2NrZXQpLnNlbmRNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBldmVudDogJ3BpbmcnLFxuICAgICAgICAgICAgICAgIHBhZ2VcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSwgMjUwMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX3JvdXRlci5kZWZhdWx0LnJlYWR5KCgpPT57XG4gICAgICAgICAgICBzZXRJbnRlcnZhbCgoKT0+e1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gbm90Rm91bmQ6IHRydWUgaXMgcmV0dXJuZWQgd2Ugc2hvdWxkIHVzZSB0aGUgbm90Rm91bmRQYWdlXG4gICAgICAgICAgICAgICAgLy8gYXMgdGhlIFJvdXRlci5wYXRobmFtZSB3aWxsIHBvaW50IHRvIHRoZSA0MDQgcGFnZSBidXQgd2Ugd2FudFxuICAgICAgICAgICAgICAgIC8vIHRvIHBpbmcgdGhlIHNvdXJjZSBwYWdlIHRoYXQgcmV0dXJuZWQgbm90Rm91bmQ6IHRydWUgaW5zdGVhZFxuICAgICAgICAgICAgICAgIGNvbnN0IG5vdEZvdW5kU3JjUGFnZSA9IHNlbGYuX19ORVhUX0RBVEFfXy5ub3RGb3VuZFNyY1BhZ2U7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aG5hbWUgPSAoX3JvdXRlci5kZWZhdWx0LnBhdGhuYW1lID09PSAnLzQwNCcgfHwgX3JvdXRlci5kZWZhdWx0LnBhdGhuYW1lID09PSAnL19lcnJvcicpICYmIG5vdEZvdW5kU3JjUGFnZSA/IG5vdEZvdW5kU3JjUGFnZSA6IF9yb3V0ZXIuZGVmYXVsdC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICAoMCwgX3dlYnNvY2tldCkuc2VuZE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICBldmVudDogJ3BpbmcnLFxuICAgICAgICAgICAgICAgICAgICBwYWdlOiBwYXRobmFtZVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0sIDI1MDApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgKDAsIF93ZWJzb2NrZXQpLmFkZE1lc3NhZ2VMaXN0ZW5lcigoZXZlbnQpPT57XG4gICAgICAgIGlmIChldmVudC5kYXRhLmluZGV4T2YoJ3snKSA9PT0gLTEpIHJldHVybjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgLy8gZG9uJ3QgYXR0ZW1wdCBmZXRjaGluZyB0aGUgcGFnZSBpZiB3ZSdyZSBhbHJlYWR5IHNob3dpbmdcbiAgICAgICAgICAgIC8vIHRoZSBkZXYgb3ZlcmxheSBhcyB0aGlzIGNhbiBjYXVzZSB0aGUgZXJyb3IgdG8gYmUgdHJpZ2dlcmVkXG4gICAgICAgICAgICAvLyByZXBlYXRlZGx5XG4gICAgICAgICAgICBpZiAocGF5bG9hZC5ldmVudCA9PT0gJ3BvbmcnICYmIHBheWxvYWQuaW52YWxpZCAmJiAhc2VsZi5fX05FWFRfREFUQV9fLmVycikge1xuICAgICAgICAgICAgICAgIC8vIFBheWxvYWQgY2FuIGJlIGludmFsaWQgZXZlbiBpZiB0aGUgcGFnZSBkb2VzIGV4aXN0LlxuICAgICAgICAgICAgICAgIC8vIFNvLCB3ZSBjaGVjayBpZiBpdCBjYW4gYmUgY3JlYXRlZC5cbiAgICAgICAgICAgICAgICBmZXRjaChsb2NhdGlvbi5ocmVmLCB7XG4gICAgICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nXG4gICAgICAgICAgICAgICAgfSkudGhlbigocGFnZVJlcyk9PntcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhZ2VSZXMuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhZ2UgZXhpc3RzIG5vdywgcmVsb2FkXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhZ2UgZG9lc24ndCBleGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX19ORVhUX0RBVEFfXy5wYWdlID09PSBfcm91dGVyLmRlZmF1bHQucGF0aG5hbWUgJiYgX3JvdXRlci5kZWZhdWx0LnBhdGhuYW1lICE9PSAnL19lcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhcmUgc3RpbGwgb24gdGhlIHBhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVsb2FkIHRvIHNob3cgNDA0IGVycm9yIHBhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ29uLWRlbWFuZC1lbnRyaWVzIGZhaWxlZCB0byBwYXJzZSByZXNwb25zZScsIGVycik7XG4gICAgICAgIH1cbiAgICB9KTtcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9uLWRlbWFuZC1lbnRyaWVzLWNsaWVudC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwiX2FzeW5jX3RvX2dlbmVyYXRvciIsInJlcXVpcmUiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJfcm91dGVyIiwiX3dlYnNvY2tldCIsIl9kZWZhdWx0IiwicGFnZSIsInNldEludGVydmFsIiwic2VuZE1lc3NhZ2UiLCJKU09OIiwic3RyaW5naWZ5IiwiZXZlbnQiLCJyZWFkeSIsIm5vdEZvdW5kU3JjUGFnZSIsInNlbGYiLCJfX05FWFRfREFUQV9fIiwicGF0aG5hbWUiLCJhZGRNZXNzYWdlTGlzdGVuZXIiLCJkYXRhIiwiaW5kZXhPZiIsInBheWxvYWQiLCJwYXJzZSIsImludmFsaWQiLCJlcnIiLCJmZXRjaCIsImxvY2F0aW9uIiwiaHJlZiIsImNyZWRlbnRpYWxzIiwidGhlbiIsInBhZ2VSZXMiLCJzdGF0dXMiLCJyZWxvYWQiLCJjb25zb2xlIiwiZXJyb3IiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/dev/on-demand-entries-client.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/dev/webpack-hot-middleware-client.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/webpack-hot-middleware-client.js ***!
  \****************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _hotDevClient = _interop_require_default(__webpack_require__(/*! ./error-overlay/hot-dev-client */ \"./node_modules/next/dist/client/dev/error-overlay/hot-dev-client.js\"));\nvar _websocket = __webpack_require__(/*! ./error-overlay/websocket */ \"./node_modules/next/dist/client/dev/error-overlay/websocket.js\");\nvar _default = ()=>{\n    const devClient = (0, _hotDevClient).default();\n    devClient.subscribeToHmrEvent((obj)=>{\n        if (obj.action === \"reloadPage\") {\n            (0, _websocket).sendMessage(JSON.stringify({\n                event: \"client-reload-page\",\n                clientId: window.__nextDevClientId\n            }));\n            return window.location.reload();\n        }\n        if (obj.action === \"removedPage\") {\n            const [page] = obj.data;\n            if (page === window.next.router.pathname) {\n                (0, _websocket).sendMessage(JSON.stringify({\n                    event: \"client-removed-page\",\n                    clientId: window.__nextDevClientId,\n                    page\n                }));\n                return window.location.reload();\n            }\n            return;\n        }\n        if (obj.action === \"addedPage\") {\n            const [page1] = obj.data;\n            if (page1 === window.next.router.pathname && typeof window.next.router.components[page1] === \"undefined\") {\n                (0, _websocket).sendMessage(JSON.stringify({\n                    event: \"client-added-page\",\n                    clientId: window.__nextDevClientId,\n                    page: page1\n                }));\n                return window.location.reload();\n            }\n            return;\n        }\n        throw new Error(\"Unexpected action \" + obj.action);\n    });\n    return devClient;\n};\nexports[\"default\"] = _default;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=webpack-hot-middleware-client.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvd2VicGFjay1ob3QtbWlkZGxld2FyZS1jbGllbnQuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsa0JBQWUsR0FBRyxLQUFLO0FBQ3ZCLElBQUlHLDJCQUEyQkMsbUpBQStEO0FBQzlGLElBQUlDLGdCQUFnQkYseUJBQXlCQyxtQkFBT0EsQ0FBQywyR0FBZ0M7QUFDckYsSUFBSUUsYUFBYUYsbUJBQU9BLENBQUMsaUdBQTJCO0FBQ3BELElBQUlHLFdBQVcsSUFBSTtJQUNmLE1BQU1DLFlBQVksQ0FBQyxHQUFHSCxhQUFhLEVBQUVILE9BQU87SUFDNUNNLFVBQVVDLG1CQUFtQixDQUFDLENBQUNDLE1BQU07UUFDakMsSUFBSUEsSUFBSUMsTUFBTSxLQUFLLGNBQWM7WUFDNUIsSUFBR0wsVUFBVSxFQUFFTSxXQUFXLENBQUNDLEtBQUtDLFNBQVMsQ0FBQztnQkFDdkNDLE9BQU87Z0JBQ1BDLFVBQVVDLE9BQU9DLGlCQUFpQjtZQUN0QztZQUNBLE9BQU9ELE9BQU9FLFFBQVEsQ0FBQ0MsTUFBTTtRQUNqQyxDQUFDO1FBQ0QsSUFBSVYsSUFBSUMsTUFBTSxLQUFLLGVBQWU7WUFDOUIsTUFBTSxDQUFDVSxLQUFLLEdBQUdYLElBQUlZLElBQUk7WUFDdkIsSUFBSUQsU0FBU0osT0FBT00sSUFBSSxDQUFDQyxNQUFNLENBQUNDLFFBQVEsRUFBRTtnQkFDckMsSUFBR25CLFVBQVUsRUFBRU0sV0FBVyxDQUFDQyxLQUFLQyxTQUFTLENBQUM7b0JBQ3ZDQyxPQUFPO29CQUNQQyxVQUFVQyxPQUFPQyxpQkFBaUI7b0JBQ2xDRztnQkFDSjtnQkFDQSxPQUFPSixPQUFPRSxRQUFRLENBQUNDLE1BQU07WUFDakMsQ0FBQztZQUNEO1FBQ0osQ0FBQztRQUNELElBQUlWLElBQUlDLE1BQU0sS0FBSyxhQUFhO1lBQzVCLE1BQU0sQ0FBQ1UsTUFBSyxHQUFHWCxJQUFJWSxJQUFJO1lBQ3ZCLElBQUlELFVBQVNKLE9BQU9NLElBQUksQ0FBQ0MsTUFBTSxDQUFDQyxRQUFRLElBQUksT0FBT1IsT0FBT00sSUFBSSxDQUFDQyxNQUFNLENBQUNFLFVBQVUsQ0FBQ0wsTUFBSyxLQUFLLGFBQWE7Z0JBQ25HLElBQUdmLFVBQVUsRUFBRU0sV0FBVyxDQUFDQyxLQUFLQyxTQUFTLENBQUM7b0JBQ3ZDQyxPQUFPO29CQUNQQyxVQUFVQyxPQUFPQyxpQkFBaUI7b0JBQ2xDRyxNQUFBQTtnQkFDSjtnQkFDQSxPQUFPSixPQUFPRSxRQUFRLENBQUNDLE1BQU07WUFDakMsQ0FBQztZQUNEO1FBQ0osQ0FBQztRQUNELE1BQU0sSUFBSU8sTUFBTSx1QkFBdUJqQixJQUFJQyxNQUFNLEVBQUU7SUFDdkQ7SUFDQSxPQUFPSDtBQUNYO0FBQ0FSLGtCQUFlLEdBQUdPO0FBRWxCLElBQUksQ0FBQyxPQUFPUCxRQUFRRSxPQUFPLEtBQUssY0FBZSxPQUFPRixRQUFRRSxPQUFPLEtBQUssWUFBWUYsUUFBUUUsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPRixRQUFRRSxPQUFPLENBQUMwQixVQUFVLEtBQUssYUFBYTtJQUNySzlCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUUUsT0FBTyxFQUFFLGNBQWM7UUFBRUQsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU8rQixNQUFNLENBQUM3QixRQUFRRSxPQUFPLEVBQUVGO0lBQy9COEIsT0FBTzlCLE9BQU8sR0FBR0EsUUFBUUUsT0FBTztBQUNsQyxDQUFDLENBRUQseURBQXlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2Rldi93ZWJwYWNrLWhvdC1taWRkbGV3YXJlLWNsaWVudC5qcz85YWQyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5qc1wiKS5kZWZhdWx0O1xudmFyIF9ob3REZXZDbGllbnQgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcIi4vZXJyb3Itb3ZlcmxheS9ob3QtZGV2LWNsaWVudFwiKSk7XG52YXIgX3dlYnNvY2tldCA9IHJlcXVpcmUoXCIuL2Vycm9yLW92ZXJsYXkvd2Vic29ja2V0XCIpO1xudmFyIF9kZWZhdWx0ID0gKCk9PntcbiAgICBjb25zdCBkZXZDbGllbnQgPSAoMCwgX2hvdERldkNsaWVudCkuZGVmYXVsdCgpO1xuICAgIGRldkNsaWVudC5zdWJzY3JpYmVUb0htckV2ZW50KChvYmopPT57XG4gICAgICAgIGlmIChvYmouYWN0aW9uID09PSAncmVsb2FkUGFnZScpIHtcbiAgICAgICAgICAgICgwLCBfd2Vic29ja2V0KS5zZW5kTWVzc2FnZShKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgZXZlbnQ6ICdjbGllbnQtcmVsb2FkLXBhZ2UnLFxuICAgICAgICAgICAgICAgIGNsaWVudElkOiB3aW5kb3cuX19uZXh0RGV2Q2xpZW50SWRcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iai5hY3Rpb24gPT09ICdyZW1vdmVkUGFnZScpIHtcbiAgICAgICAgICAgIGNvbnN0IFtwYWdlXSA9IG9iai5kYXRhO1xuICAgICAgICAgICAgaWYgKHBhZ2UgPT09IHdpbmRvdy5uZXh0LnJvdXRlci5wYXRobmFtZSkge1xuICAgICAgICAgICAgICAgICgwLCBfd2Vic29ja2V0KS5zZW5kTWVzc2FnZShKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiAnY2xpZW50LXJlbW92ZWQtcGFnZScsXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudElkOiB3aW5kb3cuX19uZXh0RGV2Q2xpZW50SWQsXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLmFjdGlvbiA9PT0gJ2FkZGVkUGFnZScpIHtcbiAgICAgICAgICAgIGNvbnN0IFtwYWdlXSA9IG9iai5kYXRhO1xuICAgICAgICAgICAgaWYgKHBhZ2UgPT09IHdpbmRvdy5uZXh0LnJvdXRlci5wYXRobmFtZSAmJiB0eXBlb2Ygd2luZG93Lm5leHQucm91dGVyLmNvbXBvbmVudHNbcGFnZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgKDAsIF93ZWJzb2NrZXQpLnNlbmRNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6ICdjbGllbnQtYWRkZWQtcGFnZScsXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudElkOiB3aW5kb3cuX19uZXh0RGV2Q2xpZW50SWQsXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgYWN0aW9uICcgKyBvYmouYWN0aW9uKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGV2Q2xpZW50O1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWJwYWNrLWhvdC1taWRkbGV3YXJlLWNsaWVudC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsIl9ob3REZXZDbGllbnQiLCJfd2Vic29ja2V0IiwiX2RlZmF1bHQiLCJkZXZDbGllbnQiLCJzdWJzY3JpYmVUb0htckV2ZW50Iiwib2JqIiwiYWN0aW9uIiwic2VuZE1lc3NhZ2UiLCJKU09OIiwic3RyaW5naWZ5IiwiZXZlbnQiLCJjbGllbnRJZCIsIndpbmRvdyIsIl9fbmV4dERldkNsaWVudElkIiwibG9jYXRpb24iLCJyZWxvYWQiLCJwYWdlIiwiZGF0YSIsIm5leHQiLCJyb3V0ZXIiLCJwYXRobmFtZSIsImNvbXBvbmVudHMiLCJFcnJvciIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/dev/webpack-hot-middleware-client.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/has-base-path.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/client/has-base-path.js ***!
  \********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.hasBasePath = hasBasePath;\nvar _pathHasPrefix = __webpack_require__(/*! ../shared/lib/router/utils/path-has-prefix */ \"./node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js\");\nconst basePath =  false || \"\";\nfunction hasBasePath(path) {\n    return (0, _pathHasPrefix).pathHasPrefix(path, basePath);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=has-base-path.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9oYXMtYmFzZS1wYXRoLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELG1CQUFtQixHQUFHRTtBQUN0QixJQUFJQyxpQkFBaUJDLG1CQUFPQSxDQUFDLHVIQUE0QztBQUN6RSxNQUFNQyxXQUFXQyxNQUFrQyxJQUFJO0FBQ3ZELFNBQVNKLFlBQVlPLElBQUksRUFBRTtJQUN2QixPQUFPLENBQUMsR0FBR04sY0FBYyxFQUFFTyxhQUFhLENBQUNELE1BQU1KO0FBQ25EO0FBRUEsSUFBSSxDQUFDLE9BQU9MLFFBQVFXLE9BQU8sS0FBSyxjQUFlLE9BQU9YLFFBQVFXLE9BQU8sS0FBSyxZQUFZWCxRQUFRVyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9YLFFBQVFXLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktkLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUVcsT0FBTyxFQUFFLGNBQWM7UUFBRVYsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9lLE1BQU0sQ0FBQ2IsUUFBUVcsT0FBTyxFQUFFWDtJQUMvQmMsT0FBT2QsT0FBTyxHQUFHQSxRQUFRVyxPQUFPO0FBQ2xDLENBQUMsQ0FFRCx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvaGFzLWJhc2UtcGF0aC5qcz81YTQ5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5oYXNCYXNlUGF0aCA9IGhhc0Jhc2VQYXRoO1xudmFyIF9wYXRoSGFzUHJlZml4ID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3BhdGgtaGFzLXByZWZpeFwiKTtcbmNvbnN0IGJhc2VQYXRoID0gcHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CQVNFUEFUSCB8fCAnJztcbmZ1bmN0aW9uIGhhc0Jhc2VQYXRoKHBhdGgpIHtcbiAgICByZXR1cm4gKDAsIF9wYXRoSGFzUHJlZml4KS5wYXRoSGFzUHJlZml4KHBhdGgsIGJhc2VQYXRoKTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzLWJhc2UtcGF0aC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJoYXNCYXNlUGF0aCIsIl9wYXRoSGFzUHJlZml4IiwicmVxdWlyZSIsImJhc2VQYXRoIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9ST1VURVJfQkFTRVBBVEgiLCJwYXRoIiwicGF0aEhhc1ByZWZpeCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/has-base-path.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/head-manager.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/head-manager.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = initHeadManager;\nexports.isEqualNode = isEqualNode;\nexports.DOMAttributeNames = void 0;\nfunction initHeadManager() {\n    return {\n        mountedInstances: new Set(),\n        updateHead: (head)=>{\n            const tags = {};\n            head.forEach((h)=>{\n                if (// it won't be inlined. In this case revert to the original behavior\n                h.type === \"link\" && h.props[\"data-optimized-fonts\"]) {\n                    if (document.querySelector('style[data-href=\"'.concat(h.props[\"data-href\"], '\"]'))) {\n                        return;\n                    } else {\n                        h.props.href = h.props[\"data-href\"];\n                        h.props[\"data-href\"] = undefined;\n                    }\n                }\n                const components = tags[h.type] || [];\n                components.push(h);\n                tags[h.type] = components;\n            });\n            const titleComponent = tags.title ? tags.title[0] : null;\n            let title = \"\";\n            if (titleComponent) {\n                const { children  } = titleComponent.props;\n                title = typeof children === \"string\" ? children : Array.isArray(children) ? children.join(\"\") : \"\";\n            }\n            if (title !== document.title) document.title = title;\n            [\n                \"meta\",\n                \"base\",\n                \"link\",\n                \"style\",\n                \"script\"\n            ].forEach((type)=>{\n                updateElements(type, tags[type] || []);\n            });\n        }\n    };\n}\nconst DOMAttributeNames = {\n    acceptCharset: \"accept-charset\",\n    className: \"class\",\n    htmlFor: \"for\",\n    httpEquiv: \"http-equiv\",\n    noModule: \"noModule\"\n};\nexports.DOMAttributeNames = DOMAttributeNames;\nfunction reactElementToDOM(param) {\n    let { type , props  } = param;\n    const el = document.createElement(type);\n    for(const p in props){\n        if (!props.hasOwnProperty(p)) continue;\n        if (p === \"children\" || p === \"dangerouslySetInnerHTML\") continue;\n        // we don't render undefined props to the DOM\n        if (props[p] === undefined) continue;\n        const attr = DOMAttributeNames[p] || p.toLowerCase();\n        if (type === \"script\" && (attr === \"async\" || attr === \"defer\" || attr === \"noModule\")) {\n            el[attr] = !!props[p];\n        } else {\n            el.setAttribute(attr, props[p]);\n        }\n    }\n    const { children , dangerouslySetInnerHTML  } = props;\n    if (dangerouslySetInnerHTML) {\n        el.innerHTML = dangerouslySetInnerHTML.__html || \"\";\n    } else if (children) {\n        el.textContent = typeof children === \"string\" ? children : Array.isArray(children) ? children.join(\"\") : \"\";\n    }\n    return el;\n}\nfunction isEqualNode(oldTag, newTag) {\n    if (oldTag instanceof HTMLElement && newTag instanceof HTMLElement) {\n        const nonce = newTag.getAttribute(\"nonce\");\n        // Only strip the nonce if `oldTag` has had it stripped. An element's nonce attribute will not\n        // be stripped if there is no content security policy response header that includes a nonce.\n        if (nonce && !oldTag.getAttribute(\"nonce\")) {\n            const cloneTag = newTag.cloneNode(true);\n            cloneTag.setAttribute(\"nonce\", \"\");\n            cloneTag.nonce = nonce;\n            return nonce === oldTag.nonce && oldTag.isEqualNode(cloneTag);\n        }\n    }\n    return oldTag.isEqualNode(newTag);\n}\nfunction updateElements(type, components) {\n    const headEl = document.getElementsByTagName(\"head\")[0];\n    const headCountEl = headEl.querySelector(\"meta[name=next-head-count]\");\n    if (true) {\n        if (!headCountEl) {\n            console.error(\"Warning: next-head-count is missing. https://nextjs.org/docs/messages/next-head-count-missing\");\n            return;\n        }\n    }\n    const headCount = Number(headCountEl.content);\n    const oldTags = [];\n    for(let i = 0, j = headCountEl.previousElementSibling; i < headCount; i++, j = (j == null ? void 0 : j.previousElementSibling) || null){\n        var ref;\n        if ((j == null ? void 0 : (ref = j.tagName) == null ? void 0 : ref.toLowerCase()) === type) {\n            oldTags.push(j);\n        }\n    }\n    const newTags = components.map(reactElementToDOM).filter((newTag)=>{\n        for(let k = 0, len = oldTags.length; k < len; k++){\n            const oldTag = oldTags[k];\n            if (isEqualNode(oldTag, newTag)) {\n                oldTags.splice(k, 1);\n                return false;\n            }\n        }\n        return true;\n    });\n    oldTags.forEach((t)=>{\n        var ref;\n        return (ref = t.parentNode) == null ? void 0 : ref.removeChild(t);\n    });\n    newTags.forEach((t)=>headEl.insertBefore(t, headCountEl));\n    headCountEl.content = (headCount - oldTags.length + newTags.length).toString();\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=head-manager.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9oZWFkLW1hbmFnZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsa0JBQWUsR0FBR0c7QUFDbEJILG1CQUFtQixHQUFHSTtBQUN0QkoseUJBQXlCLEdBQUcsS0FBSztBQUNqQyxTQUFTRyxrQkFBa0I7SUFDdkIsT0FBTztRQUNIRyxrQkFBa0IsSUFBSUM7UUFDdEJDLFlBQVksQ0FBQ0MsT0FBTztZQUNoQixNQUFNQyxPQUFPLENBQUM7WUFDZEQsS0FBS0UsT0FBTyxDQUFDLENBQUNDLElBQUk7Z0JBQ2QsSUFDQSxvRUFBb0U7Z0JBQ3BFQSxFQUFFQyxJQUFJLEtBQUssVUFBVUQsRUFBRUUsS0FBSyxDQUFDLHVCQUF1QixFQUFFO29CQUNsRCxJQUFJQyxTQUFTQyxhQUFhLENBQUMsb0JBQXlDLE9BQXJCSixFQUFFRSxLQUFLLENBQUMsWUFBWSxFQUFDLFFBQU07d0JBQ3RFO29CQUNKLE9BQU87d0JBQ0hGLEVBQUVFLEtBQUssQ0FBQ0csSUFBSSxHQUFHTCxFQUFFRSxLQUFLLENBQUMsWUFBWTt3QkFDbkNGLEVBQUVFLEtBQUssQ0FBQyxZQUFZLEdBQUdJO29CQUMzQixDQUFDO2dCQUNMLENBQUM7Z0JBQ0QsTUFBTUMsYUFBYVQsSUFBSSxDQUFDRSxFQUFFQyxJQUFJLENBQUMsSUFBSSxFQUFFO2dCQUNyQ00sV0FBV0MsSUFBSSxDQUFDUjtnQkFDaEJGLElBQUksQ0FBQ0UsRUFBRUMsSUFBSSxDQUFDLEdBQUdNO1lBQ25CO1lBQ0EsTUFBTUUsaUJBQWlCWCxLQUFLWSxLQUFLLEdBQUdaLEtBQUtZLEtBQUssQ0FBQyxFQUFFLEdBQUcsSUFBSTtZQUN4RCxJQUFJQSxRQUFRO1lBQ1osSUFBSUQsZ0JBQWdCO2dCQUNoQixNQUFNLEVBQUVFLFNBQVEsRUFBRyxHQUFHRixlQUFlUCxLQUFLO2dCQUMxQ1EsUUFBUSxPQUFPQyxh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LENBQUMsT0FBTzlFLFFBQVFFLE9BQU8sS0FBSyxjQUFlLE9BQU9GLFFBQVFFLE9BQU8sS0FBSyxZQUFZRixRQUFRRSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9GLFFBQVFFLE9BQU8sQ0FBQzZFLFVBQVUsS0FBSyxhQUFhO0lBQ3JLakYsT0FBT0MsY0FBYyxDQUFDQyxRQUFRRSxPQUFPLEVBQUUsY0FBYztRQUFFRCxPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT2tGLE1BQU0sQ0FBQ2hGLFFBQVFFLE9BQU8sRUFBRUY7SUFDL0JpRixPQUFPakYsT0FBTyxHQUFHQSxRQUFRRSxPQUFPO0FBQ2xDLENBQUMsQ0FFRCx3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvaGVhZC1tYW5hZ2VyLmpzP2NhNGEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpbml0SGVhZE1hbmFnZXI7XG5leHBvcnRzLmlzRXF1YWxOb2RlID0gaXNFcXVhbE5vZGU7XG5leHBvcnRzLkRPTUF0dHJpYnV0ZU5hbWVzID0gdm9pZCAwO1xuZnVuY3Rpb24gaW5pdEhlYWRNYW5hZ2VyKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG1vdW50ZWRJbnN0YW5jZXM6IG5ldyBTZXQoKSxcbiAgICAgICAgdXBkYXRlSGVhZDogKGhlYWQpPT57XG4gICAgICAgICAgICBjb25zdCB0YWdzID0ge307XG4gICAgICAgICAgICBoZWFkLmZvckVhY2goKGgpPT57XG4gICAgICAgICAgICAgICAgaWYgKC8vIElmIHRoZSBmb250IHRhZyBpcyBsb2FkZWQgb25seSBvbiBjbGllbnQgbmF2aWdhdGlvblxuICAgICAgICAgICAgICAgIC8vIGl0IHdvbid0IGJlIGlubGluZWQuIEluIHRoaXMgY2FzZSByZXZlcnQgdG8gdGhlIG9yaWdpbmFsIGJlaGF2aW9yXG4gICAgICAgICAgICAgICAgaC50eXBlID09PSAnbGluaycgJiYgaC5wcm9wc1snZGF0YS1vcHRpbWl6ZWQtZm9udHMnXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihgc3R5bGVbZGF0YS1ocmVmPVwiJHtoLnByb3BzWydkYXRhLWhyZWYnXX1cIl1gKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaC5wcm9wcy5ocmVmID0gaC5wcm9wc1snZGF0YS1ocmVmJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBoLnByb3BzWydkYXRhLWhyZWYnXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjb21wb25lbnRzID0gdGFnc1toLnR5cGVdIHx8IFtdO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChoKTtcbiAgICAgICAgICAgICAgICB0YWdzW2gudHlwZV0gPSBjb21wb25lbnRzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB0aXRsZUNvbXBvbmVudCA9IHRhZ3MudGl0bGUgPyB0YWdzLnRpdGxlWzBdIDogbnVsbDtcbiAgICAgICAgICAgIGxldCB0aXRsZSA9ICcnO1xuICAgICAgICAgICAgaWYgKHRpdGxlQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjaGlsZHJlbiAgfSA9IHRpdGxlQ29tcG9uZW50LnByb3BzO1xuICAgICAgICAgICAgICAgIHRpdGxlID0gdHlwZW9mIGNoaWxkcmVuID09PSAnc3RyaW5nJyA/IGNoaWxkcmVuIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlbi5qb2luKCcnKSA6ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpdGxlICE9PSBkb2N1bWVudC50aXRsZSkgZG9jdW1lbnQudGl0bGUgPSB0aXRsZTtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnbWV0YScsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnLFxuICAgICAgICAgICAgICAgICdsaW5rJyxcbiAgICAgICAgICAgICAgICAnc3R5bGUnLFxuICAgICAgICAgICAgICAgICdzY3JpcHQnXG4gICAgICAgICAgICBdLmZvckVhY2goKHR5cGUpPT57XG4gICAgICAgICAgICAgICAgdXBkYXRlRWxlbWVudHModHlwZSwgdGFnc1t0eXBlXSB8fCBbXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5jb25zdCBET01BdHRyaWJ1dGVOYW1lcyA9IHtcbiAgICBhY2NlcHRDaGFyc2V0OiAnYWNjZXB0LWNoYXJzZXQnLFxuICAgIGNsYXNzTmFtZTogJ2NsYXNzJyxcbiAgICBodG1sRm9yOiAnZm9yJyxcbiAgICBodHRwRXF1aXY6ICdodHRwLWVxdWl2JyxcbiAgICBub01vZHVsZTogJ25vTW9kdWxlJ1xufTtcbmV4cG9ydHMuRE9NQXR0cmlidXRlTmFtZXMgPSBET01BdHRyaWJ1dGVOYW1lcztcbmZ1bmN0aW9uIHJlYWN0RWxlbWVudFRvRE9NKHsgdHlwZSAsIHByb3BzICB9KSB7XG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUpO1xuICAgIGZvcihjb25zdCBwIGluIHByb3BzKXtcbiAgICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShwKSkgY29udGludWU7XG4gICAgICAgIGlmIChwID09PSAnY2hpbGRyZW4nIHx8IHAgPT09ICdkYW5nZXJvdXNseVNldElubmVySFRNTCcpIGNvbnRpbnVlO1xuICAgICAgICAvLyB3ZSBkb24ndCByZW5kZXIgdW5kZWZpbmVkIHByb3BzIHRvIHRoZSBET01cbiAgICAgICAgaWYgKHByb3BzW3BdID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBhdHRyID0gRE9NQXR0cmlidXRlTmFtZXNbcF0gfHwgcC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3NjcmlwdCcgJiYgKGF0dHIgPT09ICdhc3luYycgfHwgYXR0ciA9PT0gJ2RlZmVyJyB8fCBhdHRyID09PSAnbm9Nb2R1bGUnKSkge1xuICAgICAgICAgICAgZWxbYXR0cl0gPSAhIXByb3BzW3BdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHIsIHByb3BzW3BdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7IGNoaWxkcmVuICwgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIH0gPSBwcm9wcztcbiAgICBpZiAoZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpIHtcbiAgICAgICAgZWwuaW5uZXJIVE1MID0gZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sIHx8ICcnO1xuICAgIH0gZWxzZSBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgZWwudGV4dENvbnRlbnQgPSB0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnID8gY2hpbGRyZW4gOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSA/IGNoaWxkcmVuLmpvaW4oJycpIDogJyc7XG4gICAgfVxuICAgIHJldHVybiBlbDtcbn1cbmZ1bmN0aW9uIGlzRXF1YWxOb2RlKG9sZFRhZywgbmV3VGFnKSB7XG4gICAgaWYgKG9sZFRhZyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIG5ld1RhZyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IG5vbmNlID0gbmV3VGFnLmdldEF0dHJpYnV0ZSgnbm9uY2UnKTtcbiAgICAgICAgLy8gT25seSBzdHJpcCB0aGUgbm9uY2UgaWYgYG9sZFRhZ2AgaGFzIGhhZCBpdCBzdHJpcHBlZC4gQW4gZWxlbWVudCdzIG5vbmNlIGF0dHJpYnV0ZSB3aWxsIG5vdFxuICAgICAgICAvLyBiZSBzdHJpcHBlZCBpZiB0aGVyZSBpcyBubyBjb250ZW50IHNlY3VyaXR5IHBvbGljeSByZXNwb25zZSBoZWFkZXIgdGhhdCBpbmNsdWRlcyBhIG5vbmNlLlxuICAgICAgICBpZiAobm9uY2UgJiYgIW9sZFRhZy5nZXRBdHRyaWJ1dGUoJ25vbmNlJykpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsb25lVGFnID0gbmV3VGFnLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgICAgIGNsb25lVGFnLnNldEF0dHJpYnV0ZSgnbm9uY2UnLCAnJyk7XG4gICAgICAgICAgICBjbG9uZVRhZy5ub25jZSA9IG5vbmNlO1xuICAgICAgICAgICAgcmV0dXJuIG5vbmNlID09PSBvbGRUYWcubm9uY2UgJiYgb2xkVGFnLmlzRXF1YWxOb2RlKGNsb25lVGFnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2xkVGFnLmlzRXF1YWxOb2RlKG5ld1RhZyk7XG59XG5mdW5jdGlvbiB1cGRhdGVFbGVtZW50cyh0eXBlLCBjb21wb25lbnRzKSB7XG4gICAgY29uc3QgaGVhZEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICBjb25zdCBoZWFkQ291bnRFbCA9IGhlYWRFbC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9bmV4dC1oZWFkLWNvdW50XScpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICghaGVhZENvdW50RWwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1dhcm5pbmc6IG5leHQtaGVhZC1jb3VudCBpcyBtaXNzaW5nLiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWhlYWQtY291bnQtbWlzc2luZycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGhlYWRDb3VudCA9IE51bWJlcihoZWFkQ291bnRFbC5jb250ZW50KTtcbiAgICBjb25zdCBvbGRUYWdzID0gW107XG4gICAgZm9yKGxldCBpID0gMCwgaiA9IGhlYWRDb3VudEVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7IGkgPCBoZWFkQ291bnQ7IGkrKywgaiA9IChqID09IG51bGwgPyB2b2lkIDAgOiBqLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpIHx8IG51bGwpe1xuICAgICAgICB2YXIgcmVmO1xuICAgICAgICBpZiAoKGogPT0gbnVsbCA/IHZvaWQgMCA6IChyZWYgPSBqLnRhZ05hbWUpID09IG51bGwgPyB2b2lkIDAgOiByZWYudG9Mb3dlckNhc2UoKSkgPT09IHR5cGUpIHtcbiAgICAgICAgICAgIG9sZFRhZ3MucHVzaChqKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBuZXdUYWdzID0gY29tcG9uZW50cy5tYXAocmVhY3RFbGVtZW50VG9ET00pLmZpbHRlcigobmV3VGFnKT0+e1xuICAgICAgICBmb3IobGV0IGsgPSAwLCBsZW4gPSBvbGRUYWdzLmxlbmd0aDsgayA8IGxlbjsgaysrKXtcbiAgICAgICAgICAgIGNvbnN0IG9sZFRhZyA9IG9sZFRhZ3Nba107XG4gICAgICAgICAgICBpZiAoaXNFcXVhbE5vZGUob2xkVGFnLCBuZXdUYWcpKSB7XG4gICAgICAgICAgICAgICAgb2xkVGFncy5zcGxpY2UoaywgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIG9sZFRhZ3MuZm9yRWFjaCgodCk9PntcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgcmV0dXJuIChyZWYgPSB0LnBhcmVudE5vZGUpID09IG51bGwgPyB2b2lkIDAgOiByZWYucmVtb3ZlQ2hpbGQodCk7XG4gICAgfSk7XG4gICAgbmV3VGFncy5mb3JFYWNoKCh0KT0+aGVhZEVsLmluc2VydEJlZm9yZSh0LCBoZWFkQ291bnRFbCkpO1xuICAgIGhlYWRDb3VudEVsLmNvbnRlbnQgPSAoaGVhZENvdW50IC0gb2xkVGFncy5sZW5ndGggKyBuZXdUYWdzLmxlbmd0aCkudG9TdHJpbmcoKTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVhZC1tYW5hZ2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHQiLCJpbml0SGVhZE1hbmFnZXIiLCJpc0VxdWFsTm9kZSIsIkRPTUF0dHJpYnV0ZU5hbWVzIiwibW91bnRlZEluc3RhbmNlcyIsIlNldCIsInVwZGF0ZUhlYWQiLCJoZWFkIiwidGFncyIsImZvckVhY2giLCJoIiwidHlwZSIsInByb3BzIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwiaHJlZiIsInVuZGVmaW5lZCIsImNvbXBvbmVudHMiLCJwdXNoIiwidGl0bGVDb21wb25lbnQiLCJ0aXRsZSIsImNoaWxkcmVuIiwiQXJyYXkiLCJpc0FycmF5Iiwiam9pbiIsInVwZGF0ZUVsZW1lbnRzIiwiYWNjZXB0Q2hhcnNldCIsImNsYXNzTmFtZSIsImh0bWxGb3IiLCJodHRwRXF1aXYiLCJub01vZHVsZSIsInJlYWN0RWxlbWVudFRvRE9NIiwiZWwiLCJjcmVhdGVFbGVtZW50IiwicCIsImhhc093blByb3BlcnR5IiwiYXR0ciIsInRvTG93ZXJDYXNlIiwic2V0QXR0cmlidXRlIiwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCJpbm5lckhUTUwiLCJfX2h0bWwiLCJ0ZXh0Q29udGVudCIsIm9sZFRhZyIsIm5ld1RhZyIsIkhUTUxFbGVtZW50Iiwibm9uY2UiLCJnZXRBdHRyaWJ1dGUiLCJjbG9uZVRhZyIsImNsb25lTm9kZSIsImhlYWRFbCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiaGVhZENvdW50RWwiLCJwcm9jZXNzIiwiY29uc29sZSIsImVycm9yIiwiaGVhZENvdW50IiwiTnVtYmVyIiwiY29udGVudCIsIm9sZFRhZ3MiLCJpIiwiaiIsInByZXZpb3VzRWxlbWVudFNpYmxpbmciLCJyZWYiLCJ0YWdOYW1lIiwibmV3VGFncyIsIm1hcCIsImZpbHRlciIsImsiLCJsZW4iLCJsZW5ndGgiLCJzcGxpY2UiLCJ0IiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiaW5zZXJ0QmVmb3JlIiwidG9TdHJpbmciLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/head-manager.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/index.js":
/*!************************************************!*\
  !*** ./node_modules/next/dist/client/index.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst _interopRequireWildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.initialize = initialize;\nexports.hydrate = hydrate;\nexports.emitter = exports.router = exports.version = void 0;\nvar _async_to_generator = (__webpack_require__(/*! @swc/helpers/lib/_async_to_generator.js */ \"./node_modules/@swc/helpers/lib/_async_to_generator.js\")[\"default\"]);\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\n__webpack_require__(/*! ../build/polyfills/polyfill-module */ \"./node_modules/next/dist/build/polyfills/polyfill-module.js\");\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar _client = _interop_require_default(__webpack_require__(/*! react-dom/client */ \"./node_modules/react-dom/client.js\"));\nvar _headManagerContext = __webpack_require__(/*! ../shared/lib/head-manager-context */ \"./node_modules/next/dist/shared/lib/head-manager-context.js\");\nvar _mitt = _interop_require_default(__webpack_require__(/*! ../shared/lib/mitt */ \"./node_modules/next/dist/shared/lib/mitt.js\"));\nvar _routerContext = __webpack_require__(/*! ../shared/lib/router-context */ \"./node_modules/next/dist/shared/lib/router-context.js\");\nvar _isDynamic = __webpack_require__(/*! ../shared/lib/router/utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nvar _querystring = __webpack_require__(/*! ../shared/lib/router/utils/querystring */ \"./node_modules/next/dist/shared/lib/router/utils/querystring.js\");\nvar _runtimeConfig = __webpack_require__(/*! ../shared/lib/runtime-config */ \"./node_modules/next/dist/shared/lib/runtime-config.js\");\nvar _utils = __webpack_require__(/*! ../shared/lib/utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\nvar _portal = __webpack_require__(/*! ./portal */ \"./node_modules/next/dist/client/portal/index.js\");\nvar _headManager = _interop_require_default(__webpack_require__(/*! ./head-manager */ \"./node_modules/next/dist/client/head-manager.js\"));\nvar _pageLoader = _interop_require_default(__webpack_require__(/*! ./page-loader */ \"./node_modules/next/dist/client/page-loader.js\"));\nvar _performanceRelayer = _interop_require_default(__webpack_require__(/*! ./performance-relayer */ \"./node_modules/next/dist/client/performance-relayer.js\"));\nvar _routeAnnouncer = __webpack_require__(/*! ./route-announcer */ \"./node_modules/next/dist/client/route-announcer.js\");\nvar _router = __webpack_require__(/*! ./router */ \"./node_modules/next/dist/client/router.js\");\nvar _isError = __webpack_require__(/*! ../lib/is-error */ \"./node_modules/next/dist/lib/is-error.js\");\nvar _imageConfigContext = __webpack_require__(/*! ../shared/lib/image-config-context */ \"./node_modules/next/dist/shared/lib/image-config-context.js\");\nvar _removeBasePath = __webpack_require__(/*! ./remove-base-path */ \"./node_modules/next/dist/client/remove-base-path.js\");\nvar _hasBasePath = __webpack_require__(/*! ./has-base-path */ \"./node_modules/next/dist/client/has-base-path.js\");\nvar _appRouterContext = __webpack_require__(/*! ../shared/lib/app-router-context */ \"./node_modules/next/dist/shared/lib/app-router-context.js\");\nvar _adapters = __webpack_require__(/*! ../shared/lib/router/adapters */ \"./node_modules/next/dist/shared/lib/router/adapters.js\");\nvar _hooksClientContext = __webpack_require__(/*! ../shared/lib/hooks-client-context */ \"./node_modules/next/dist/shared/lib/hooks-client-context.js\");\nconst version = \"13.0.3\";\nexports.version = version;\nlet router;\nexports.router = router;\nconst emitter = (0, _mitt).default();\nexports.emitter = emitter;\nconst looseToArray = (input)=>[].slice.call(input);\nlet initialData;\nlet defaultLocale = undefined;\nlet asPath;\nlet pageLoader;\nlet appElement;\nlet headManager;\nlet initialMatchesMiddleware = false;\nlet lastAppProps;\nlet lastRenderReject;\nlet webpackHMR;\nlet CachedApp, onPerfEntry;\nlet CachedComponent;\nself.__next_require__ = __webpack_require__;\nclass Container extends _react.default.Component {\n    componentDidCatch(componentErr, info) {\n        this.props.fn(componentErr, info);\n    }\n    componentDidMount() {\n        this.scrollToHash();\n        // We need to replace the router state if:\n        // - the page was (auto) exported and has a query string or search (hash)\n        // - it was auto exported and is a dynamic route (to provide params)\n        // - if it is a client-side skeleton (fallback render)\n        // - if middleware matches the current page (may have rewrite params)\n        // - if rewrites in next.config.js match (may have rewrite params)\n        if (router.isSsr && // We don't update for 404 requests as this can modify\n        // the asPath unexpectedly e.g. adding basePath when\n        // it wasn't originally present\n        initialData.page !== \"/404\" && initialData.page !== \"/_error\" && (initialData.isFallback || initialData.nextExport && ((0, _isDynamic).isDynamicRoute(router.pathname) || location.search || false || initialMatchesMiddleware) || initialData.props && initialData.props.__N_SSG && (location.search || false || initialMatchesMiddleware))) {\n            // update query on mount for exported pages\n            router.replace(router.pathname + \"?\" + String((0, _querystring).assign((0, _querystring).urlQueryToSearchParams(router.query), new URLSearchParams(location.search))), asPath, {\n                // @ts-ignore\n                // WARNING: `_h` is an internal option for handing Next.js\n                // client-side hydration. Your app should _never_ use this property.\n                // It may change at any time without notice.\n                _h: 1,\n                // Fallback pages must trigger the data fetch, so the transition is\n                // not shallow.\n                // Other pages (strictly updating query) happens shallowly, as data\n                // requirements would already be present.\n                shallow: !initialData.isFallback && !initialMatchesMiddleware\n            }).catch((err)=>{\n                if (!err.cancelled) throw err;\n            });\n        }\n    }\n    componentDidUpdate() {\n        this.scrollToHash();\n    }\n    scrollToHash() {\n        let { hash  } = location;\n        hash = hash && hash.substring(1);\n        if (!hash) return;\n        const el = document.getElementById(hash);\n        if (!el) return;\n        // If we call scrollIntoView() in here without a setTimeout\n        // it won't scroll properly.\n        setTimeout(()=>el.scrollIntoView(), 0);\n    }\n    render() {\n        if (false) {} else {\n            const { ReactDevOverlay  } = __webpack_require__(/*! next/dist/compiled/@next/react-dev-overlay/dist/client */ \"./node_modules/next/dist/compiled/@next/react-dev-overlay/dist/client.js\");\n            return /*#__PURE__*/ _react.default.createElement(ReactDevOverlay, null, this.props.children);\n        }\n    }\n}\nfunction initialize() {\n    return _initialize.apply(this, arguments);\n}\nfunction _initialize() {\n    _initialize = _async_to_generator(function*() {\n        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        // This makes sure this specific lines are removed in production\n        if (true) {\n            webpackHMR = opts.webpackHMR;\n        }\n        initialData = JSON.parse(document.getElementById(\"__NEXT_DATA__\").textContent);\n        window.__NEXT_DATA__ = initialData;\n        defaultLocale = initialData.defaultLocale;\n        const prefix = initialData.assetPrefix || \"\";\n        // With dynamic assetPrefix it's no longer possible to set assetPrefix at the build time\n        // So, this is how we do it in the client side at runtime\n        __webpack_require__.p = \"\".concat(prefix, \"/_next/\") //eslint-disable-line\n        ;\n        // Initialize next/config with the environment configuration\n        (0, _runtimeConfig).setConfig({\n            serverRuntimeConfig: {},\n            publicRuntimeConfig: initialData.runtimeConfig || {}\n        });\n        asPath = (0, _utils).getURL();\n        // make sure not to attempt stripping basePath for 404s\n        if ((0, _hasBasePath).hasBasePath(asPath)) {\n            asPath = (0, _removeBasePath).removeBasePath(asPath);\n        }\n        if (false) {}\n        if (initialData.scriptLoader) {\n            const { initScriptLoader  } = __webpack_require__(/*! ./script */ \"./node_modules/next/dist/client/script.js\");\n            initScriptLoader(initialData.scriptLoader);\n        }\n        pageLoader = new _pageLoader.default(initialData.buildId, prefix);\n        const register = (param)=>{\n            let [r, f] = param;\n            return pageLoader.routeLoader.onEntrypoint(r, f);\n        };\n        if (window.__NEXT_P) {\n            // Defer page registration for another tick. This will increase the overall\n            // latency in hydrating the page, but reduce the total blocking time.\n            window.__NEXT_P.map((p)=>setTimeout(()=>register(p), 0));\n        }\n        window.__NEXT_P = [];\n        window.__NEXT_P.push = register;\n        headManager = (0, _headManager).default();\n        headManager.getIsSsr = ()=>{\n            return router.isSsr;\n        };\n        appElement = document.getElementById(\"__next\");\n        return {\n            assetPrefix: prefix\n        };\n    });\n    return _initialize.apply(this, arguments);\n}\nfunction renderApp(App, appProps) {\n    return /*#__PURE__*/ _react.default.createElement(App, Object.assign({}, appProps));\n}\nfunction AppContainer(param) {\n    let { children  } = param;\n    var _autoExport;\n    return /*#__PURE__*/ _react.default.createElement(Container, {\n        fn: (error)=>// eslint-disable-next-line @typescript-eslint/no-use-before-define\n            renderError({\n                App: CachedApp,\n                err: error\n            }).catch((err)=>console.error(\"Error rendering page: \", err))\n    }, /*#__PURE__*/ _react.default.createElement(_appRouterContext.AppRouterContext.Provider, {\n        value: (0, _adapters).adaptForAppRouterInstance(router)\n    }, /*#__PURE__*/ _react.default.createElement(_hooksClientContext.SearchParamsContext.Provider, {\n        value: (0, _adapters).adaptForSearchParams(router)\n    }, /*#__PURE__*/ _react.default.createElement(_adapters.PathnameContextProviderAdapter, {\n        router: router,\n        isAutoExport: (_autoExport = self.__NEXT_DATA__.autoExport) != null ? _autoExport : false\n    }, /*#__PURE__*/ _react.default.createElement(_routerContext.RouterContext.Provider, {\n        value: (0, _router).makePublicRouterInstance(router)\n    }, /*#__PURE__*/ _react.default.createElement(_headManagerContext.HeadManagerContext.Provider, {\n        value: headManager\n    }, /*#__PURE__*/ _react.default.createElement(_imageConfigContext.ImageConfigContext.Provider, {\n        value: {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[]}\n    }, children)))))));\n}\n_c = AppContainer;\nconst wrapApp = (App)=>(wrappedAppProps)=>{\n        const appProps = _extends({}, wrappedAppProps, {\n            Component: CachedComponent,\n            err: initialData.err,\n            router\n        });\n        return /*#__PURE__*/ _react.default.createElement(AppContainer, null, renderApp(App, appProps));\n    };\n// This method handles all runtime and debug errors.\n// 404 and 500 errors are special kind of errors\n// and they are still handle via the main render method.\nfunction renderError(renderErrorProps) {\n    let { App , err  } = renderErrorProps;\n    // In development runtime errors are caught by our overlay\n    // In production we catch runtime errors using componentDidCatch which will trigger renderError\n    if (true) {\n        // A Next.js rendering runtime error is always unrecoverable\n        // FIXME: let's make this recoverable (error in GIP client-transition)\n        webpackHMR.onUnrecoverableError();\n        // We need to render an empty <App> so that the `<ReactDevOverlay>` can\n        // render itself.\n        // TODO: Fix disabled eslint rule\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return doRender({\n            App: ()=>null,\n            props: {},\n            Component: ()=>null,\n            styleSheets: []\n        });\n    }\n    // Make sure we log the error to the console, otherwise users can't track down issues.\n    console.error(err);\n    console.error(\"A client-side exception has occurred, see here for more info: https://nextjs.org/docs/messages/client-side-exception-occurred\");\n    return pageLoader.loadPage(\"/_error\").then((param)=>{\n        let { page: ErrorComponent , styleSheets  } = param;\n        return (lastAppProps == null ? void 0 : lastAppProps.Component) === ErrorComponent ? Promise.resolve().then(()=>/*#__PURE__*/ _interopRequireWildcard(__webpack_require__(/*! ../pages/_error */ \"./node_modules/next/dist/pages/_error.js\"))).then((errorModule)=>{\n            return Promise.resolve().then(()=>/*#__PURE__*/ _interopRequireWildcard(__webpack_require__(/*! ../pages/_app */ \"./node_modules/next/dist/pages/_app.js\"))).then((appModule)=>{\n                App = appModule.default;\n                renderErrorProps.App = App;\n                return errorModule;\n            });\n        }).then((m)=>({\n                ErrorComponent: m.default,\n                styleSheets: []\n            })) : {\n            ErrorComponent,\n            styleSheets\n        };\n    }).then((param)=>{\n        let { ErrorComponent , styleSheets  } = param;\n        var ref;\n        // In production we do a normal render with the `ErrorComponent` as component.\n        // If we've gotten here upon initial render, we can use the props from the server.\n        // Otherwise, we need to call `getInitialProps` on `App` before mounting.\n        const AppTree = wrapApp(App);\n        const appCtx = {\n            Component: ErrorComponent,\n            AppTree,\n            router,\n            ctx: {\n                err,\n                pathname: initialData.page,\n                query: initialData.query,\n                asPath,\n                AppTree\n            }\n        };\n        return Promise.resolve(((ref = renderErrorProps.props) == null ? void 0 : ref.err) ? renderErrorProps.props : (0, _utils).loadGetInitialProps(App, appCtx)).then((initProps)=>// eslint-disable-next-line @typescript-eslint/no-use-before-define\n            doRender(_extends({}, renderErrorProps, {\n                err,\n                Component: ErrorComponent,\n                styleSheets,\n                props: initProps\n            })));\n    });\n}\n// Dummy component that we render as a child of Root so that we can\n// toggle the correct styles before the page is rendered.\nfunction Head(param) {\n    let { callback  } = param;\n    _s();\n    // We use `useLayoutEffect` to guarantee the callback is executed\n    // as soon as React flushes the update.\n    _react.default.useLayoutEffect(()=>callback(), [\n        callback\n    ]);\n    return null;\n}\n_s(Head, \"n7/vCynhJvM+pLkyL2DMQUF0odM=\");\n_c1 = Head;\nlet reactRoot = null;\n// On initial render a hydrate should always happen\nlet shouldHydrate = true;\nfunction clearMarks() {\n    [\n        \"beforeRender\",\n        \"afterHydrate\",\n        \"afterRender\",\n        \"routeChange\"\n    ].forEach((mark)=>performance.clearMarks(mark));\n}\nfunction markHydrateComplete() {\n    if (!_utils.ST) return;\n    performance.mark(\"afterHydrate\") // mark end of hydration\n    ;\n    performance.measure(\"Next.js-before-hydration\", \"navigationStart\", \"beforeRender\");\n    performance.measure(\"Next.js-hydration\", \"beforeRender\", \"afterHydrate\");\n    if (onPerfEntry) {\n        performance.getEntriesByName(\"Next.js-hydration\").forEach(onPerfEntry);\n    }\n    clearMarks();\n}\nfunction markRenderComplete() {\n    if (!_utils.ST) return;\n    performance.mark(\"afterRender\") // mark end of render\n    ;\n    const navStartEntries = performance.getEntriesByName(\"routeChange\", \"mark\");\n    if (!navStartEntries.length) return;\n    performance.measure(\"Next.js-route-change-to-render\", navStartEntries[0].name, \"beforeRender\");\n    performance.measure(\"Next.js-render\", \"beforeRender\", \"afterRender\");\n    if (onPerfEntry) {\n        performance.getEntriesByName(\"Next.js-render\").forEach(onPerfEntry);\n        performance.getEntriesByName(\"Next.js-route-change-to-render\").forEach(onPerfEntry);\n    }\n    clearMarks();\n    [\n        \"Next.js-route-change-to-render\",\n        \"Next.js-render\"\n    ].forEach((measure)=>performance.clearMeasures(measure));\n}\nfunction renderReactElement(domEl, fn) {\n    // mark start of hydrate/render\n    if (_utils.ST) {\n        performance.mark(\"beforeRender\");\n    }\n    const reactEl = fn(shouldHydrate ? markHydrateComplete : markRenderComplete);\n    if (!reactRoot) {\n        // Unlike with createRoot, you don't need a separate root.render() call here\n        reactRoot = _client.default.hydrateRoot(domEl, reactEl);\n        // TODO: Remove shouldHydrate variable when React 18 is stable as it can depend on `reactRoot` existing\n        shouldHydrate = false;\n    } else {\n        const startTransition = _react.default.startTransition;\n        startTransition(()=>{\n            reactRoot.render(reactEl);\n        });\n    }\n}\nfunction Root(param) {\n    let { callbacks , children  } = param;\n    _s1();\n    // We use `useLayoutEffect` to guarantee the callbacks are executed\n    // as soon as React flushes the update\n    _react.default.useLayoutEffect(()=>callbacks.forEach((callback)=>callback()), [\n        callbacks\n    ]);\n    // We should ask to measure the Web Vitals after rendering completes so we\n    // don't cause any hydration delay:\n    _react.default.useEffect(()=>{\n        (0, _performanceRelayer).default(onPerfEntry);\n    }, []);\n    if (false) {}\n    return children;\n}\n_s1(Root, \"Gjgl5rfcc2T4sFnfEMfRvL6K4Q4=\");\n_c2 = Root;\nfunction doRender(input) {\n    let { App , Component , props , err  } = input;\n    let styleSheets = \"initial\" in input ? undefined : input.styleSheets;\n    Component = Component || lastAppProps.Component;\n    props = props || lastAppProps.props;\n    const appProps = _extends({}, props, {\n        Component,\n        err,\n        router\n    });\n    // lastAppProps has to be set before ReactDom.render to account for ReactDom throwing an error.\n    lastAppProps = appProps;\n    let canceled = false;\n    let resolvePromise;\n    const renderPromise = new Promise((resolve, reject)=>{\n        if (lastRenderReject) {\n            lastRenderReject();\n        }\n        resolvePromise = ()=>{\n            lastRenderReject = null;\n            resolve();\n        };\n        lastRenderReject = ()=>{\n            canceled = true;\n            lastRenderReject = null;\n            const error = new Error(\"Cancel rendering route\");\n            error.cancelled = true;\n            reject(error);\n        };\n    });\n    // This function has a return type to ensure it doesn't start returning a\n    // Promise. It should remain synchronous.\n    function onStart() {\n        if (!styleSheets || // We use `style-loader` in development, so we don't need to do anything\n        // unless we're in production:\n        \"development\" !== \"production\") {\n            return false;\n        }\n        const currentStyleTags = looseToArray(document.querySelectorAll(\"style[data-n-href]\"));\n        const currentHrefs = new Set(currentStyleTags.map((tag)=>tag.getAttribute(\"data-n-href\")));\n        const noscript = document.querySelector(\"noscript[data-n-css]\");\n        const nonce = noscript == null ? void 0 : noscript.getAttribute(\"data-n-css\");\n        styleSheets.forEach((param)=>{\n            let { href , text  } = param;\n            if (!currentHrefs.has(href)) {\n                const styleTag = document.createElement(\"style\");\n                styleTag.setAttribute(\"data-n-href\", href);\n                styleTag.setAttribute(\"media\", \"x\");\n                if (nonce) {\n                    styleTag.setAttribute(\"nonce\", nonce);\n                }\n                document.head.appendChild(styleTag);\n                styleTag.appendChild(document.createTextNode(text));\n            }\n        });\n        return true;\n    }\n    function onHeadCommit() {\n        if (// unless we're in production:\n        false) {}\n        if (input.scroll) {\n            const htmlElement = document.documentElement;\n            const existing = htmlElement.style.scrollBehavior;\n            htmlElement.style.scrollBehavior = \"auto\";\n            window.scrollTo(input.scroll.x, input.scroll.y);\n            htmlElement.style.scrollBehavior = existing;\n        }\n    }\n    function onRootCommit() {\n        resolvePromise();\n    }\n    onStart();\n    const elem = /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(Head, {\n        callback: onHeadCommit\n    }), /*#__PURE__*/ _react.default.createElement(AppContainer, null, renderApp(App, appProps), /*#__PURE__*/ _react.default.createElement(_portal.Portal, {\n        type: \"next-route-announcer\"\n    }, /*#__PURE__*/ _react.default.createElement(_routeAnnouncer.RouteAnnouncer, null))));\n    // We catch runtime errors using componentDidCatch which will trigger renderError\n    renderReactElement(appElement, (callback)=>/*#__PURE__*/ _react.default.createElement(Root, {\n            callbacks: [\n                callback,\n                onRootCommit\n            ]\n        },  true ? /*#__PURE__*/ _react.default.createElement(_react.default.StrictMode, null, elem) : 0));\n    return renderPromise;\n}\nfunction render(renderingProps) {\n    return _render.apply(this, arguments);\n}\nfunction _render() {\n    _render = _async_to_generator(function*(renderingProps) {\n        if (renderingProps.err) {\n            yield renderError(renderingProps);\n            return;\n        }\n        try {\n            yield doRender(renderingProps);\n        } catch (err) {\n            const renderErr = (0, _isError).getProperError(err);\n            // bubble up cancelation errors\n            if (renderErr.cancelled) {\n                throw renderErr;\n            }\n            if (true) {\n                // Ensure this error is displayed in the overlay in development\n                setTimeout(()=>{\n                    throw renderErr;\n                });\n            }\n            yield renderError(_extends({}, renderingProps, {\n                err: renderErr\n            }));\n        }\n    });\n    return _render.apply(this, arguments);\n}\nfunction hydrate(opts) {\n    return _hydrate.apply(this, arguments);\n}\nfunction _hydrate() {\n    _hydrate = _async_to_generator(function*(opts) {\n        let initialErr = initialData.err;\n        try {\n            const appEntrypoint = yield pageLoader.routeLoader.whenEntrypoint(\"/_app\");\n            if (\"error\" in appEntrypoint) {\n                throw appEntrypoint.error;\n            }\n            const { component: app , exports: mod  } = appEntrypoint;\n            CachedApp = app;\n            if (mod && mod.reportWebVitals) {\n                onPerfEntry = (param)=>{\n                    let { id , name , startTime , value , duration , entryType , entries , attribution  } = param;\n                    // Combines timestamp with random number for unique ID\n                    const uniqueID = \"\".concat(Date.now(), \"-\").concat(Math.floor(Math.random() * (9e12 - 1)) + 1e12);\n                    let perfStartEntry;\n                    if (entries && entries.length) {\n                        perfStartEntry = entries[0].startTime;\n                    }\n                    const webVitals = {\n                        id: id || uniqueID,\n                        name,\n                        startTime: startTime || perfStartEntry,\n                        value: value == null ? duration : value,\n                        label: entryType === \"mark\" || entryType === \"measure\" ? \"custom\" : \"web-vital\"\n                    };\n                    if (attribution) {\n                        webVitals.attribution = attribution;\n                    }\n                    mod.reportWebVitals(webVitals);\n                };\n            }\n            const pageEntrypoint = // error, so we need to skip waiting for the entrypoint.\n             true && initialData.err ? {\n                error: initialData.err\n            } : yield pageLoader.routeLoader.whenEntrypoint(initialData.page);\n            if (\"error\" in pageEntrypoint) {\n                throw pageEntrypoint.error;\n            }\n            CachedComponent = pageEntrypoint.component;\n            if (true) {\n                const { isValidElementType  } = __webpack_require__(/*! next/dist/compiled/react-is */ \"./node_modules/next/dist/compiled/react-is/index.js\");\n                if (!isValidElementType(CachedComponent)) {\n                    throw new Error('The default export is not a React Component in page: \"'.concat(initialData.page, '\"'));\n                }\n            }\n        } catch (error1) {\n            // This catches errors like throwing in the top level of a module\n            initialErr = (0, _isError).getProperError(error1);\n        }\n        if (true) {\n            const { getServerError  } = __webpack_require__(/*! next/dist/compiled/@next/react-dev-overlay/dist/client */ \"./node_modules/next/dist/compiled/@next/react-dev-overlay/dist/client.js\");\n            // Server-side runtime errors need to be re-thrown on the client-side so\n            // that the overlay is rendered.\n            if (initialErr) {\n                if (initialErr === initialData.err) {\n                    setTimeout(()=>{\n                        let error;\n                        try {\n                            // Generate a new error object. We `throw` it because some browsers\n                            // will set the `stack` when thrown, and we want to ensure ours is\n                            // not overridden when we re-throw it below.\n                            throw new Error(initialErr.message);\n                        } catch (e) {\n                            error = e;\n                        }\n                        error.name = initialErr.name;\n                        error.stack = initialErr.stack;\n                        throw getServerError(error, initialErr.source);\n                    });\n                } else {\n                    setTimeout(()=>{\n                        throw initialErr;\n                    });\n                }\n            }\n        }\n        if (window.__NEXT_PRELOADREADY) {\n            yield window.__NEXT_PRELOADREADY(initialData.dynamicIds);\n        }\n        exports.router = router = (0, _router).createRouter(initialData.page, initialData.query, asPath, {\n            initialProps: initialData.props,\n            pageLoader,\n            App: CachedApp,\n            Component: CachedComponent,\n            wrapApp,\n            err: initialErr,\n            isFallback: Boolean(initialData.isFallback),\n            subscription: (info, App, scroll)=>render(Object.assign({}, info, {\n                    App,\n                    scroll\n                })),\n            locale: initialData.locale,\n            locales: initialData.locales,\n            defaultLocale,\n            domainLocales: initialData.domainLocales,\n            isPreview: initialData.isPreview\n        });\n        initialMatchesMiddleware = yield router._initialMatchesMiddlewarePromise;\n        const renderCtx = {\n            App: CachedApp,\n            initial: true,\n            Component: CachedComponent,\n            props: initialData.props,\n            err: initialErr\n        };\n        if (opts == null ? void 0 : opts.beforeRender) {\n            yield opts.beforeRender();\n        }\n        render(renderCtx);\n    });\n    return _hydrate.apply(this, arguments);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=index.js.map\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"AppContainer\");\n$RefreshReg$(_c1, \"Head\");\n$RefreshReg$(_c2, \"Root\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7Ozs7O0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGtCQUFrQixHQUFHRTtBQUNyQkYsZUFBZSxHQUFHRztBQUNsQkgsZUFBZSxHQUFHQSxjQUFjLEdBQUdBLGVBQWUsR0FBRyxLQUFLO0FBQzFELElBQUlPLHNCQUFzQkMseUlBQTBEO0FBQ3BGLElBQUlFLFdBQVdGLG1IQUErQztBQUM5RCxJQUFJRywyQkFBMkJILG1KQUErRDtBQUM5RixJQUFJSSw0QkFBNEJKLHFKQUFnRTtBQUNoR0EsbUJBQU9BLENBQUMsdUdBQW9DO0FBQzVDLElBQUlLLFNBQVNGLHlCQUF5QkgsbUJBQU9BLENBQUMsNENBQU87QUFDckQsSUFBSU0sVUFBVUgseUJBQXlCSCxtQkFBT0EsQ0FBQyw0REFBa0I7QUFDakUsSUFBSU8sc0JBQXNCUCxtQkFBT0EsQ0FBQyx1R0FBb0M7QUFDdEUsSUFBSVEsUUFBUUwseUJBQXlCSCxtQkFBT0EsQ0FBQyx1RUFBb0I7QUFDakUsSUFBSVMsaUJBQWlCVCxtQkFBT0EsQ0FBQywyRkFBOEI7QUFDM0QsSUFBSVUsYUFBYVYsbUJBQU9BLENBQUMsNkdBQXVDO0FBQ2hFLElBQUlXLGVBQWVYLG1CQUFPQSxDQUFDLCtHQUF3QztBQUNuRSxJQUFJWSxpQkFBaUJaLG1CQUFPQSxDQUFDLDJGQUE4QjtBQUMzRCxJQUFJYSxTQUFTYixtQkFBT0EsQ0FBQyx5RUFBcUI7QUFDMUMsSUFBSWMsVUFBVWQsbUJBQU9BLENBQUMsaUVBQVU7QUFDaEMsSUFBSWUsZUFBZVoseUJBQXlCSCxtQkFBT0EsQ0FBQyx1RUFBZ0I7QUFDcEUsSUFBSWdCLGNBQWNiLHlCQUF5QkgsbUJBQU9BLENBQUMscUVBQWU7QUFDbEUsSUFBSWlCLHNCQUFzQmQseUJBQXlCSCxtQkFBT0EsQ0FBQyxxRkFBdUI7QUFDbEYsSUFBSWtCLGtCQUFr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QUFFUixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT2lGLE1BQU0sQ0FBQy9FLFFBQVFTLE9BQU8sRUFBRVQ7SUFDL0IwVCxPQUFPMVQsT0FBTyxHQUFHQSxRQUFRUyxPQUFPO0FBQ2xDLENBQUMsQ0FFRCxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvaW5kZXguanM/NDZjYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuaW5pdGlhbGl6ZSA9IGluaXRpYWxpemU7XG5leHBvcnRzLmh5ZHJhdGUgPSBoeWRyYXRlO1xuZXhwb3J0cy5lbWl0dGVyID0gZXhwb3J0cy5yb3V0ZXIgPSBleHBvcnRzLnZlcnNpb24gPSB2b2lkIDA7XG52YXIgX2FzeW5jX3RvX2dlbmVyYXRvciA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19hc3luY190b19nZW5lcmF0b3IuanNcIikuZGVmYXVsdDtcbnZhciBfZXh0ZW5kcyA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19leHRlbmRzLmpzXCIpLmRlZmF1bHQ7XG52YXIgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0LmpzXCIpLmRlZmF1bHQ7XG52YXIgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQuanNcIikuZGVmYXVsdDtcbnJlcXVpcmUoXCIuLi9idWlsZC9wb2x5ZmlsbHMvcG9seWZpbGwtbW9kdWxlXCIpO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9jbGllbnQgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcInJlYWN0LWRvbS9jbGllbnRcIikpO1xudmFyIF9oZWFkTWFuYWdlckNvbnRleHQgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9oZWFkLW1hbmFnZXItY29udGV4dFwiKTtcbnZhciBfbWl0dCA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9taXR0XCIpKTtcbnZhciBfcm91dGVyQ29udGV4dCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci1jb250ZXh0XCIpO1xudmFyIF9pc0R5bmFtaWMgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtZHluYW1pY1wiKTtcbnZhciBfcXVlcnlzdHJpbmcgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmdcIik7XG52YXIgX3J1bnRpbWVDb25maWcgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9ydW50aW1lLWNvbmZpZ1wiKTtcbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi91dGlsc1wiKTtcbnZhciBfcG9ydGFsID0gcmVxdWlyZShcIi4vcG9ydGFsXCIpO1xudmFyIF9oZWFkTWFuYWdlciA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwiLi9oZWFkLW1hbmFnZXJcIikpO1xudmFyIF9wYWdlTG9hZGVyID0gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KHJlcXVpcmUoXCIuL3BhZ2UtbG9hZGVyXCIpKTtcbnZhciBfcGVyZm9ybWFuY2VSZWxheWVyID0gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KHJlcXVpcmUoXCIuL3BlcmZvcm1hbmNlLXJlbGF5ZXJcIikpO1xudmFyIF9yb3V0ZUFubm91bmNlciA9IHJlcXVpcmUoXCIuL3JvdXRlLWFubm91bmNlclwiKTtcbnZhciBfcm91dGVyID0gcmVxdWlyZShcIi4vcm91dGVyXCIpO1xudmFyIF9pc0Vycm9yID0gcmVxdWlyZShcIi4uL2xpYi9pcy1lcnJvclwiKTtcbnZhciBfaW1hZ2VDb25maWdDb250ZXh0ID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvaW1hZ2UtY29uZmlnLWNvbnRleHRcIik7XG52YXIgX3JlbW92ZUJhc2VQYXRoID0gcmVxdWlyZShcIi4vcmVtb3ZlLWJhc2UtcGF0aFwiKTtcbnZhciBfaGFzQmFzZVBhdGggPSByZXF1aXJlKFwiLi9oYXMtYmFzZS1wYXRoXCIpO1xudmFyIF9hcHBSb3V0ZXJDb250ZXh0ID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0XCIpO1xudmFyIF9hZGFwdGVycyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci9hZGFwdGVyc1wiKTtcbnZhciBfaG9va3NDbGllbnRDb250ZXh0ID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvaG9va3MtY2xpZW50LWNvbnRleHRcIik7XG5jb25zdCB2ZXJzaW9uID0gXCIxMy4wLjNcIjtcbmV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XG5sZXQgcm91dGVyO1xuZXhwb3J0cy5yb3V0ZXIgPSByb3V0ZXI7XG5jb25zdCBlbWl0dGVyID0gKDAsIF9taXR0KS5kZWZhdWx0KCk7XG5leHBvcnRzLmVtaXR0ZXIgPSBlbWl0dGVyO1xuY29uc3QgbG9vc2VUb0FycmF5ID0gKGlucHV0KT0+W10uc2xpY2UuY2FsbChpbnB1dCk7XG5sZXQgaW5pdGlhbERhdGE7XG5sZXQgZGVmYXVsdExvY2FsZSA9IHVuZGVmaW5lZDtcbmxldCBhc1BhdGg7XG5sZXQgcGFnZUxvYWRlcjtcbmxldCBhcHBFbGVtZW50O1xubGV0IGhlYWRNYW5hZ2VyO1xubGV0IGluaXRpYWxNYXRjaGVzTWlkZGxld2FyZSA9IGZhbHNlO1xubGV0IGxhc3RBcHBQcm9wcztcbmxldCBsYXN0UmVuZGVyUmVqZWN0O1xubGV0IHdlYnBhY2tITVI7XG5sZXQgQ2FjaGVkQXBwLCBvblBlcmZFbnRyeTtcbmxldCBDYWNoZWRDb21wb25lbnQ7XG5zZWxmLl9fbmV4dF9yZXF1aXJlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fO1xuY2xhc3MgQ29udGFpbmVyIGV4dGVuZHMgX3JlYWN0LmRlZmF1bHQuQ29tcG9uZW50IHtcbiAgICBjb21wb25lbnREaWRDYXRjaChjb21wb25lbnRFcnIsIGluZm8pIHtcbiAgICAgICAgdGhpcy5wcm9wcy5mbihjb21wb25lbnRFcnIsIGluZm8pO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxUb0hhc2goKTtcbiAgICAgICAgLy8gV2UgbmVlZCB0byByZXBsYWNlIHRoZSByb3V0ZXIgc3RhdGUgaWY6XG4gICAgICAgIC8vIC0gdGhlIHBhZ2Ugd2FzIChhdXRvKSBleHBvcnRlZCBhbmQgaGFzIGEgcXVlcnkgc3RyaW5nIG9yIHNlYXJjaCAoaGFzaClcbiAgICAgICAgLy8gLSBpdCB3YXMgYXV0byBleHBvcnRlZCBhbmQgaXMgYSBkeW5hbWljIHJvdXRlICh0byBwcm92aWRlIHBhcmFtcylcbiAgICAgICAgLy8gLSBpZiBpdCBpcyBhIGNsaWVudC1zaWRlIHNrZWxldG9uIChmYWxsYmFjayByZW5kZXIpXG4gICAgICAgIC8vIC0gaWYgbWlkZGxld2FyZSBtYXRjaGVzIHRoZSBjdXJyZW50IHBhZ2UgKG1heSBoYXZlIHJld3JpdGUgcGFyYW1zKVxuICAgICAgICAvLyAtIGlmIHJld3JpdGVzIGluIG5leHQuY29uZmlnLmpzIG1hdGNoIChtYXkgaGF2ZSByZXdyaXRlIHBhcmFtcylcbiAgICAgICAgaWYgKHJvdXRlci5pc1NzciAmJiAvLyBXZSBkb24ndCB1cGRhdGUgZm9yIDQwNCByZXF1ZXN0cyBhcyB0aGlzIGNhbiBtb2RpZnlcbiAgICAgICAgLy8gdGhlIGFzUGF0aCB1bmV4cGVjdGVkbHkgZS5nLiBhZGRpbmcgYmFzZVBhdGggd2hlblxuICAgICAgICAvLyBpdCB3YXNuJ3Qgb3JpZ2luYWxseSBwcmVzZW50XG4gICAgICAgIGluaXRpYWxEYXRhLnBhZ2UgIT09ICcvNDA0JyAmJiBpbml0aWFsRGF0YS5wYWdlICE9PSAnL19lcnJvcicgJiYgKGluaXRpYWxEYXRhLmlzRmFsbGJhY2sgfHwgaW5pdGlhbERhdGEubmV4dEV4cG9ydCAmJiAoKDAsIF9pc0R5bmFtaWMpLmlzRHluYW1pY1JvdXRlKHJvdXRlci5wYXRobmFtZSkgfHwgbG9jYXRpb24uc2VhcmNoIHx8IHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgfHwgaW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlKSB8fCBpbml0aWFsRGF0YS5wcm9wcyAmJiBpbml0aWFsRGF0YS5wcm9wcy5fX05fU1NHICYmIChsb2NhdGlvbi5zZWFyY2ggfHwgcHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyB8fCBpbml0aWFsTWF0Y2hlc01pZGRsZXdhcmUpKSkge1xuICAgICAgICAgICAgLy8gdXBkYXRlIHF1ZXJ5IG9uIG1vdW50IGZvciBleHBvcnRlZCBwYWdlc1xuICAgICAgICAgICAgcm91dGVyLnJlcGxhY2Uocm91dGVyLnBhdGhuYW1lICsgJz8nICsgU3RyaW5nKCgwLCBfcXVlcnlzdHJpbmcpLmFzc2lnbigoMCwgX3F1ZXJ5c3RyaW5nKS51cmxRdWVyeVRvU2VhcmNoUGFyYW1zKHJvdXRlci5xdWVyeSksIG5ldyBVUkxTZWFyY2hQYXJhbXMobG9jYXRpb24uc2VhcmNoKSkpLCBhc1BhdGgsIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgLy8gV0FSTklORzogYF9oYCBpcyBhbiBpbnRlcm5hbCBvcHRpb24gZm9yIGhhbmRpbmcgTmV4dC5qc1xuICAgICAgICAgICAgICAgIC8vIGNsaWVudC1zaWRlIGh5ZHJhdGlvbi4gWW91ciBhcHAgc2hvdWxkIF9uZXZlcl8gdXNlIHRoaXMgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gSXQgbWF5IGNoYW5nZSBhdCBhbnkgdGltZSB3aXRob3V0IG5vdGljZS5cbiAgICAgICAgICAgICAgICBfaDogMSxcbiAgICAgICAgICAgICAgICAvLyBGYWxsYmFjayBwYWdlcyBtdXN0IHRyaWdnZXIgdGhlIGRhdGEgZmV0Y2gsIHNvIHRoZSB0cmFuc2l0aW9uIGlzXG4gICAgICAgICAgICAgICAgLy8gbm90IHNoYWxsb3cuXG4gICAgICAgICAgICAgICAgLy8gT3RoZXIgcGFnZXMgKHN0cmljdGx5IHVwZGF0aW5nIHF1ZXJ5KSBoYXBwZW5zIHNoYWxsb3dseSwgYXMgZGF0YVxuICAgICAgICAgICAgICAgIC8vIHJlcXVpcmVtZW50cyB3b3VsZCBhbHJlYWR5IGJlIHByZXNlbnQuXG4gICAgICAgICAgICAgICAgc2hhbGxvdzogIWluaXRpYWxEYXRhLmlzRmFsbGJhY2sgJiYgIWluaXRpYWxNYXRjaGVzTWlkZGxld2FyZVxuICAgICAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgICAgICBpZiAoIWVyci5jYW5jZWxsZWQpIHRocm93IGVycjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxUb0hhc2goKTtcbiAgICB9XG4gICAgc2Nyb2xsVG9IYXNoKCkge1xuICAgICAgICBsZXQgeyBoYXNoICB9ID0gbG9jYXRpb247XG4gICAgICAgIGhhc2ggPSBoYXNoICYmIGhhc2guc3Vic3RyaW5nKDEpO1xuICAgICAgICBpZiAoIWhhc2gpIHJldHVybjtcbiAgICAgICAgY29uc3QgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChoYXNoKTtcbiAgICAgICAgaWYgKCFlbCkgcmV0dXJuO1xuICAgICAgICAvLyBJZiB3ZSBjYWxsIHNjcm9sbEludG9WaWV3KCkgaW4gaGVyZSB3aXRob3V0IGEgc2V0VGltZW91dFxuICAgICAgICAvLyBpdCB3b24ndCBzY3JvbGwgcHJvcGVybHkuXG4gICAgICAgIHNldFRpbWVvdXQoKCk9PmVsLnNjcm9sbEludG9WaWV3KCksIDApO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHsgUmVhY3REZXZPdmVybGF5ICwgIH0gPSByZXF1aXJlKCduZXh0L2Rpc3QvY29tcGlsZWQvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvZGlzdC9jbGllbnQnKTtcbiAgICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUmVhY3REZXZPdmVybGF5LCBudWxsLCB0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgcmV0dXJuIF9pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfaW5pdGlhbGl6ZSgpIHtcbiAgICBfaW5pdGlhbGl6ZSA9IF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24qKG9wdHMgPSB7fSkge1xuICAgICAgICAvLyBUaGlzIG1ha2VzIHN1cmUgdGhpcyBzcGVjaWZpYyBsaW5lcyBhcmUgcmVtb3ZlZCBpbiBwcm9kdWN0aW9uXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgd2VicGFja0hNUiA9IG9wdHMud2VicGFja0hNUjtcbiAgICAgICAgfVxuICAgICAgICBpbml0aWFsRGF0YSA9IEpTT04ucGFyc2UoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ19fTkVYVF9EQVRBX18nKS50ZXh0Q29udGVudCk7XG4gICAgICAgIHdpbmRvdy5fX05FWFRfREFUQV9fID0gaW5pdGlhbERhdGE7XG4gICAgICAgIGRlZmF1bHRMb2NhbGUgPSBpbml0aWFsRGF0YS5kZWZhdWx0TG9jYWxlO1xuICAgICAgICBjb25zdCBwcmVmaXggPSBpbml0aWFsRGF0YS5hc3NldFByZWZpeCB8fCAnJztcbiAgICAgICAgLy8gV2l0aCBkeW5hbWljIGFzc2V0UHJlZml4IGl0J3Mgbm8gbG9uZ2VyIHBvc3NpYmxlIHRvIHNldCBhc3NldFByZWZpeCBhdCB0aGUgYnVpbGQgdGltZVxuICAgICAgICAvLyBTbywgdGhpcyBpcyBob3cgd2UgZG8gaXQgaW4gdGhlIGNsaWVudCBzaWRlIGF0IHJ1bnRpbWVcbiAgICAgICAgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gPSBgJHtwcmVmaXh9L19uZXh0L2AgLy9lc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIDtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBuZXh0L2NvbmZpZyB3aXRoIHRoZSBlbnZpcm9ubWVudCBjb25maWd1cmF0aW9uXG4gICAgICAgICgwLCBfcnVudGltZUNvbmZpZykuc2V0Q29uZmlnKHtcbiAgICAgICAgICAgIHNlcnZlclJ1bnRpbWVDb25maWc6IHt9LFxuICAgICAgICAgICAgcHVibGljUnVudGltZUNvbmZpZzogaW5pdGlhbERhdGEucnVudGltZUNvbmZpZyB8fCB7fVxuICAgICAgICB9KTtcbiAgICAgICAgYXNQYXRoID0gKDAsIF91dGlscykuZ2V0VVJMKCk7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSBub3QgdG8gYXR0ZW1wdCBzdHJpcHBpbmcgYmFzZVBhdGggZm9yIDQwNHNcbiAgICAgICAgaWYgKCgwLCBfaGFzQmFzZVBhdGgpLmhhc0Jhc2VQYXRoKGFzUGF0aCkpIHtcbiAgICAgICAgICAgIGFzUGF0aCA9ICgwLCBfcmVtb3ZlQmFzZVBhdGgpLnJlbW92ZUJhc2VQYXRoKGFzUGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbm9ybWFsaXplTG9jYWxlUGF0aCAgfSA9IHJlcXVpcmUoJy4uL3NoYXJlZC9saWIvaTE4bi9ub3JtYWxpemUtbG9jYWxlLXBhdGgnKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGV0ZWN0RG9tYWluTG9jYWxlICB9ID0gcmVxdWlyZSgnLi4vc2hhcmVkL2xpYi9pMThuL2RldGVjdC1kb21haW4tbG9jYWxlJyk7XG4gICAgICAgICAgICBjb25zdCB7IHBhcnNlUmVsYXRpdmVVcmwgIH0gPSByZXF1aXJlKCcuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9wYXJzZS1yZWxhdGl2ZS11cmwnKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZm9ybWF0VXJsICB9ID0gcmVxdWlyZSgnLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybCcpO1xuICAgICAgICAgICAgaWYgKGluaXRpYWxEYXRhLmxvY2FsZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRBcyA9IHBhcnNlUmVsYXRpdmVVcmwoYXNQYXRoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbGVQYXRoUmVzdWx0ID0gbm9ybWFsaXplTG9jYWxlUGF0aChwYXJzZWRBcy5wYXRobmFtZSwgaW5pdGlhbERhdGEubG9jYWxlcyk7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSBsb2NhbGVQYXRoUmVzdWx0LnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICBhc1BhdGggPSBmb3JtYXRVcmwocGFyc2VkQXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlcml2ZSB0aGUgZGVmYXVsdCBsb2NhbGUgaWYgaXQgd2Fzbid0IGRldGVjdGVkIGluIHRoZSBhc1BhdGhcbiAgICAgICAgICAgICAgICAgICAgLy8gc2luY2Ugd2UgZG9uJ3QgcHJlcmVuZGVyIHN0YXRpYyBwYWdlcyB3aXRoIGFsbCBwb3NzaWJsZSBkZWZhdWx0XG4gICAgICAgICAgICAgICAgICAgIC8vIGxvY2FsZXNcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdExvY2FsZSA9IGluaXRpYWxEYXRhLmxvY2FsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYXR0ZW1wdCBkZXRlY3RpbmcgZGVmYXVsdCBsb2NhbGUgYmFzZWQgb24gaG9zdG5hbWVcbiAgICAgICAgICAgICAgICBjb25zdCBkZXRlY3RlZERvbWFpbiA9IGRldGVjdERvbWFpbkxvY2FsZShwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9ET01BSU5TLCB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGludmVzdGlnYXRlIGlmIGRlZmF1bHRMb2NhbGUgbmVlZHMgdG8gYmUgcG9wdWxhdGVkIGFmdGVyXG4gICAgICAgICAgICAgICAgLy8gaHlkcmF0aW9uIHRvIHByZXZlbnQgbWlzbWF0Y2hlZCByZW5kZXJzXG4gICAgICAgICAgICAgICAgaWYgKGRldGVjdGVkRG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRMb2NhbGUgPSBkZXRlY3RlZERvbWFpbi5kZWZhdWx0TG9jYWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5pdGlhbERhdGEuc2NyaXB0TG9hZGVyKSB7XG4gICAgICAgICAgICBjb25zdCB7IGluaXRTY3JpcHRMb2FkZXIgIH0gPSByZXF1aXJlKCcuL3NjcmlwdCcpO1xuICAgICAgICAgICAgaW5pdFNjcmlwdExvYWRlcihpbml0aWFsRGF0YS5zY3JpcHRMb2FkZXIpO1xuICAgICAgICB9XG4gICAgICAgIHBhZ2VMb2FkZXIgPSBuZXcgX3BhZ2VMb2FkZXIuZGVmYXVsdChpbml0aWFsRGF0YS5idWlsZElkLCBwcmVmaXgpO1xuICAgICAgICBjb25zdCByZWdpc3RlciA9IChbciwgZl0pPT5wYWdlTG9hZGVyLnJvdXRlTG9hZGVyLm9uRW50cnlwb2ludChyLCBmKTtcbiAgICAgICAgaWYgKHdpbmRvdy5fX05FWFRfUCkge1xuICAgICAgICAgICAgLy8gRGVmZXIgcGFnZSByZWdpc3RyYXRpb24gZm9yIGFub3RoZXIgdGljay4gVGhpcyB3aWxsIGluY3JlYXNlIHRoZSBvdmVyYWxsXG4gICAgICAgICAgICAvLyBsYXRlbmN5IGluIGh5ZHJhdGluZyB0aGUgcGFnZSwgYnV0IHJlZHVjZSB0aGUgdG90YWwgYmxvY2tpbmcgdGltZS5cbiAgICAgICAgICAgIHdpbmRvdy5fX05FWFRfUC5tYXAoKHApPT5zZXRUaW1lb3V0KCgpPT5yZWdpc3RlcihwKSwgMCkpO1xuICAgICAgICB9XG4gICAgICAgIHdpbmRvdy5fX05FWFRfUCA9IFtdO1xuICAgICAgICB3aW5kb3cuX19ORVhUX1AucHVzaCA9IHJlZ2lzdGVyO1xuICAgICAgICBoZWFkTWFuYWdlciA9ICgwLCBfaGVhZE1hbmFnZXIpLmRlZmF1bHQoKTtcbiAgICAgICAgaGVhZE1hbmFnZXIuZ2V0SXNTc3IgPSAoKT0+e1xuICAgICAgICAgICAgcmV0dXJuIHJvdXRlci5pc1NzcjtcbiAgICAgICAgfTtcbiAgICAgICAgYXBwRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdfX25leHQnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFzc2V0UHJlZml4OiBwcmVmaXhcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gX2luaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIHJlbmRlckFwcChBcHAsIGFwcFByb3BzKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChBcHAsIE9iamVjdC5hc3NpZ24oe30sIGFwcFByb3BzKSk7XG59XG5mdW5jdGlvbiBBcHBDb250YWluZXIoeyBjaGlsZHJlbiAgfSkge1xuICAgIHZhciBfYXV0b0V4cG9ydDtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KENvbnRhaW5lciwge1xuICAgICAgICBmbjogKGVycm9yKT0+Ly8gVE9ETzogRml4IGRpc2FibGVkIGVzbGludCBydWxlXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgICAgICByZW5kZXJFcnJvcih7XG4gICAgICAgICAgICAgICAgQXBwOiBDYWNoZWRBcHAsXG4gICAgICAgICAgICAgICAgZXJyOiBlcnJvclxuICAgICAgICAgICAgfSkuY2F0Y2goKGVycik9PmNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbmRlcmluZyBwYWdlOiAnLCBlcnIpKVxuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfYXBwUm91dGVyQ29udGV4dC5BcHBSb3V0ZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiAoMCwgX2FkYXB0ZXJzKS5hZGFwdEZvckFwcFJvdXRlckluc3RhbmNlKHJvdXRlcilcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2hvb2tzQ2xpZW50Q29udGV4dC5TZWFyY2hQYXJhbXNDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiAoMCwgX2FkYXB0ZXJzKS5hZGFwdEZvclNlYXJjaFBhcmFtcyhyb3V0ZXIpXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9hZGFwdGVycy5QYXRobmFtZUNvbnRleHRQcm92aWRlckFkYXB0ZXIsIHtcbiAgICAgICAgcm91dGVyOiByb3V0ZXIsXG4gICAgICAgIGlzQXV0b0V4cG9ydDogKF9hdXRvRXhwb3J0ID0gc2VsZi5fX05FWFRfREFUQV9fLmF1dG9FeHBvcnQpICE9IG51bGwgPyBfYXV0b0V4cG9ydCA6IGZhbHNlXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yb3V0ZXJDb250ZXh0LlJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6ICgwLCBfcm91dGVyKS5tYWtlUHVibGljUm91dGVySW5zdGFuY2Uocm91dGVyKVxuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfaGVhZE1hbmFnZXJDb250ZXh0LkhlYWRNYW5hZ2VyQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogaGVhZE1hbmFnZXJcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2ltYWdlQ29uZmlnQ29udGV4dC5JbWFnZUNvbmZpZ0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHByb2Nlc3MuZW52Ll9fTkVYVF9JTUFHRV9PUFRTXG4gICAgfSwgY2hpbGRyZW4pKSkpKSkpO1xufVxuY29uc3Qgd3JhcEFwcCA9IChBcHApPT4od3JhcHBlZEFwcFByb3BzKT0+e1xuICAgICAgICBjb25zdCBhcHBQcm9wcyA9IF9leHRlbmRzKHt9LCB3cmFwcGVkQXBwUHJvcHMsIHtcbiAgICAgICAgICAgIENvbXBvbmVudDogQ2FjaGVkQ29tcG9uZW50LFxuICAgICAgICAgICAgZXJyOiBpbml0aWFsRGF0YS5lcnIsXG4gICAgICAgICAgICByb3V0ZXJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQXBwQ29udGFpbmVyLCBudWxsLCByZW5kZXJBcHAoQXBwLCBhcHBQcm9wcykpO1xuICAgIH07XG4vLyBUaGlzIG1ldGhvZCBoYW5kbGVzIGFsbCBydW50aW1lIGFuZCBkZWJ1ZyBlcnJvcnMuXG4vLyA0MDQgYW5kIDUwMCBlcnJvcnMgYXJlIHNwZWNpYWwga2luZCBvZiBlcnJvcnNcbi8vIGFuZCB0aGV5IGFyZSBzdGlsbCBoYW5kbGUgdmlhIHRoZSBtYWluIHJlbmRlciBtZXRob2QuXG5mdW5jdGlvbiByZW5kZXJFcnJvcihyZW5kZXJFcnJvclByb3BzKSB7XG4gICAgbGV0IHsgQXBwICwgZXJyICB9ID0gcmVuZGVyRXJyb3JQcm9wcztcbiAgICAvLyBJbiBkZXZlbG9wbWVudCBydW50aW1lIGVycm9ycyBhcmUgY2F1Z2h0IGJ5IG91ciBvdmVybGF5XG4gICAgLy8gSW4gcHJvZHVjdGlvbiB3ZSBjYXRjaCBydW50aW1lIGVycm9ycyB1c2luZyBjb21wb25lbnREaWRDYXRjaCB3aGljaCB3aWxsIHRyaWdnZXIgcmVuZGVyRXJyb3JcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAvLyBBIE5leHQuanMgcmVuZGVyaW5nIHJ1bnRpbWUgZXJyb3IgaXMgYWx3YXlzIHVucmVjb3ZlcmFibGVcbiAgICAgICAgLy8gRklYTUU6IGxldCdzIG1ha2UgdGhpcyByZWNvdmVyYWJsZSAoZXJyb3IgaW4gR0lQIGNsaWVudC10cmFuc2l0aW9uKVxuICAgICAgICB3ZWJwYWNrSE1SLm9uVW5yZWNvdmVyYWJsZUVycm9yKCk7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gcmVuZGVyIGFuIGVtcHR5IDxBcHA+IHNvIHRoYXQgdGhlIGA8UmVhY3REZXZPdmVybGF5PmAgY2FuXG4gICAgICAgIC8vIHJlbmRlciBpdHNlbGYuXG4gICAgICAgIC8vIFRPRE86IEZpeCBkaXNhYmxlZCBlc2xpbnQgcnVsZVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiBkb1JlbmRlcih7XG4gICAgICAgICAgICBBcHA6ICgpPT5udWxsLFxuICAgICAgICAgICAgcHJvcHM6IHt9LFxuICAgICAgICAgICAgQ29tcG9uZW50OiAoKT0+bnVsbCxcbiAgICAgICAgICAgIHN0eWxlU2hlZXRzOiBbXVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIHdlIGxvZyB0aGUgZXJyb3IgdG8gdGhlIGNvbnNvbGUsIG90aGVyd2lzZSB1c2VycyBjYW4ndCB0cmFjayBkb3duIGlzc3Vlcy5cbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgY29uc29sZS5lcnJvcihgQSBjbGllbnQtc2lkZSBleGNlcHRpb24gaGFzIG9jY3VycmVkLCBzZWUgaGVyZSBmb3IgbW9yZSBpbmZvOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9jbGllbnQtc2lkZS1leGNlcHRpb24tb2NjdXJyZWRgKTtcbiAgICByZXR1cm4gcGFnZUxvYWRlci5sb2FkUGFnZSgnL19lcnJvcicpLnRoZW4oKHsgcGFnZTogRXJyb3JDb21wb25lbnQgLCBzdHlsZVNoZWV0cyAgfSk9PntcbiAgICAgICAgcmV0dXJuIChsYXN0QXBwUHJvcHMgPT0gbnVsbCA/IHZvaWQgMCA6IGxhc3RBcHBQcm9wcy5Db21wb25lbnQpID09PSBFcnJvckNvbXBvbmVudCA/IGltcG9ydCgnLi4vcGFnZXMvX2Vycm9yJykudGhlbigoZXJyb3JNb2R1bGUpPT57XG4gICAgICAgICAgICByZXR1cm4gaW1wb3J0KCcuLi9wYWdlcy9fYXBwJykudGhlbigoYXBwTW9kdWxlKT0+e1xuICAgICAgICAgICAgICAgIEFwcCA9IGFwcE1vZHVsZS5kZWZhdWx0O1xuICAgICAgICAgICAgICAgIHJlbmRlckVycm9yUHJvcHMuQXBwID0gQXBwO1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvck1vZHVsZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS50aGVuKChtKT0+KHtcbiAgICAgICAgICAgICAgICBFcnJvckNvbXBvbmVudDogbS5kZWZhdWx0LFxuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRzOiBbXVxuICAgICAgICAgICAgfSkpIDoge1xuICAgICAgICAgICAgRXJyb3JDb21wb25lbnQsXG4gICAgICAgICAgICBzdHlsZVNoZWV0c1xuICAgICAgICB9O1xuICAgIH0pLnRoZW4oKHsgRXJyb3JDb21wb25lbnQgLCBzdHlsZVNoZWV0cyAgfSk9PntcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgLy8gSW4gcHJvZHVjdGlvbiB3ZSBkbyBhIG5vcm1hbCByZW5kZXIgd2l0aCB0aGUgYEVycm9yQ29tcG9uZW50YCBhcyBjb21wb25lbnQuXG4gICAgICAgIC8vIElmIHdlJ3ZlIGdvdHRlbiBoZXJlIHVwb24gaW5pdGlhbCByZW5kZXIsIHdlIGNhbiB1c2UgdGhlIHByb3BzIGZyb20gdGhlIHNlcnZlci5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBuZWVkIHRvIGNhbGwgYGdldEluaXRpYWxQcm9wc2Agb24gYEFwcGAgYmVmb3JlIG1vdW50aW5nLlxuICAgICAgICBjb25zdCBBcHBUcmVlID0gd3JhcEFwcChBcHApO1xuICAgICAgICBjb25zdCBhcHBDdHggPSB7XG4gICAgICAgICAgICBDb21wb25lbnQ6IEVycm9yQ29tcG9uZW50LFxuICAgICAgICAgICAgQXBwVHJlZSxcbiAgICAgICAgICAgIHJvdXRlcixcbiAgICAgICAgICAgIGN0eDoge1xuICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICBwYXRobmFtZTogaW5pdGlhbERhdGEucGFnZSxcbiAgICAgICAgICAgICAgICBxdWVyeTogaW5pdGlhbERhdGEucXVlcnksXG4gICAgICAgICAgICAgICAgYXNQYXRoLFxuICAgICAgICAgICAgICAgIEFwcFRyZWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgoKHJlZiA9IHJlbmRlckVycm9yUHJvcHMucHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiByZWYuZXJyKSA/IHJlbmRlckVycm9yUHJvcHMucHJvcHMgOiAoMCwgX3V0aWxzKS5sb2FkR2V0SW5pdGlhbFByb3BzKEFwcCwgYXBwQ3R4KSkudGhlbigoaW5pdFByb3BzKT0+Ly8gVE9ETzogRml4IGRpc2FibGVkIGVzbGludCBydWxlXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgICAgICBkb1JlbmRlcihfZXh0ZW5kcyh7fSwgcmVuZGVyRXJyb3JQcm9wcywge1xuICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICBDb21wb25lbnQ6IEVycm9yQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRzLFxuICAgICAgICAgICAgICAgIHByb3BzOiBpbml0UHJvcHNcbiAgICAgICAgICAgIH0pKSk7XG4gICAgfSk7XG59XG4vLyBEdW1teSBjb21wb25lbnQgdGhhdCB3ZSByZW5kZXIgYXMgYSBjaGlsZCBvZiBSb290IHNvIHRoYXQgd2UgY2FuXG4vLyB0b2dnbGUgdGhlIGNvcnJlY3Qgc3R5bGVzIGJlZm9yZSB0aGUgcGFnZSBpcyByZW5kZXJlZC5cbmZ1bmN0aW9uIEhlYWQoeyBjYWxsYmFjayAgfSkge1xuICAgIC8vIFdlIHVzZSBgdXNlTGF5b3V0RWZmZWN0YCB0byBndWFyYW50ZWUgdGhlIGNhbGxiYWNrIGlzIGV4ZWN1dGVkXG4gICAgLy8gYXMgc29vbiBhcyBSZWFjdCBmbHVzaGVzIHRoZSB1cGRhdGUuXG4gICAgX3JlYWN0LmRlZmF1bHQudXNlTGF5b3V0RWZmZWN0KCgpPT5jYWxsYmFjaygpLCBbXG4gICAgICAgIGNhbGxiYWNrXG4gICAgXSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG5sZXQgcmVhY3RSb290ID0gbnVsbDtcbi8vIE9uIGluaXRpYWwgcmVuZGVyIGEgaHlkcmF0ZSBzaG91bGQgYWx3YXlzIGhhcHBlblxubGV0IHNob3VsZEh5ZHJhdGUgPSB0cnVlO1xuZnVuY3Rpb24gY2xlYXJNYXJrcygpIHtcbiAgICBbXG4gICAgICAgICdiZWZvcmVSZW5kZXInLFxuICAgICAgICAnYWZ0ZXJIeWRyYXRlJyxcbiAgICAgICAgJ2FmdGVyUmVuZGVyJyxcbiAgICAgICAgJ3JvdXRlQ2hhbmdlJ1xuICAgIF0uZm9yRWFjaCgobWFyayk9PnBlcmZvcm1hbmNlLmNsZWFyTWFya3MobWFyaykpO1xufVxuZnVuY3Rpb24gbWFya0h5ZHJhdGVDb21wbGV0ZSgpIHtcbiAgICBpZiAoIV91dGlscy5TVCkgcmV0dXJuO1xuICAgIHBlcmZvcm1hbmNlLm1hcmsoJ2FmdGVySHlkcmF0ZScpIC8vIG1hcmsgZW5kIG9mIGh5ZHJhdGlvblxuICAgIDtcbiAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKCdOZXh0LmpzLWJlZm9yZS1oeWRyYXRpb24nLCAnbmF2aWdhdGlvblN0YXJ0JywgJ2JlZm9yZVJlbmRlcicpO1xuICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUoJ05leHQuanMtaHlkcmF0aW9uJywgJ2JlZm9yZVJlbmRlcicsICdhZnRlckh5ZHJhdGUnKTtcbiAgICBpZiAob25QZXJmRW50cnkpIHtcbiAgICAgICAgcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZSgnTmV4dC5qcy1oeWRyYXRpb24nKS5mb3JFYWNoKG9uUGVyZkVudHJ5KTtcbiAgICB9XG4gICAgY2xlYXJNYXJrcygpO1xufVxuZnVuY3Rpb24gbWFya1JlbmRlckNvbXBsZXRlKCkge1xuICAgIGlmICghX3V0aWxzLlNUKSByZXR1cm47XG4gICAgcGVyZm9ybWFuY2UubWFyaygnYWZ0ZXJSZW5kZXInKSAvLyBtYXJrIGVuZCBvZiByZW5kZXJcbiAgICA7XG4gICAgY29uc3QgbmF2U3RhcnRFbnRyaWVzID0gcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZSgncm91dGVDaGFuZ2UnLCAnbWFyaycpO1xuICAgIGlmICghbmF2U3RhcnRFbnRyaWVzLmxlbmd0aCkgcmV0dXJuO1xuICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUoJ05leHQuanMtcm91dGUtY2hhbmdlLXRvLXJlbmRlcicsIG5hdlN0YXJ0RW50cmllc1swXS5uYW1lLCAnYmVmb3JlUmVuZGVyJyk7XG4gICAgcGVyZm9ybWFuY2UubWVhc3VyZSgnTmV4dC5qcy1yZW5kZXInLCAnYmVmb3JlUmVuZGVyJywgJ2FmdGVyUmVuZGVyJyk7XG4gICAgaWYgKG9uUGVyZkVudHJ5KSB7XG4gICAgICAgIHBlcmZvcm1hbmNlLmdldEVudHJpZXNCeU5hbWUoJ05leHQuanMtcmVuZGVyJykuZm9yRWFjaChvblBlcmZFbnRyeSk7XG4gICAgICAgIHBlcmZvcm1hbmNlLmdldEVudHJpZXNCeU5hbWUoJ05leHQuanMtcm91dGUtY2hhbmdlLXRvLXJlbmRlcicpLmZvckVhY2gob25QZXJmRW50cnkpO1xuICAgIH1cbiAgICBjbGVhck1hcmtzKCk7XG4gICAgW1xuICAgICAgICAnTmV4dC5qcy1yb3V0ZS1jaGFuZ2UtdG8tcmVuZGVyJyxcbiAgICAgICAgJ05leHQuanMtcmVuZGVyJ1xuICAgIF0uZm9yRWFjaCgobWVhc3VyZSk9PnBlcmZvcm1hbmNlLmNsZWFyTWVhc3VyZXMobWVhc3VyZSkpO1xufVxuZnVuY3Rpb24gcmVuZGVyUmVhY3RFbGVtZW50KGRvbUVsLCBmbikge1xuICAgIC8vIG1hcmsgc3RhcnQgb2YgaHlkcmF0ZS9yZW5kZXJcbiAgICBpZiAoX3V0aWxzLlNUKSB7XG4gICAgICAgIHBlcmZvcm1hbmNlLm1hcmsoJ2JlZm9yZVJlbmRlcicpO1xuICAgIH1cbiAgICBjb25zdCByZWFjdEVsID0gZm4oc2hvdWxkSHlkcmF0ZSA/IG1hcmtIeWRyYXRlQ29tcGxldGUgOiBtYXJrUmVuZGVyQ29tcGxldGUpO1xuICAgIGlmICghcmVhY3RSb290KSB7XG4gICAgICAgIC8vIFVubGlrZSB3aXRoIGNyZWF0ZVJvb3QsIHlvdSBkb24ndCBuZWVkIGEgc2VwYXJhdGUgcm9vdC5yZW5kZXIoKSBjYWxsIGhlcmVcbiAgICAgICAgcmVhY3RSb290ID0gX2NsaWVudC5kZWZhdWx0Lmh5ZHJhdGVSb290KGRvbUVsLCByZWFjdEVsKTtcbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIHNob3VsZEh5ZHJhdGUgdmFyaWFibGUgd2hlbiBSZWFjdCAxOCBpcyBzdGFibGUgYXMgaXQgY2FuIGRlcGVuZCBvbiBgcmVhY3RSb290YCBleGlzdGluZ1xuICAgICAgICBzaG91bGRIeWRyYXRlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc3RhcnRUcmFuc2l0aW9uID0gX3JlYWN0LmRlZmF1bHQuc3RhcnRUcmFuc2l0aW9uO1xuICAgICAgICBzdGFydFRyYW5zaXRpb24oKCk9PntcbiAgICAgICAgICAgIHJlYWN0Um9vdC5yZW5kZXIocmVhY3RFbCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIFJvb3QoeyBjYWxsYmFja3MgLCBjaGlsZHJlbiAgfSkge1xuICAgIC8vIFdlIHVzZSBgdXNlTGF5b3V0RWZmZWN0YCB0byBndWFyYW50ZWUgdGhlIGNhbGxiYWNrcyBhcmUgZXhlY3V0ZWRcbiAgICAvLyBhcyBzb29uIGFzIFJlYWN0IGZsdXNoZXMgdGhlIHVwZGF0ZVxuICAgIF9yZWFjdC5kZWZhdWx0LnVzZUxheW91dEVmZmVjdCgoKT0+Y2FsbGJhY2tzLmZvckVhY2goKGNhbGxiYWNrKT0+Y2FsbGJhY2soKSksIFtcbiAgICAgICAgY2FsbGJhY2tzXG4gICAgXSk7XG4gICAgLy8gV2Ugc2hvdWxkIGFzayB0byBtZWFzdXJlIHRoZSBXZWIgVml0YWxzIGFmdGVyIHJlbmRlcmluZyBjb21wbGV0ZXMgc28gd2VcbiAgICAvLyBkb24ndCBjYXVzZSBhbnkgaHlkcmF0aW9uIGRlbGF5OlxuICAgIF9yZWFjdC5kZWZhdWx0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICAoMCwgX3BlcmZvcm1hbmNlUmVsYXllcikuZGVmYXVsdChvblBlcmZFbnRyeSk7XG4gICAgfSwgW10pO1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfVEVTVF9NT0RFKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgICAgICBfcmVhY3QuZGVmYXVsdC51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgICAgIHdpbmRvdy5fX05FWFRfSFlEUkFURUQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5fX05FWFRfSFlEUkFURURfQ0IpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuX19ORVhUX0hZRFJBVEVEX0NCKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xufVxuZnVuY3Rpb24gZG9SZW5kZXIoaW5wdXQpIHtcbiAgICBsZXQgeyBBcHAgLCBDb21wb25lbnQgLCBwcm9wcyAsIGVyciAgfSA9IGlucHV0O1xuICAgIGxldCBzdHlsZVNoZWV0cyA9ICdpbml0aWFsJyBpbiBpbnB1dCA/IHVuZGVmaW5lZCA6IGlucHV0LnN0eWxlU2hlZXRzO1xuICAgIENvbXBvbmVudCA9IENvbXBvbmVudCB8fCBsYXN0QXBwUHJvcHMuQ29tcG9uZW50O1xuICAgIHByb3BzID0gcHJvcHMgfHwgbGFzdEFwcFByb3BzLnByb3BzO1xuICAgIGNvbnN0IGFwcFByb3BzID0gX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgZXJyLFxuICAgICAgICByb3V0ZXJcbiAgICB9KTtcbiAgICAvLyBsYXN0QXBwUHJvcHMgaGFzIHRvIGJlIHNldCBiZWZvcmUgUmVhY3REb20ucmVuZGVyIHRvIGFjY291bnQgZm9yIFJlYWN0RG9tIHRocm93aW5nIGFuIGVycm9yLlxuICAgIGxhc3RBcHBQcm9wcyA9IGFwcFByb3BzO1xuICAgIGxldCBjYW5jZWxlZCA9IGZhbHNlO1xuICAgIGxldCByZXNvbHZlUHJvbWlzZTtcbiAgICBjb25zdCByZW5kZXJQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcbiAgICAgICAgaWYgKGxhc3RSZW5kZXJSZWplY3QpIHtcbiAgICAgICAgICAgIGxhc3RSZW5kZXJSZWplY3QoKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlUHJvbWlzZSA9ICgpPT57XG4gICAgICAgICAgICBsYXN0UmVuZGVyUmVqZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGFzdFJlbmRlclJlamVjdCA9ICgpPT57XG4gICAgICAgICAgICBjYW5jZWxlZCA9IHRydWU7XG4gICAgICAgICAgICBsYXN0UmVuZGVyUmVqZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdDYW5jZWwgcmVuZGVyaW5nIHJvdXRlJyk7XG4gICAgICAgICAgICBlcnJvci5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGhhcyBhIHJldHVybiB0eXBlIHRvIGVuc3VyZSBpdCBkb2Vzbid0IHN0YXJ0IHJldHVybmluZyBhXG4gICAgLy8gUHJvbWlzZS4gSXQgc2hvdWxkIHJlbWFpbiBzeW5jaHJvbm91cy5cbiAgICBmdW5jdGlvbiBvblN0YXJ0KCkge1xuICAgICAgICBpZiAoIXN0eWxlU2hlZXRzIHx8IC8vIFdlIHVzZSBgc3R5bGUtbG9hZGVyYCBpbiBkZXZlbG9wbWVudCwgc28gd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZ1xuICAgICAgICAvLyB1bmxlc3Mgd2UncmUgaW4gcHJvZHVjdGlvbjpcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdHlsZVRhZ3MgPSBsb29zZVRvQXJyYXkoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc3R5bGVbZGF0YS1uLWhyZWZdJykpO1xuICAgICAgICBjb25zdCBjdXJyZW50SHJlZnMgPSBuZXcgU2V0KGN1cnJlbnRTdHlsZVRhZ3MubWFwKCh0YWcpPT50YWcuZ2V0QXR0cmlidXRlKCdkYXRhLW4taHJlZicpKSk7XG4gICAgICAgIGNvbnN0IG5vc2NyaXB0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignbm9zY3JpcHRbZGF0YS1uLWNzc10nKTtcbiAgICAgICAgY29uc3Qgbm9uY2UgPSBub3NjcmlwdCA9PSBudWxsID8gdm9pZCAwIDogbm9zY3JpcHQuZ2V0QXR0cmlidXRlKCdkYXRhLW4tY3NzJyk7XG4gICAgICAgIHN0eWxlU2hlZXRzLmZvckVhY2goKHsgaHJlZiAsIHRleHQgIH0pPT57XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRIcmVmcy5oYXMoaHJlZikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZVRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgICAgICAgICAgc3R5bGVUYWcuc2V0QXR0cmlidXRlKCdkYXRhLW4taHJlZicsIGhyZWYpO1xuICAgICAgICAgICAgICAgIHN0eWxlVGFnLnNldEF0dHJpYnV0ZSgnbWVkaWEnLCAneCcpO1xuICAgICAgICAgICAgICAgIGlmIChub25jZSkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZVRhZy5zZXRBdHRyaWJ1dGUoJ25vbmNlJywgbm9uY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlVGFnKTtcbiAgICAgICAgICAgICAgICBzdHlsZVRhZy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25IZWFkQ29tbWl0KCkge1xuICAgICAgICBpZiAoLy8gV2UgdXNlIGBzdHlsZS1sb2FkZXJgIGluIGRldmVsb3BtZW50LCBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nXG4gICAgICAgIC8vIHVubGVzcyB3ZSdyZSBpbiBwcm9kdWN0aW9uOlxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nICYmIC8vIFdlIGNhbiBza2lwIHRoaXMgZHVyaW5nIGh5ZHJhdGlvbi4gUnVubmluZyBpdCB3b250IGNhdXNlIGFueSBoYXJtLCBidXRcbiAgICAgICAgLy8gd2UgbWF5IGFzIHdlbGwgc2F2ZSB0aGUgQ1BVIGN5Y2xlczpcbiAgICAgICAgc3R5bGVTaGVldHMgJiYgLy8gRW5zdXJlIHRoaXMgcmVuZGVyIHdhcyBub3QgY2FuY2VsZWRcbiAgICAgICAgIWNhbmNlbGVkKSB7XG4gICAgICAgICAgICBjb25zdCBkZXNpcmVkSHJlZnMgPSBuZXcgU2V0KHN0eWxlU2hlZXRzLm1hcCgocyk9PnMuaHJlZikpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFN0eWxlVGFncyA9IGxvb3NlVG9BcnJheShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdzdHlsZVtkYXRhLW4taHJlZl0nKSk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50SHJlZnMgPSBjdXJyZW50U3R5bGVUYWdzLm1hcCgodGFnKT0+dGFnLmdldEF0dHJpYnV0ZSgnZGF0YS1uLWhyZWYnKSk7XG4gICAgICAgICAgICAvLyBUb2dnbGUgYDxzdHlsZT5gIHRhZ3Mgb24gb3Igb2ZmIGRlcGVuZGluZyBvbiBpZiB0aGV5J3JlIG5lZWRlZDpcbiAgICAgICAgICAgIGZvcihsZXQgaWR4ID0gMDsgaWR4IDwgY3VycmVudEhyZWZzLmxlbmd0aDsgKytpZHgpe1xuICAgICAgICAgICAgICAgIGlmIChkZXNpcmVkSHJlZnMuaGFzKGN1cnJlbnRIcmVmc1tpZHhdKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3R5bGVUYWdzW2lkeF0ucmVtb3ZlQXR0cmlidXRlKCdtZWRpYScpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdHlsZVRhZ3NbaWR4XS5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgJ3gnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW9yZGVyIHN0eWxlcyBpbnRvIGludGVuZGVkIG9yZGVyOlxuICAgICAgICAgICAgbGV0IHJlZmVyZW5jZU5vZGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdub3NjcmlwdFtkYXRhLW4tY3NzXScpO1xuICAgICAgICAgICAgaWYgKC8vIFRoaXMgc2hvdWxkIGJlIGFuIGludmFyaWFudDpcbiAgICAgICAgICAgIHJlZmVyZW5jZU5vZGUpIHtcbiAgICAgICAgICAgICAgICBzdHlsZVNoZWV0cy5mb3JFYWNoKCh7IGhyZWYgIH0pPT57XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFRhZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYHN0eWxlW2RhdGEtbi1ocmVmPVwiJHtocmVmfVwiXWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoLy8gVGhpcyBzaG91bGQgYmUgYW4gaW52YXJpYW50OlxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRUYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZU5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGFyZ2V0VGFnLCByZWZlcmVuY2VOb2RlLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZU5vZGUgPSB0YXJnZXRUYWc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpbmFsbHksIGNsZWFuIHVwIHNlcnZlciByZW5kZXJlZCBzdHlsZXNoZWV0czpcbiAgICAgICAgICAgIGxvb3NlVG9BcnJheShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdsaW5rW2RhdGEtbi1wXScpKS5mb3JFYWNoKChlbCk9PntcbiAgICAgICAgICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dC5zY3JvbGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGh0bWxFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBodG1sRWxlbWVudC5zdHlsZS5zY3JvbGxCZWhhdmlvcjtcbiAgICAgICAgICAgIGh0bWxFbGVtZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yID0gJ2F1dG8nO1xuICAgICAgICAgICAgd2luZG93LnNjcm9sbFRvKGlucHV0LnNjcm9sbC54LCBpbnB1dC5zY3JvbGwueSk7XG4gICAgICAgICAgICBodG1sRWxlbWVudC5zdHlsZS5zY3JvbGxCZWhhdmlvciA9IGV4aXN0aW5nO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uUm9vdENvbW1pdCgpIHtcbiAgICAgICAgcmVzb2x2ZVByb21pc2UoKTtcbiAgICB9XG4gICAgb25TdGFydCgpO1xuICAgIGNvbnN0IGVsZW0gPSAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChIZWFkLCB7XG4gICAgICAgIGNhbGxiYWNrOiBvbkhlYWRDb21taXRcbiAgICB9KSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEFwcENvbnRhaW5lciwgbnVsbCwgcmVuZGVyQXBwKEFwcCwgYXBwUHJvcHMpLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3BvcnRhbC5Qb3J0YWwsIHtcbiAgICAgICAgdHlwZTogXCJuZXh0LXJvdXRlLWFubm91bmNlclwiXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yb3V0ZUFubm91bmNlci5Sb3V0ZUFubm91bmNlciwgbnVsbCkpKSk7XG4gICAgLy8gV2UgY2F0Y2ggcnVudGltZSBlcnJvcnMgdXNpbmcgY29tcG9uZW50RGlkQ2F0Y2ggd2hpY2ggd2lsbCB0cmlnZ2VyIHJlbmRlckVycm9yXG4gICAgcmVuZGVyUmVhY3RFbGVtZW50KGFwcEVsZW1lbnQsIChjYWxsYmFjayk9Pi8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChSb290LCB7XG4gICAgICAgICAgICBjYWxsYmFja3M6IFtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICBvblJvb3RDb21taXRcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSwgcHJvY2Vzcy5lbnYuX19ORVhUX1NUUklDVF9NT0RFID8gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LlN0cmljdE1vZGUsIG51bGwsIGVsZW0pIDogZWxlbSkpO1xuICAgIHJldHVybiByZW5kZXJQcm9taXNlO1xufVxuZnVuY3Rpb24gcmVuZGVyKHJlbmRlcmluZ1Byb3BzKSB7XG4gICAgcmV0dXJuIF9yZW5kZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9yZW5kZXIoKSB7XG4gICAgX3JlbmRlciA9IF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24qKHJlbmRlcmluZ1Byb3BzKSB7XG4gICAgICAgIGlmIChyZW5kZXJpbmdQcm9wcy5lcnIpIHtcbiAgICAgICAgICAgIHlpZWxkIHJlbmRlckVycm9yKHJlbmRlcmluZ1Byb3BzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgeWllbGQgZG9SZW5kZXIocmVuZGVyaW5nUHJvcHMpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbmRlckVyciA9ICgwLCBfaXNFcnJvcikuZ2V0UHJvcGVyRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIC8vIGJ1YmJsZSB1cCBjYW5jZWxhdGlvbiBlcnJvcnNcbiAgICAgICAgICAgIGlmIChyZW5kZXJFcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgcmVuZGVyRXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoaXMgZXJyb3IgaXMgZGlzcGxheWVkIGluIHRoZSBvdmVybGF5IGluIGRldmVsb3BtZW50XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyByZW5kZXJFcnI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCByZW5kZXJFcnJvcihfZXh0ZW5kcyh7fSwgcmVuZGVyaW5nUHJvcHMsIHtcbiAgICAgICAgICAgICAgICBlcnI6IHJlbmRlckVyclxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9yZW5kZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIGh5ZHJhdGUob3B0cykge1xuICAgIHJldHVybiBfaHlkcmF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX2h5ZHJhdGUoKSB7XG4gICAgX2h5ZHJhdGUgPSBfYXN5bmNfdG9fZ2VuZXJhdG9yKGZ1bmN0aW9uKihvcHRzKSB7XG4gICAgICAgIGxldCBpbml0aWFsRXJyID0gaW5pdGlhbERhdGEuZXJyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYXBwRW50cnlwb2ludCA9IHlpZWxkIHBhZ2VMb2FkZXIucm91dGVMb2FkZXIud2hlbkVudHJ5cG9pbnQoJy9fYXBwJyk7XG4gICAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiBhcHBFbnRyeXBvaW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYXBwRW50cnlwb2ludC5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgY29tcG9uZW50OiBhcHAgLCBleHBvcnRzOiBtb2QgIH0gPSBhcHBFbnRyeXBvaW50O1xuICAgICAgICAgICAgQ2FjaGVkQXBwID0gYXBwO1xuICAgICAgICAgICAgaWYgKG1vZCAmJiBtb2QucmVwb3J0V2ViVml0YWxzKSB7XG4gICAgICAgICAgICAgICAgb25QZXJmRW50cnkgPSAoeyBpZCAsIG5hbWUgLCBzdGFydFRpbWUgLCB2YWx1ZSAsIGR1cmF0aW9uICwgZW50cnlUeXBlICwgZW50cmllcyAsIGF0dHJpYnV0aW9uICB9KT0+e1xuICAgICAgICAgICAgICAgICAgICAvLyBDb21iaW5lcyB0aW1lc3RhbXAgd2l0aCByYW5kb20gbnVtYmVyIGZvciB1bmlxdWUgSURcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdW5pcXVlSUQgPSBgJHtEYXRlLm5vdygpfS0ke01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqICg5ZTEyIC0gMSkpICsgMWUxMn1gO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGVyZlN0YXJ0RW50cnk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbnRyaWVzICYmIGVudHJpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJmU3RhcnRFbnRyeSA9IGVudHJpZXNbMF0uc3RhcnRUaW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdlYlZpdGFscyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCB8fCB1bmlxdWVJRCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWU6IHN0YXJ0VGltZSB8fCBwZXJmU3RhcnRFbnRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSA9PSBudWxsID8gZHVyYXRpb24gOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBlbnRyeVR5cGUgPT09ICdtYXJrJyB8fCBlbnRyeVR5cGUgPT09ICdtZWFzdXJlJyA/ICdjdXN0b20nIDogJ3dlYi12aXRhbCdcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWJWaXRhbHMuYXR0cmlidXRpb24gPSBhdHRyaWJ1dGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtb2QucmVwb3J0V2ViVml0YWxzKHdlYlZpdGFscyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhZ2VFbnRyeXBvaW50ID0gLy8gVGhlIGRldiBzZXJ2ZXIgZmFpbHMgdG8gc2VydmUgc2NyaXB0IGFzc2V0cyB3aGVuIHRoZXJlJ3MgYSBoeWRyYXRpb25cbiAgICAgICAgICAgIC8vIGVycm9yLCBzbyB3ZSBuZWVkIHRvIHNraXAgd2FpdGluZyBmb3IgdGhlIGVudHJ5cG9pbnQuXG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiBpbml0aWFsRGF0YS5lcnIgPyB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IGluaXRpYWxEYXRhLmVyclxuICAgICAgICAgICAgfSA6IHlpZWxkIHBhZ2VMb2FkZXIucm91dGVMb2FkZXIud2hlbkVudHJ5cG9pbnQoaW5pdGlhbERhdGEucGFnZSk7XG4gICAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiBwYWdlRW50cnlwb2ludCkge1xuICAgICAgICAgICAgICAgIHRocm93IHBhZ2VFbnRyeXBvaW50LmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQ2FjaGVkQ29tcG9uZW50ID0gcGFnZUVudHJ5cG9pbnQuY29tcG9uZW50O1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGlzVmFsaWRFbGVtZW50VHlwZSAgfSA9IHJlcXVpcmUoJ25leHQvZGlzdC9jb21waWxlZC9yZWFjdC1pcycpO1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKENhY2hlZENvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZGVmYXVsdCBleHBvcnQgaXMgbm90IGEgUmVhY3QgQ29tcG9uZW50IGluIHBhZ2U6IFwiJHtpbml0aWFsRGF0YS5wYWdlfVwiYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcjEpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY2F0Y2hlcyBlcnJvcnMgbGlrZSB0aHJvd2luZyBpbiB0aGUgdG9wIGxldmVsIG9mIGEgbW9kdWxlXG4gICAgICAgICAgICBpbml0aWFsRXJyID0gKDAsIF9pc0Vycm9yKS5nZXRQcm9wZXJFcnJvcihlcnJvcjEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgY29uc3QgeyBnZXRTZXJ2ZXJFcnJvciAsICB9ID0gcmVxdWlyZSgnbmV4dC9kaXN0L2NvbXBpbGVkL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2Rpc3QvY2xpZW50Jyk7XG4gICAgICAgICAgICAvLyBTZXJ2ZXItc2lkZSBydW50aW1lIGVycm9ycyBuZWVkIHRvIGJlIHJlLXRocm93biBvbiB0aGUgY2xpZW50LXNpZGUgc29cbiAgICAgICAgICAgIC8vIHRoYXQgdGhlIG92ZXJsYXkgaXMgcmVuZGVyZWQuXG4gICAgICAgICAgICBpZiAoaW5pdGlhbEVycikge1xuICAgICAgICAgICAgICAgIGlmIChpbml0aWFsRXJyID09PSBpbml0aWFsRGF0YS5lcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSBhIG5ldyBlcnJvciBvYmplY3QuIFdlIGB0aHJvd2AgaXQgYmVjYXVzZSBzb21lIGJyb3dzZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCBzZXQgdGhlIGBzdGFja2Agd2hlbiB0aHJvd24sIGFuZCB3ZSB3YW50IHRvIGVuc3VyZSBvdXJzIGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90IG92ZXJyaWRkZW4gd2hlbiB3ZSByZS10aHJvdyBpdCBiZWxvdy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoaW5pdGlhbEVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5uYW1lID0gaW5pdGlhbEVyci5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3Iuc3RhY2sgPSBpbml0aWFsRXJyLnN0YWNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZ2V0U2VydmVyRXJyb3IoZXJyb3IsIGluaXRpYWxFcnIuc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgaW5pdGlhbEVycjtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh3aW5kb3cuX19ORVhUX1BSRUxPQURSRUFEWSkge1xuICAgICAgICAgICAgeWllbGQgd2luZG93Ll9fTkVYVF9QUkVMT0FEUkVBRFkoaW5pdGlhbERhdGEuZHluYW1pY0lkcyk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0cy5yb3V0ZXIgPSByb3V0ZXIgPSAoMCwgX3JvdXRlcikuY3JlYXRlUm91dGVyKGluaXRpYWxEYXRhLnBhZ2UsIGluaXRpYWxEYXRhLnF1ZXJ5LCBhc1BhdGgsIHtcbiAgICAgICAgICAgIGluaXRpYWxQcm9wczogaW5pdGlhbERhdGEucHJvcHMsXG4gICAgICAgICAgICBwYWdlTG9hZGVyLFxuICAgICAgICAgICAgQXBwOiBDYWNoZWRBcHAsXG4gICAgICAgICAgICBDb21wb25lbnQ6IENhY2hlZENvbXBvbmVudCxcbiAgICAgICAgICAgIHdyYXBBcHAsXG4gICAgICAgICAgICBlcnI6IGluaXRpYWxFcnIsXG4gICAgICAgICAgICBpc0ZhbGxiYWNrOiBCb29sZWFuKGluaXRpYWxEYXRhLmlzRmFsbGJhY2spLFxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uOiAoaW5mbywgQXBwLCBzY3JvbGwpPT5yZW5kZXIoT2JqZWN0LmFzc2lnbih7fSwgaW5mbywge1xuICAgICAgICAgICAgICAgICAgICBBcHAsXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFxuICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgIGxvY2FsZTogaW5pdGlhbERhdGEubG9jYWxlLFxuICAgICAgICAgICAgbG9jYWxlczogaW5pdGlhbERhdGEubG9jYWxlcyxcbiAgICAgICAgICAgIGRlZmF1bHRMb2NhbGUsXG4gICAgICAgICAgICBkb21haW5Mb2NhbGVzOiBpbml0aWFsRGF0YS5kb21haW5Mb2NhbGVzLFxuICAgICAgICAgICAgaXNQcmV2aWV3OiBpbml0aWFsRGF0YS5pc1ByZXZpZXdcbiAgICAgICAgfSk7XG4gICAgICAgIGluaXRpYWxNYXRjaGVzTWlkZGxld2FyZSA9IHlpZWxkIHJvdXRlci5faW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlUHJvbWlzZTtcbiAgICAgICAgY29uc3QgcmVuZGVyQ3R4ID0ge1xuICAgICAgICAgICAgQXBwOiBDYWNoZWRBcHAsXG4gICAgICAgICAgICBpbml0aWFsOiB0cnVlLFxuICAgICAgICAgICAgQ29tcG9uZW50OiBDYWNoZWRDb21wb25lbnQsXG4gICAgICAgICAgICBwcm9wczogaW5pdGlhbERhdGEucHJvcHMsXG4gICAgICAgICAgICBlcnI6IGluaXRpYWxFcnJcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuYmVmb3JlUmVuZGVyKSB7XG4gICAgICAgICAgICB5aWVsZCBvcHRzLmJlZm9yZVJlbmRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJlbmRlcihyZW5kZXJDdHgpO1xuICAgIH0pO1xuICAgIHJldHVybiBfaHlkcmF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJpbml0aWFsaXplIiwiaHlkcmF0ZSIsImVtaXR0ZXIiLCJyb3V0ZXIiLCJ2ZXJzaW9uIiwiX2FzeW5jX3RvX2dlbmVyYXRvciIsInJlcXVpcmUiLCJkZWZhdWx0IiwiX2V4dGVuZHMiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwiX3JlYWN0IiwiX2NsaWVudCIsIl9oZWFkTWFuYWdlckNvbnRleHQiLCJfbWl0dCIsIl9yb3V0ZXJDb250ZXh0IiwiX2lzRHluYW1pYyIsIl9xdWVyeXN0cmluZyIsIl9ydW50aW1lQ29uZmlnIiwiX3V0aWxzIiwiX3BvcnRhbCIsIl9oZWFkTWFuYWdlciIsIl9wYWdlTG9hZGVyIiwiX3BlcmZvcm1hbmNlUmVsYXllciIsIl9yb3V0ZUFubm91bmNlciIsIl9yb3V0ZXIiLCJfaXNFcnJvciIsIl9pbWFnZUNvbmZpZ0NvbnRleHQiLCJfcmVtb3ZlQmFzZVBhdGgiLCJfaGFzQmFzZVBhdGgiLCJfYXBwUm91dGVyQ29udGV4dCIsIl9hZGFwdGVycyIsIl9ob29rc0NsaWVudENvbnRleHQiLCJsb29zZVRvQXJyYXkiLCJpbnB1dCIsInNsaWNlIiwiY2FsbCIsImluaXRpYWxEYXRhIiwiZGVmYXVsdExvY2FsZSIsInVuZGVmaW5lZCIsImFzUGF0aCIsInBhZ2VMb2FkZXIiLCJhcHBFbGVtZW50IiwiaGVhZE1hbmFnZXIiLCJpbml0aWFsTWF0Y2hlc01pZGRsZXdhcmUiLCJsYXN0QXBwUHJvcHMiLCJsYXN0UmVuZGVyUmVqZWN0Iiwid2VicGFja0hNUiIsIkNhY2hlZEFwcCIsIm9uUGVyZkVudHJ5IiwiQ2FjaGVkQ29tcG9uZW50Iiwic2VsZiIsIl9fbmV4dF9yZXF1aXJlX18iLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwiQ29udGFpbmVyIiwiQ29tcG9uZW50IiwiY29tcG9uZW50RGlkQ2F0Y2giLCJjb21wb25lbnRFcnIiLCJpbmZvIiwicHJvcHMiLCJmbiIsImNvbXBvbmVudERpZE1vdW50Iiwic2Nyb2xsVG9IYXNoIiwiaXNTc3IiLCJwYWdlIiwiaXNGYWxsYmFjayIsIm5leHRFeHBvcnQiLCJpc0R5bmFtaWNSb3V0ZSIsInBhdGhuYW1lIiwibG9jYXRpb24iLCJzZWFyY2giLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0hBU19SRVdSSVRFUyIsIl9fTl9TU0ciLCJyZXBsYWNlIiwiU3RyaW5nIiwiYXNzaWduIiwidXJsUXVlcnlUb1NlYXJjaFBhcmFtcyIsInF1ZXJ5IiwiVVJMU2VhcmNoUGFyYW1zIiwiX2giLCJzaGFsbG93IiwiY2F0Y2giLCJlcnIiLCJjYW5jZWxsZWQiLCJjb21wb25lbnREaWRVcGRhdGUiLCJoYXNoIiwic3Vic3RyaW5nIiwiZWwiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwic2V0VGltZW91dCIsInNjcm9sbEludG9WaWV3IiwicmVuZGVyIiwiY2hpbGRyZW4iLCJSZWFjdERldk92ZXJsYXkiLCJjcmVhdGVFbGVtZW50IiwiX2luaXRpYWxpemUiLCJhcHBseSIsImFyZ3VtZW50cyIsIm9wdHMiLCJKU09OIiwicGFyc2UiLCJ0ZXh0Q29udGVudCIsIndpbmRvdyIsIl9fTkVYVF9EQVRBX18iLCJwcmVmaXgiLCJhc3NldFByZWZpeCIsIl9fd2VicGFja19wdWJsaWNfcGF0aF9fIiwic2V0Q29uZmlnIiwic2VydmVyUnVudGltZUNvbmZpZyIsInB1YmxpY1J1bnRpbWVDb25maWciLCJydW50aW1lQ29uZmlnIiwiZ2V0VVJMIiwiaGFzQmFzZVBhdGgiLCJyZW1vdmVCYXNlUGF0aCIsIl9fTkVYVF9JMThOX1NVUFBPUlQiLCJub3JtYWxpemVMb2NhbGVQYXRoIiwiZGV0ZWN0RG9tYWluTG9jYWxlIiwicGFyc2VSZWxhdGl2ZVVybCIsImZvcm1hdFVybCIsImxvY2FsZXMiLCJwYXJzZWRBcyIsImxvY2FsZVBhdGhSZXN1bHQiLCJkZXRlY3RlZExvY2FsZSIsImxvY2FsZSIsImRldGVjdGVkRG9tYWluIiwiX19ORVhUX0kxOE5fRE9NQUlOUyIsImhvc3RuYW1lIiwic2NyaXB0TG9hZGVyIiwiaW5pdFNjcmlwdExvYWRlciIsImJ1aWxkSWQiLCJyZWdpc3RlciIsInIiLCJmIiwicm91dGVMb2FkZXIiLCJvbkVudHJ5cG9pbnQiLCJfX05FWFRfUCIsIm1hcCIsInAiLCJwdXNoIiwiZ2V0SXNTc3IiLCJyZW5kZXJBcHAiLCJBcHAiLCJhcHBQcm9wcyIsIkFwcENvbnRhaW5lciIsIl9hdXRvRXhwb3J0IiwiZXJyb3IiLCJyZW5kZXJFcnJvciIsImNvbnNvbGUiLCJBcHBSb3V0ZXJDb250ZXh0IiwiUHJvdmlkZXIiLCJhZGFwdEZvckFwcFJvdXRlckluc3RhbmNlIiwiU2VhcmNoUGFyYW1zQ29udGV4dCIsImFkYXB0Rm9yU2VhcmNoUGFyYW1zIiwiUGF0aG5hbWVDb250ZXh0UHJvdmlkZXJBZGFwdGVyIiwiaXNBdXRvRXhwb3J0IiwiYXV0b0V4cG9ydCIsIlJvdXRlckNvbnRleHQiLCJtYWtlUHVibGljUm91dGVySW5zdGFuY2UiLCJIZWFkTWFuYWdlckNvbnRleHQiLCJJbWFnZUNvbmZpZ0NvbnRleHQiLCJfX05FWFRfSU1BR0VfT1BUUyIsIndyYXBBcHAiLCJ3cmFwcGVkQXBwUHJvcHMiLCJyZW5kZXJFcnJvclByb3BzIiwib25VbnJlY292ZXJhYmxlRXJyb3IiLCJkb1JlbmRlciIsInN0eWxlU2hlZXRzIiwibG9hZFBhZ2UiLCJ0aGVuIiwiRXJyb3JDb21wb25lbnQiLCJlcnJvck1vZHVsZSIsImFwcE1vZHVsZSIsIm0iLCJyZWYiLCJBcHBUcmVlIiwiYXBwQ3R4IiwiY3R4IiwiUHJvbWlzZSIsInJlc29sdmUiLCJsb2FkR2V0SW5pdGlhbFByb3BzIiwiaW5pdFByb3BzIiwiSGVhZCIsImNhbGxiYWNrIiwidXNlTGF5b3V0RWZmZWN0IiwicmVhY3RSb290Iiwic2hvdWxkSHlkcmF0ZSIsImNsZWFyTWFya3MiLCJmb3JFYWNoIiwibWFyayIsInBlcmZvcm1hbmNlIiwibWFya0h5ZHJhdGVDb21wbGV0ZSIsIlNUIiwibWVhc3VyZSIsImdldEVudHJpZXNCeU5hbWUiLCJtYXJrUmVuZGVyQ29tcGxldGUiLCJuYXZTdGFydEVudHJpZXMiLCJsZW5ndGgiLCJuYW1lIiwiY2xlYXJNZWFzdXJlcyIsInJlbmRlclJlYWN0RWxlbWVudCIsImRvbUVsIiwicmVhY3RFbCIsImh5ZHJhdGVSb290Iiwic3RhcnRUcmFuc2l0aW9uIiwiUm9vdCIsImNhbGxiYWNrcyIsInVzZUVmZmVjdCIsIl9fTkVYVF9URVNUX01PREUiLCJfX05FWFRfSFlEUkFURUQiLCJfX05FWFRfSFlEUkFURURfQ0IiLCJjYW5jZWxlZCIsInJlc29sdmVQcm9taXNlIiwicmVuZGVyUHJvbWlzZSIsInJlamVjdCIsIkVycm9yIiwib25TdGFydCIsImN1cnJlbnRTdHlsZVRhZ3MiLCJxdWVyeVNlbGVjdG9yQWxsIiwiY3VycmVudEhyZWZzIiwiU2V0IiwidGFnIiwiZ2V0QXR0cmlidXRlIiwibm9zY3JpcHQiLCJxdWVyeVNlbGVjdG9yIiwibm9uY2UiLCJocmVmIiwidGV4dCIsImhhcyIsInN0eWxlVGFnIiwic2V0QXR0cmlidXRlIiwiaGVhZCIsImFwcGVuZENoaWxkIiwiY3JlYXRlVGV4dE5vZGUiLCJvbkhlYWRDb21taXQiLCJkZXNpcmVkSHJlZnMiLCJzIiwiaWR4IiwicmVtb3ZlQXR0cmlidXRlIiwicmVmZXJlbmNlTm9kZSIsInRhcmdldFRhZyIsInBhcmVudE5vZGUiLCJpbnNlcnRCZWZvcmUiLCJuZXh0U2libGluZyIsInJlbW92ZUNoaWxkIiwic2Nyb2xsIiwiaHRtbEVsZW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJleGlzdGluZyIsInN0eWxlIiwic2Nyb2xsQmVoYXZpb3IiLCJzY3JvbGxUbyIsIngiLCJ5Iiwib25Sb290Q29tbWl0IiwiZWxlbSIsIkZyYWdtZW50IiwiUG9ydGFsIiwidHlwZSIsIlJvdXRlQW5ub3VuY2VyIiwiX19ORVhUX1NUUklDVF9NT0RFIiwiU3RyaWN0TW9kZSIsInJlbmRlcmluZ1Byb3BzIiwiX3JlbmRlciIsInJlbmRlckVyciIsImdldFByb3BlckVycm9yIiwiX2h5ZHJhdGUiLCJpbml0aWFsRXJyIiwiYXBwRW50cnlwb2ludCIsIndoZW5FbnRyeXBvaW50IiwiY29tcG9uZW50IiwiYXBwIiwibW9kIiwicmVwb3J0V2ViVml0YWxzIiwiaWQiLCJzdGFydFRpbWUiLCJkdXJhdGlvbiIsImVudHJ5VHlwZSIsImVudHJpZXMiLCJhdHRyaWJ1dGlvbiIsInVuaXF1ZUlEIiwiTWF0aCIsIkRhdGUiLCJub3ciLCJmbG9vciIsInJhbmRvbSIsInBlcmZTdGFydEVudHJ5Iiwid2ViVml0YWxzIiwibGFiZWwiLCJwYWdlRW50cnlwb2ludCIsImlzVmFsaWRFbGVtZW50VHlwZSIsImVycm9yMSIsImdldFNlcnZlckVycm9yIiwibWVzc2FnZSIsImUiLCJzdGFjayIsInNvdXJjZSIsIl9fTkVYVF9QUkVMT0FEUkVBRFkiLCJkeW5hbWljSWRzIiwiY3JlYXRlUm91dGVyIiwiaW5pdGlhbFByb3BzIiwiQm9vbGVhbiIsInN1YnNjcmlwdGlvbiIsImRvbWFpbkxvY2FsZXMiLCJpc1ByZXZpZXciLCJfaW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlUHJvbWlzZSIsInJlbmRlckN0eCIsImluaXRpYWwiLCJiZWZvcmVSZW5kZXIiLCJfX2VzTW9kdWxlIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/index.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/next-dev.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/client/next-dev.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _ = __webpack_require__(/*! ./ */ \"./node_modules/next/dist/client/index.js\");\nvar _onDemandEntriesClient = _interop_require_default(__webpack_require__(/*! ./dev/on-demand-entries-client */ \"./node_modules/next/dist/client/dev/on-demand-entries-client.js\"));\nvar _webpackHotMiddlewareClient = _interop_require_default(__webpack_require__(/*! ./dev/webpack-hot-middleware-client */ \"./node_modules/next/dist/client/dev/webpack-hot-middleware-client.js\"));\nvar _devBuildWatcher = _interop_require_default(__webpack_require__(/*! ./dev/dev-build-watcher */ \"./node_modules/next/dist/client/dev/dev-build-watcher.js\"));\nvar _fouc = __webpack_require__(/*! ./dev/fouc */ \"./node_modules/next/dist/client/dev/fouc.js\");\nvar _websocket = __webpack_require__(/*! ./dev/error-overlay/websocket */ \"./node_modules/next/dist/client/dev/error-overlay/websocket.js\");\nvar _querystring = __webpack_require__(/*! ../shared/lib/router/utils/querystring */ \"./node_modules/next/dist/shared/lib/router/utils/querystring.js\");\nif (!window._nextSetupHydrationWarning) {\n    const origConsoleError = window.console.error;\n    window.console.error = function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        const isHydrateError = args.some((arg)=>typeof arg === \"string\" && arg.match(/(hydration|content does not match|did not match)/i));\n        if (isHydrateError) {\n            args = [\n                ...args,\n                \"\\n\\nSee more info here: https://nextjs.org/docs/messages/react-hydration-error\"\n            ];\n        }\n        origConsoleError.apply(window.console, args);\n    };\n    window._nextSetupHydrationWarning = true;\n}\nwindow.next = {\n    version: _.version,\n    // router is initialized later so it has to be live-binded\n    get router () {\n        return _.router;\n    },\n    emitter: _.emitter\n};\nconst webpackHMR = (0, _webpackHotMiddlewareClient).default();\n(0, _).initialize({\n    webpackHMR\n}).then((param)=>{\n    let { assetPrefix  } = param;\n    (0, _websocket).connectHMR({\n        assetPrefix,\n        path: \"/_next/webpack-hmr\"\n    });\n    return (0, _).hydrate({\n        beforeRender: _fouc.displayContent\n    }).then(()=>{\n        (0, _onDemandEntriesClient).default();\n        let buildIndicatorHandler = ()=>{};\n        function devPagesManifestListener(event) {\n            if (event.data.indexOf(\"devPagesManifest\") !== -1) {\n                fetch(\"\".concat(assetPrefix, \"/_next/static/development/_devPagesManifest.json\")).then((res)=>res.json()).then((manifest)=>{\n                    window.__DEV_PAGES_MANIFEST = manifest;\n                }).catch((err)=>{\n                    console.log(\"Failed to fetch devPagesManifest\", err);\n                });\n            } else if (event.data.indexOf(\"middlewareChanges\") !== -1) {\n                return window.location.reload();\n            } else if (event.data.indexOf(\"serverOnlyChanges\") !== -1) {\n                const { pages  } = JSON.parse(event.data);\n                // Make sure to reload when the dev-overlay is showing for an\n                // API route\n                if (pages.includes(_.router.query.__NEXT_PAGE)) {\n                    return window.location.reload();\n                }\n                if (!_.router.clc && pages.includes(_.router.pathname)) {\n                    console.log(\"Refreshing page data due to server-side change\");\n                    buildIndicatorHandler(\"building\");\n                    const clearIndicator = ()=>buildIndicatorHandler(\"built\");\n                    _.router.replace(_.router.pathname + \"?\" + String((0, _querystring).assign((0, _querystring).urlQueryToSearchParams(_.router.query), new URLSearchParams(location.search))), _.router.asPath, {\n                        scroll: false\n                    }).catch(()=>{\n                        // trigger hard reload when failing to refresh data\n                        // to show error overlay properly\n                        location.reload();\n                    }).finally(clearIndicator);\n                }\n            }\n        }\n        (0, _websocket).addMessageListener(devPagesManifestListener);\n        if (true) {\n            (0, _devBuildWatcher).default((handler)=>{\n                buildIndicatorHandler = handler;\n            }, \"bottom-right\");\n        }\n    });\n}).catch((err)=>{\n    console.error(\"Error was not caught\", err);\n});\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=next-dev.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9uZXh0LWRldi5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLDJCQUEyQkMsbUpBQStEO0FBQzlGLElBQUlFLElBQUlGLG1CQUFPQSxDQUFDLG9EQUFJO0FBQ3BCLElBQUlHLHlCQUF5QkoseUJBQXlCQyxtQkFBT0EsQ0FBQyx1R0FBZ0M7QUFDOUYsSUFBSUksOEJBQThCTCx5QkFBeUJDLG1CQUFPQSxDQUFDLGlIQUFxQztBQUN4RyxJQUFJSyxtQkFBbUJOLHlCQUF5QkMsbUJBQU9BLENBQUMseUZBQXlCO0FBQ2pGLElBQUlNLFFBQVFOLG1CQUFPQSxDQUFDLCtEQUFZO0FBQ2hDLElBQUlPLGFBQWFQLG1CQUFPQSxDQUFDLHFHQUErQjtBQUN4RCxJQUFJUSxlQUFlUixtQkFBT0EsQ0FBQywrR0FBd0M7QUFDbkUsSUFBSSxDQUFDUyxPQUFPQywwQkFBMEIsRUFBRTtJQUNwQyxNQUFNQyxtQkFBbUJGLE9BQU9HLE9BQU8sQ0FBQ0MsS0FBSztJQUM3Q0osT0FBT0csT0FBTyxDQUFDQyxLQUFLLEdBQUcsV0FBVzt5Q0FBUEM7WUFBQUE7O1FBQ3ZCLE1BQU1DLGlCQUFpQkQsS0FBS0UsSUFBSSxDQUFDLENBQUNDLE1BQU0sT0FBT0EsUUFBUSxZQUFZQSxJQUFJQyxLQUFLLENBQUM7UUFDN0UsSUFBSUgsZ0JBQWdCO1lBQ2hCRCxPQUFPO21CQUNBQTtnQkFDRjthQUNKO1FBQ0wsQ0FBQztRQUNESCxpQkFBaUJRLEtBQUssQ0FBQ1YsT0FBT0csT0FBTyxFQUFFRTtJQUMzQztJQUNBTCxPQUFPQywwQkFBMEIsR0FBRyxJQUFJO0FBQzVDLENBQUM7QUFDREQsT0FBT1csSUFBSSxHQUFHO0lBQ1ZDLFNBQVNuQixFQUFFbUIsT0FBTztJQUNsQiwwREFBMEQ7SUFDMUQsSUFBSUMsVUFBVTtRQUNWLE9BQU9wQixFQUFFb0IsTUFBTTtJQUNuQjtJQUNBQyxTQUFTckIsRUFBRXFCLE9BQU87QUFDdEI7QUFDQSxN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T0FBTzRCLFFBQVF2RSxPQUFPLEtBQUssY0FBZSxPQUFPdUUsUUFBUXZFLE9BQU8sS0FBSyxZQUFZdUUsUUFBUXZFLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT3VFLFFBQVF2RSxPQUFPLENBQUN3RSxVQUFVLEtBQUssYUFBYTtJQUNyS0MsT0FBT0MsY0FBYyxDQUFDSCxRQUFRdkUsT0FBTyxFQUFFLGNBQWM7UUFBRTJFLE9BQU8sSUFBSTtJQUFDO0lBQ25FRixPQUFPZixNQUFNLENBQUNhLFFBQVF2RSxPQUFPLEVBQUV1RTtJQUMvQkssT0FBT0wsT0FBTyxHQUFHQSxRQUFRdkUsT0FBTztBQUNsQyxDQUFDLENBRUQsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L25leHQtZGV2LmpzPzM1MTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0LmpzXCIpLmRlZmF1bHQ7XG52YXIgXyA9IHJlcXVpcmUoXCIuL1wiKTtcbnZhciBfb25EZW1hbmRFbnRyaWVzQ2xpZW50ID0gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KHJlcXVpcmUoXCIuL2Rldi9vbi1kZW1hbmQtZW50cmllcy1jbGllbnRcIikpO1xudmFyIF93ZWJwYWNrSG90TWlkZGxld2FyZUNsaWVudCA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwiLi9kZXYvd2VicGFjay1ob3QtbWlkZGxld2FyZS1jbGllbnRcIikpO1xudmFyIF9kZXZCdWlsZFdhdGNoZXIgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcIi4vZGV2L2Rldi1idWlsZC13YXRjaGVyXCIpKTtcbnZhciBfZm91YyA9IHJlcXVpcmUoXCIuL2Rldi9mb3VjXCIpO1xudmFyIF93ZWJzb2NrZXQgPSByZXF1aXJlKFwiLi9kZXYvZXJyb3Itb3ZlcmxheS93ZWJzb2NrZXRcIik7XG52YXIgX3F1ZXJ5c3RyaW5nID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3F1ZXJ5c3RyaW5nXCIpO1xuaWYgKCF3aW5kb3cuX25leHRTZXR1cEh5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICBjb25zdCBvcmlnQ29uc29sZUVycm9yID0gd2luZG93LmNvbnNvbGUuZXJyb3I7XG4gICAgd2luZG93LmNvbnNvbGUuZXJyb3IgPSAoLi4uYXJncyk9PntcbiAgICAgICAgY29uc3QgaXNIeWRyYXRlRXJyb3IgPSBhcmdzLnNvbWUoKGFyZyk9PnR5cGVvZiBhcmcgPT09ICdzdHJpbmcnICYmIGFyZy5tYXRjaCgvKGh5ZHJhdGlvbnxjb250ZW50IGRvZXMgbm90IG1hdGNofGRpZCBub3QgbWF0Y2gpL2kpKTtcbiAgICAgICAgaWYgKGlzSHlkcmF0ZUVycm9yKSB7XG4gICAgICAgICAgICBhcmdzID0gW1xuICAgICAgICAgICAgICAgIC4uLmFyZ3MsXG4gICAgICAgICAgICAgICAgYFxcblxcblNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvcmVhY3QtaHlkcmF0aW9uLWVycm9yYCwgXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIG9yaWdDb25zb2xlRXJyb3IuYXBwbHkod2luZG93LmNvbnNvbGUsIGFyZ3MpO1xuICAgIH07XG4gICAgd2luZG93Ll9uZXh0U2V0dXBIeWRyYXRpb25XYXJuaW5nID0gdHJ1ZTtcbn1cbndpbmRvdy5uZXh0ID0ge1xuICAgIHZlcnNpb246IF8udmVyc2lvbixcbiAgICAvLyByb3V0ZXIgaXMgaW5pdGlhbGl6ZWQgbGF0ZXIgc28gaXQgaGFzIHRvIGJlIGxpdmUtYmluZGVkXG4gICAgZ2V0IHJvdXRlciAoKSB7XG4gICAgICAgIHJldHVybiBfLnJvdXRlcjtcbiAgICB9LFxuICAgIGVtaXR0ZXI6IF8uZW1pdHRlclxufTtcbmNvbnN0IHdlYnBhY2tITVIgPSAoMCwgX3dlYnBhY2tIb3RNaWRkbGV3YXJlQ2xpZW50KS5kZWZhdWx0KCk7XG4oMCwgXykuaW5pdGlhbGl6ZSh7XG4gICAgd2VicGFja0hNUlxufSkudGhlbigoeyBhc3NldFByZWZpeCAgfSk9PntcbiAgICAoMCwgX3dlYnNvY2tldCkuY29ubmVjdEhNUih7XG4gICAgICAgIGFzc2V0UHJlZml4LFxuICAgICAgICBwYXRoOiAnL19uZXh0L3dlYnBhY2staG1yJ1xuICAgIH0pO1xuICAgIHJldHVybiAoMCwgXykuaHlkcmF0ZSh7XG4gICAgICAgIGJlZm9yZVJlbmRlcjogX2ZvdWMuZGlzcGxheUNvbnRlbnRcbiAgICB9KS50aGVuKCgpPT57XG4gICAgICAgICgwLCBfb25EZW1hbmRFbnRyaWVzQ2xpZW50KS5kZWZhdWx0KCk7XG4gICAgICAgIGxldCBidWlsZEluZGljYXRvckhhbmRsZXIgPSAoKT0+e307XG4gICAgICAgIGZ1bmN0aW9uIGRldlBhZ2VzTWFuaWZlc3RMaXN0ZW5lcihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGEuaW5kZXhPZignZGV2UGFnZXNNYW5pZmVzdCcpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGZldGNoKGAke2Fzc2V0UHJlZml4fS9fbmV4dC9zdGF0aWMvZGV2ZWxvcG1lbnQvX2RldlBhZ2VzTWFuaWZlc3QuanNvbmApLnRoZW4oKHJlcyk9PnJlcy5qc29uKCkpLnRoZW4oKG1hbmlmZXN0KT0+e1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuX19ERVZfUEFHRVNfTUFOSUZFU1QgPSBtYW5pZmVzdDtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRmFpbGVkIHRvIGZldGNoIGRldlBhZ2VzTWFuaWZlc3RgLCBlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC5kYXRhLmluZGV4T2YoJ21pZGRsZXdhcmVDaGFuZ2VzJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGF0YS5pbmRleE9mKCdzZXJ2ZXJPbmx5Q2hhbmdlcycpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGFnZXMgIH0gPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0byByZWxvYWQgd2hlbiB0aGUgZGV2LW92ZXJsYXkgaXMgc2hvd2luZyBmb3IgYW5cbiAgICAgICAgICAgICAgICAvLyBBUEkgcm91dGVcbiAgICAgICAgICAgICAgICBpZiAocGFnZXMuaW5jbHVkZXMoXy5yb3V0ZXIucXVlcnkuX19ORVhUX1BBR0UpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghXy5yb3V0ZXIuY2xjICYmIHBhZ2VzLmluY2x1ZGVzKF8ucm91dGVyLnBhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUmVmcmVzaGluZyBwYWdlIGRhdGEgZHVlIHRvIHNlcnZlci1zaWRlIGNoYW5nZScpO1xuICAgICAgICAgICAgICAgICAgICBidWlsZEluZGljYXRvckhhbmRsZXIoJ2J1aWxkaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsZWFySW5kaWNhdG9yID0gKCk9PmJ1aWxkSW5kaWNhdG9ySGFuZGxlcignYnVpbHQnKTtcbiAgICAgICAgICAgICAgICAgICAgXy5yb3V0ZXIucmVwbGFjZShfLnJvdXRlci5wYXRobmFtZSArICc/JyArIFN0cmluZygoMCwgX3F1ZXJ5c3RyaW5nKS5hc3NpZ24oKDAsIF9xdWVyeXN0cmluZykudXJsUXVlcnlUb1NlYXJjaFBhcmFtcyhfLnJvdXRlci5xdWVyeSksIG5ldyBVUkxTZWFyY2hQYXJhbXMobG9jYXRpb24uc2VhcmNoKSkpLCBfLnJvdXRlci5hc1BhdGgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyaWdnZXIgaGFyZCByZWxvYWQgd2hlbiBmYWlsaW5nIHRvIHJlZnJlc2ggZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gc2hvdyBlcnJvciBvdmVybGF5IHByb3Blcmx5XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSkuZmluYWxseShjbGVhckluZGljYXRvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICgwLCBfd2Vic29ja2V0KS5hZGRNZXNzYWdlTGlzdGVuZXIoZGV2UGFnZXNNYW5pZmVzdExpc3RlbmVyKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9CVUlMRF9JTkRJQ0FUT1IpIHtcbiAgICAgICAgICAgICgwLCBfZGV2QnVpbGRXYXRjaGVyKS5kZWZhdWx0KChoYW5kbGVyKT0+e1xuICAgICAgICAgICAgICAgIGJ1aWxkSW5kaWNhdG9ySGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgICAgICB9LCBwcm9jZXNzLmVudi5fX05FWFRfQlVJTERfSU5ESUNBVE9SX1BPU0lUSU9OKTtcbiAgICAgICAgfVxuICAgIH0pO1xufSkuY2F0Y2goKGVycik9PntcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB3YXMgbm90IGNhdWdodCcsIGVycik7XG59KTtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV4dC1kZXYuanMubWFwIl0sIm5hbWVzIjpbIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJkZWZhdWx0IiwiXyIsIl9vbkRlbWFuZEVudHJpZXNDbGllbnQiLCJfd2VicGFja0hvdE1pZGRsZXdhcmVDbGllbnQiLCJfZGV2QnVpbGRXYXRjaGVyIiwiX2ZvdWMiLCJfd2Vic29ja2V0IiwiX3F1ZXJ5c3RyaW5nIiwid2luZG93IiwiX25leHRTZXR1cEh5ZHJhdGlvbldhcm5pbmciLCJvcmlnQ29uc29sZUVycm9yIiwiY29uc29sZSIsImVycm9yIiwiYXJncyIsImlzSHlkcmF0ZUVycm9yIiwic29tZSIsImFyZyIsIm1hdGNoIiwiYXBwbHkiLCJuZXh0IiwidmVyc2lvbiIsInJvdXRlciIsImVtaXR0ZXIiLCJ3ZWJwYWNrSE1SIiwiaW5pdGlhbGl6ZSIsInRoZW4iLCJhc3NldFByZWZpeCIsImNvbm5lY3RITVIiLCJwYXRoIiwiaHlkcmF0ZSIsImJlZm9yZVJlbmRlciIsImRpc3BsYXlDb250ZW50IiwiYnVpbGRJbmRpY2F0b3JIYW5kbGVyIiwiZGV2UGFnZXNNYW5pZmVzdExpc3RlbmVyIiwiZXZlbnQiLCJkYXRhIiwiaW5kZXhPZiIsImZldGNoIiwicmVzIiwianNvbiIsIm1hbmlmZXN0IiwiX19ERVZfUEFHRVNfTUFOSUZFU1QiLCJjYXRjaCIsImVyciIsImxvZyIsImxvY2F0aW9uIiwicmVsb2FkIiwicGFnZXMiLCJKU09OIiwicGFyc2UiLCJpbmNsdWRlcyIsInF1ZXJ5IiwiX19ORVhUX1BBR0UiLCJjbGMiLCJwYXRobmFtZSIsImNsZWFySW5kaWNhdG9yIiwicmVwbGFjZSIsIlN0cmluZyIsImFzc2lnbiIsInVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJzZWFyY2giLCJhc1BhdGgiLCJzY3JvbGwiLCJmaW5hbGx5IiwiYWRkTWVzc2FnZUxpc3RlbmVyIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9CVUlMRF9JTkRJQ0FUT1IiLCJoYW5kbGVyIiwiX19ORVhUX0JVSUxEX0lORElDQVRPUl9QT1NJVElPTiIsImV4cG9ydHMiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/next-dev.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/normalize-trailing-slash.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/normalize-trailing-slash.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.normalizePathTrailingSlash = void 0;\nvar _removeTrailingSlash = __webpack_require__(/*! ../shared/lib/router/utils/remove-trailing-slash */ \"./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nvar _parsePath = __webpack_require__(/*! ../shared/lib/router/utils/parse-path */ \"./node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\nconst normalizePathTrailingSlash = (path)=>{\n    if (!path.startsWith(\"/\")) {\n        return path;\n    }\n    const { pathname , query , hash  } = (0, _parsePath).parsePath(path);\n    if (false) {}\n    return \"\".concat((0, _removeTrailingSlash).removeTrailingSlash(pathname)).concat(query).concat(hash);\n};\nexports.normalizePathTrailingSlash = normalizePathTrailingSlash;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=normalize-trailing-slash.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2guanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsa0NBQWtDLEdBQUcsS0FBSztBQUMxQyxJQUFJRyx1QkFBdUJDLG1CQUFPQSxDQUFDLG1JQUFrRDtBQUNyRixJQUFJQyxhQUFhRCxtQkFBT0EsQ0FBQyw2R0FBdUM7QUFDaEUsTUFBTUYsNkJBQTZCLENBQUNJLE9BQU87SUFDdkMsSUFBSSxDQUFDQSxLQUFLQyxVQUFVLENBQUMsTUFBTTtRQUN2QixPQUFPRDtJQUNYLENBQUM7SUFDRCxNQUFNLEVBQUVFLFNBQVEsRUFBR0MsTUFBSyxFQUFHQyxLQUFJLEVBQUcsR0FBRyxDQUFDLEdBQUdMLFVBQVUsRUFBRU0sU0FBUyxDQUFDTDtJQUMvRCxJQUFJTSxLQUFpQyxFQUFFLEVBUXRDO0lBQ0QsT0FBTyxHQUE2REgsT0FBMUQsQ0FBQyxHQUFHTixvQkFBb0IsRUFBRWEsbUJBQW1CLENBQUNSLFdBQW9CRSxPQUFSRCxPQUFhLE9BQUxDO0FBQ2hGO0FBQ0FWLGtDQUFrQyxHQUFHRTtBQUVyQyxJQUFJLENBQUMsT0FBT0YsUUFBUWtCLE9BQU8sS0FBSyxjQUFlLE9BQU9sQixRQUFRa0IsT0FBTyxLQUFLLFlBQVlsQixRQUFRa0IsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPbEIsUUFBUWtCLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktyQixPQUFPQyxjQUFjLENBQUNDLFFBQVFrQixPQUFPLEVBQUUsY0FBYztRQUFFakIsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9zQixNQUFNLENBQUNwQixRQUFRa0IsT0FBTyxFQUFFbEI7SUFDL0JxQixPQUFPckIsT0FBTyxHQUFHQSxRQUFRa0IsT0FBTztBQUNsQyxDQUFDLENBRUQsb0RBQW9EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L25vcm1hbGl6ZS10cmFpbGluZy1zbGFzaC5qcz80YzJlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5ub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCA9IHZvaWQgMDtcbnZhciBfcmVtb3ZlVHJhaWxpbmdTbGFzaCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9yZW1vdmUtdHJhaWxpbmctc2xhc2hcIik7XG52YXIgX3BhcnNlUGF0aCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9wYXJzZS1wYXRoXCIpO1xuY29uc3Qgbm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2ggPSAocGF0aCk9PntcbiAgICBpZiAoIXBhdGguc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbiAgICBjb25zdCB7IHBhdGhuYW1lICwgcXVlcnkgLCBoYXNoICB9ID0gKDAsIF9wYXJzZVBhdGgpLnBhcnNlUGF0aChwYXRoKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1RSQUlMSU5HX1NMQVNIKSB7XG4gICAgICAgIGlmICgvXFwuW14vXStcXC8/JC8udGVzdChwYXRobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHsoMCwgX3JlbW92ZVRyYWlsaW5nU2xhc2gpLnJlbW92ZVRyYWlsaW5nU2xhc2gocGF0aG5hbWUpfSR7cXVlcnl9JHtoYXNofWA7XG4gICAgICAgIH0gZWxzZSBpZiAocGF0aG5hbWUuZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgcmV0dXJuIGAke3BhdGhuYW1lfSR7cXVlcnl9JHtoYXNofWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7cGF0aG5hbWV9LyR7cXVlcnl9JHtoYXNofWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGAkeygwLCBfcmVtb3ZlVHJhaWxpbmdTbGFzaCkucmVtb3ZlVHJhaWxpbmdTbGFzaChwYXRobmFtZSl9JHtxdWVyeX0ke2hhc2h9YDtcbn07XG5leHBvcnRzLm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoID0gbm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2g7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vcm1hbGl6ZS10cmFpbGluZy1zbGFzaC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCIsIl9yZW1vdmVUcmFpbGluZ1NsYXNoIiwicmVxdWlyZSIsIl9wYXJzZVBhdGgiLCJwYXRoIiwic3RhcnRzV2l0aCIsInBhdGhuYW1lIiwicXVlcnkiLCJoYXNoIiwicGFyc2VQYXRoIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9UUkFJTElOR19TTEFTSCIsInRlc3QiLCJyZW1vdmVUcmFpbGluZ1NsYXNoIiwiZW5kc1dpdGgiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/normalize-trailing-slash.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/page-loader.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/page-loader.js ***!
  \******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _addBasePath = __webpack_require__(/*! ./add-base-path */ \"./node_modules/next/dist/client/add-base-path.js\");\nvar _router = __webpack_require__(/*! ../shared/lib/router/router */ \"./node_modules/next/dist/shared/lib/router/router.js\");\nvar _getAssetPathFromRoute = _interop_require_default(__webpack_require__(/*! ../shared/lib/router/utils/get-asset-path-from-route */ \"./node_modules/next/dist/shared/lib/router/utils/get-asset-path-from-route.js\"));\nvar _addLocale = __webpack_require__(/*! ./add-locale */ \"./node_modules/next/dist/client/add-locale.js\");\nvar _isDynamic = __webpack_require__(/*! ../shared/lib/router/utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nvar _parseRelativeUrl = __webpack_require__(/*! ../shared/lib/router/utils/parse-relative-url */ \"./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js\");\nvar _removeTrailingSlash = __webpack_require__(/*! ../shared/lib/router/utils/remove-trailing-slash */ \"./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nvar _routeLoader = __webpack_require__(/*! ./route-loader */ \"./node_modules/next/dist/client/route-loader.js\");\nclass PageLoader {\n    getPageList() {\n        if (false) {} else {\n            if (window.__DEV_PAGES_MANIFEST) {\n                return window.__DEV_PAGES_MANIFEST.pages;\n            } else {\n                this.promisedDevPagesManifest || (this.promisedDevPagesManifest = fetch(\"\".concat(this.assetPrefix, \"/_next/static/development/_devPagesManifest.json\")).then((res)=>res.json()).then((manifest)=>{\n                    window.__DEV_PAGES_MANIFEST = manifest;\n                    return manifest.pages;\n                }).catch((err)=>{\n                    console.log(\"Failed to fetch devPagesManifest:\", err);\n                    throw new Error(\"Failed to fetch _devPagesManifest.json. Is something blocking that network request?\\n\" + \"Read more: https://nextjs.org/docs/messages/failed-to-fetch-devpagesmanifest\");\n                }));\n                return this.promisedDevPagesManifest;\n            }\n        }\n    }\n    getMiddleware() {\n        if (false) {} else {\n            if (window.__DEV_MIDDLEWARE_MATCHERS) {\n                return window.__DEV_MIDDLEWARE_MATCHERS;\n            } else {\n                if (!this.promisedMiddlewareMatchers) {\n                    // TODO: Decide what should happen when fetching fails instead of asserting\n                    // @ts-ignore\n                    this.promisedMiddlewareMatchers = fetch(\"\".concat(this.assetPrefix, \"/_next/static/\").concat(this.buildId, \"/_devMiddlewareManifest.json\")).then((res)=>res.json()).then((matchers)=>{\n                        window.__DEV_MIDDLEWARE_MATCHERS = matchers;\n                        return matchers;\n                    }).catch((err)=>{\n                        console.log(\"Failed to fetch _devMiddlewareManifest\", err);\n                    });\n                }\n                // TODO Remove this assertion as this could be undefined\n                return this.promisedMiddlewareMatchers;\n            }\n        }\n    }\n    getDataHref(params) {\n        const { asPath , href , locale  } = params;\n        const { pathname: hrefPathname , query , search  } = (0, _parseRelativeUrl).parseRelativeUrl(href);\n        const { pathname: asPathname  } = (0, _parseRelativeUrl).parseRelativeUrl(asPath);\n        const route = (0, _removeTrailingSlash).removeTrailingSlash(hrefPathname);\n        if (route[0] !== \"/\") {\n            throw new Error('Route name should start with a \"/\", got \"'.concat(route, '\"'));\n        }\n        const getHrefForSlug = (path)=>{\n            const dataRoute = (0, _getAssetPathFromRoute).default((0, _removeTrailingSlash).removeTrailingSlash((0, _addLocale).addLocale(path, locale)), \".json\");\n            return (0, _addBasePath).addBasePath(\"/_next/data/\".concat(this.buildId).concat(dataRoute).concat(search), true);\n        };\n        return getHrefForSlug(params.skipInterpolation ? asPathname : (0, _isDynamic).isDynamicRoute(route) ? (0, _router).interpolateAs(hrefPathname, asPathname, query).result : route);\n    }\n    /**\n   * @param {string} route - the route (file-system path)\n   */ _isSsg(route) {\n        return this.promisedSsgManifest.then((manifest)=>manifest.has(route));\n    }\n    loadPage(route) {\n        return this.routeLoader.loadRoute(route).then((res)=>{\n            if (\"component\" in res) {\n                return {\n                    page: res.component,\n                    mod: res.exports,\n                    styleSheets: res.styles.map((o)=>({\n                            href: o.href,\n                            text: o.content\n                        }))\n                };\n            }\n            throw res.error;\n        });\n    }\n    prefetch(route) {\n        return this.routeLoader.prefetch(route);\n    }\n    constructor(buildId, assetPrefix){\n        this.routeLoader = (0, _routeLoader).createRouteLoader(assetPrefix);\n        this.buildId = buildId;\n        this.assetPrefix = assetPrefix;\n        this.promisedSsgManifest = new Promise((resolve)=>{\n            if (window.__SSG_MANIFEST) {\n                resolve(window.__SSG_MANIFEST);\n            } else {\n                window.__SSG_MANIFEST_CB = ()=>{\n                    resolve(window.__SSG_MANIFEST);\n                };\n            }\n        });\n    }\n}\nexports[\"default\"] = PageLoader;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=page-loader.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9wYWdlLWxvYWRlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxrQkFBZSxHQUFHLEtBQUs7QUFDdkIsSUFBSUcsMkJBQTJCQyxtSkFBK0Q7QUFDOUYsSUFBSUMsZUFBZUQsbUJBQU9BLENBQUMseUVBQWlCO0FBQzVDLElBQUlFLFVBQVVGLG1CQUFPQSxDQUFDLHlGQUE2QjtBQUNuRCxJQUFJRyx5QkFBeUJKLHlCQUF5QkMsbUJBQU9BLENBQUMsMklBQXNEO0FBQ3BILElBQUlJLGFBQWFKLG1CQUFPQSxDQUFDLG1FQUFjO0FBQ3ZDLElBQUlLLGFBQWFMLG1CQUFPQSxDQUFDLDZHQUF1QztBQUNoRSxJQUFJTSxvQkFBb0JOLG1CQUFPQSxDQUFDLDZIQUErQztBQUMvRSxJQUFJTyx1QkFBdUJQLG1CQUFPQSxDQUFDLG1JQUFrRDtBQUNyRixJQUFJUSxlQUFlUixtQkFBT0EsQ0FBQyx1RUFBZ0I7QUFDM0MsTUFBTVM7SUFDRkMsY0FBYztRQUNWLElBQUlDLEtBQXlCLEVBQWMsRUFFMUMsTUFBTTtZQUNILElBQUlLLE9BQU9DLG9CQUFvQixFQUFFO2dCQUM3QixPQUFPRCxPQUFPQyxvQkFBb0IsQ0FBQ0MsS0FBSztZQUM1QyxPQUFPO2dCQUNILElBQUksQ0FBQ0Msd0JBQXdCLElBQUssS0FBSSxDQUFDQSx3QkFBd0IsR0FBR0MsTUFBTSxHQUFvQixPQUFqQixJQUFJLENBQUNDLFdBQVcsRUFBQyxxREFBbURSLElBQUksQ0FBQyxDQUFDUyxNQUFNQSxJQUFJQyxJQUFJLElBQUlWLElBQUksQ0FBQyxDQUFDQyxXQUFXO29CQUNwTEUsT0FBT0Msb0JBQW9CLEdBQUdIO29CQUM5QixPQUFPQSxTQUFTSSxLQUFLO2dCQUN6QixHQUFHTSxLQUFLLENBQUMsQ0FBQ0MsTUFBTTtvQkFDWkMsUUFBUUMsR0FBRyxDQUFFLHFDQUFvQ0Y7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QU87QUFDbEMsQ0FBQyxDQUVELHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9wYWdlLWxvYWRlci5qcz9lODdhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5qc1wiKS5kZWZhdWx0O1xudmFyIF9hZGRCYXNlUGF0aCA9IHJlcXVpcmUoXCIuL2FkZC1iYXNlLXBhdGhcIik7XG52YXIgX3JvdXRlciA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci9yb3V0ZXJcIik7XG52YXIgX2dldEFzc2V0UGF0aEZyb21Sb3V0ZSA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZ2V0LWFzc2V0LXBhdGgtZnJvbS1yb3V0ZVwiKSk7XG52YXIgX2FkZExvY2FsZSA9IHJlcXVpcmUoXCIuL2FkZC1sb2NhbGVcIik7XG52YXIgX2lzRHluYW1pYyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pcy1keW5hbWljXCIpO1xudmFyIF9wYXJzZVJlbGF0aXZlVXJsID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybFwiKTtcbnZhciBfcmVtb3ZlVHJhaWxpbmdTbGFzaCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9yZW1vdmUtdHJhaWxpbmctc2xhc2hcIik7XG52YXIgX3JvdXRlTG9hZGVyID0gcmVxdWlyZShcIi4vcm91dGUtbG9hZGVyXCIpO1xuY2xhc3MgUGFnZUxvYWRlciB7XG4gICAgZ2V0UGFnZUxpc3QoKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9yb3V0ZUxvYWRlcikuZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpLnRoZW4oKG1hbmlmZXN0KT0+bWFuaWZlc3Quc29ydGVkUGFnZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5fX0RFVl9QQUdFU19NQU5JRkVTVCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuX19ERVZfUEFHRVNfTUFOSUZFU1QucGFnZXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvbWlzZWREZXZQYWdlc01hbmlmZXN0IHx8ICh0aGlzLnByb21pc2VkRGV2UGFnZXNNYW5pZmVzdCA9IGZldGNoKGAke3RoaXMuYXNzZXRQcmVmaXh9L19uZXh0L3N0YXRpYy9kZXZlbG9wbWVudC9fZGV2UGFnZXNNYW5pZmVzdC5qc29uYCkudGhlbigocmVzKT0+cmVzLmpzb24oKSkudGhlbigobWFuaWZlc3QpPT57XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5fX0RFVl9QQUdFU19NQU5JRkVTVCA9IG1hbmlmZXN0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFuaWZlc3QucGFnZXM7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEZhaWxlZCB0byBmZXRjaCBkZXZQYWdlc01hbmlmZXN0OmAsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIF9kZXZQYWdlc01hbmlmZXN0Lmpzb24uIElzIHNvbWV0aGluZyBibG9ja2luZyB0aGF0IG5ldHdvcmsgcmVxdWVzdD9cXG5gICsgJ1JlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvZmFpbGVkLXRvLWZldGNoLWRldnBhZ2VzbWFuaWZlc3QnKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZWREZXZQYWdlc01hbmlmZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldE1pZGRsZXdhcmUoKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zdCBtaWRkbGV3YXJlTWF0Y2hlcnMgPSBwcm9jZXNzLmVudi5fX05FWFRfTUlERExFV0FSRV9NQVRDSEVSUztcbiAgICAgICAgICAgIHdpbmRvdy5fX01JRERMRVdBUkVfTUFUQ0hFUlMgPSBtaWRkbGV3YXJlTWF0Y2hlcnMgPyBtaWRkbGV3YXJlTWF0Y2hlcnMgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93Ll9fTUlERExFV0FSRV9NQVRDSEVSUztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuX19ERVZfTUlERExFV0FSRV9NQVRDSEVSUykge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuX19ERVZfTUlERExFV0FSRV9NQVRDSEVSUztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByb21pc2VkTWlkZGxld2FyZU1hdGNoZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IERlY2lkZSB3aGF0IHNob3VsZCBoYXBwZW4gd2hlbiBmZXRjaGluZyBmYWlscyBpbnN0ZWFkIG9mIGFzc2VydGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvbWlzZWRNaWRkbGV3YXJlTWF0Y2hlcnMgPSBmZXRjaChgJHt0aGlzLmFzc2V0UHJlZml4fS9fbmV4dC9zdGF0aWMvJHt0aGlzLmJ1aWxkSWR9L19kZXZNaWRkbGV3YXJlTWFuaWZlc3QuanNvbmApLnRoZW4oKHJlcyk9PnJlcy5qc29uKCkpLnRoZW4oKG1hdGNoZXJzKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Ll9fREVWX01JRERMRVdBUkVfTUFUQ0hFUlMgPSBtYXRjaGVycztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVycztcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGYWlsZWQgdG8gZmV0Y2ggX2Rldk1pZGRsZXdhcmVNYW5pZmVzdGAsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUT0RPIFJlbW92ZSB0aGlzIGFzc2VydGlvbiBhcyB0aGlzIGNvdWxkIGJlIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb21pc2VkTWlkZGxld2FyZU1hdGNoZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldERhdGFIcmVmKHBhcmFtcykge1xuICAgICAgICBjb25zdCB7IGFzUGF0aCAsIGhyZWYgLCBsb2NhbGUgIH0gPSBwYXJhbXM7XG4gICAgICAgIGNvbnN0IHsgcGF0aG5hbWU6IGhyZWZQYXRobmFtZSAsIHF1ZXJ5ICwgc2VhcmNoICB9ID0gKDAsIF9wYXJzZVJlbGF0aXZlVXJsKS5wYXJzZVJlbGF0aXZlVXJsKGhyZWYpO1xuICAgICAgICBjb25zdCB7IHBhdGhuYW1lOiBhc1BhdGhuYW1lICB9ID0gKDAsIF9wYXJzZVJlbGF0aXZlVXJsKS5wYXJzZVJlbGF0aXZlVXJsKGFzUGF0aCk7XG4gICAgICAgIGNvbnN0IHJvdXRlID0gKDAsIF9yZW1vdmVUcmFpbGluZ1NsYXNoKS5yZW1vdmVUcmFpbGluZ1NsYXNoKGhyZWZQYXRobmFtZSk7XG4gICAgICAgIGlmIChyb3V0ZVswXSAhPT0gJy8nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJvdXRlIG5hbWUgc2hvdWxkIHN0YXJ0IHdpdGggYSBcIi9cIiwgZ290IFwiJHtyb3V0ZX1cImApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGdldEhyZWZGb3JTbHVnID0gKHBhdGgpPT57XG4gICAgICAgICAgICBjb25zdCBkYXRhUm91dGUgPSAoMCwgX2dldEFzc2V0UGF0aEZyb21Sb3V0ZSkuZGVmYXVsdCgoMCwgX3JlbW92ZVRyYWlsaW5nU2xhc2gpLnJlbW92ZVRyYWlsaW5nU2xhc2goKDAsIF9hZGRMb2NhbGUpLmFkZExvY2FsZShwYXRoLCBsb2NhbGUpKSwgJy5qc29uJyk7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9hZGRCYXNlUGF0aCkuYWRkQmFzZVBhdGgoYC9fbmV4dC9kYXRhLyR7dGhpcy5idWlsZElkfSR7ZGF0YVJvdXRlfSR7c2VhcmNofWAsIHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZ2V0SHJlZkZvclNsdWcocGFyYW1zLnNraXBJbnRlcnBvbGF0aW9uID8gYXNQYXRobmFtZSA6ICgwLCBfaXNEeW5hbWljKS5pc0R5bmFtaWNSb3V0ZShyb3V0ZSkgPyAoMCwgX3JvdXRlcikuaW50ZXJwb2xhdGVBcyhocmVmUGF0aG5hbWUsIGFzUGF0aG5hbWUsIHF1ZXJ5KS5yZXN1bHQgOiByb3V0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm91dGUgLSB0aGUgcm91dGUgKGZpbGUtc3lzdGVtIHBhdGgpXG4gICAqLyBfaXNTc2cocm91dGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZWRTc2dNYW5pZmVzdC50aGVuKChtYW5pZmVzdCk9Pm1hbmlmZXN0Lmhhcyhyb3V0ZSkpO1xuICAgIH1cbiAgICBsb2FkUGFnZShyb3V0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3V0ZUxvYWRlci5sb2FkUm91dGUocm91dGUpLnRoZW4oKHJlcyk9PntcbiAgICAgICAgICAgIGlmICgnY29tcG9uZW50JyBpbiByZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBwYWdlOiByZXMuY29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICBtb2Q6IHJlcy5leHBvcnRzLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZVNoZWV0czogcmVzLnN0eWxlcy5tYXAoKG8pPT4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6IG8uaHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBvLmNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyByZXMuZXJyb3I7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwcmVmZXRjaChyb3V0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3V0ZUxvYWRlci5wcmVmZXRjaChyb3V0ZSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGJ1aWxkSWQsIGFzc2V0UHJlZml4KXtcbiAgICAgICAgdGhpcy5yb3V0ZUxvYWRlciA9ICgwLCBfcm91dGVMb2FkZXIpLmNyZWF0ZVJvdXRlTG9hZGVyKGFzc2V0UHJlZml4KTtcbiAgICAgICAgdGhpcy5idWlsZElkID0gYnVpbGRJZDtcbiAgICAgICAgdGhpcy5hc3NldFByZWZpeCA9IGFzc2V0UHJlZml4O1xuICAgICAgICB0aGlzLnByb21pc2VkU3NnTWFuaWZlc3QgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSk9PntcbiAgICAgICAgICAgIGlmICh3aW5kb3cuX19TU0dfTUFOSUZFU1QpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHdpbmRvdy5fX1NTR19NQU5JRkVTVCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5fX1NTR19NQU5JRkVTVF9DQiA9ICgpPT57XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUod2luZG93Ll9fU1NHX01BTklGRVNUKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBQYWdlTG9hZGVyO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWdlLWxvYWRlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsIl9hZGRCYXNlUGF0aCIsIl9yb3V0ZXIiLCJfZ2V0QXNzZXRQYXRoRnJvbVJvdXRlIiwiX2FkZExvY2FsZSIsIl9pc0R5bmFtaWMiLCJfcGFyc2VSZWxhdGl2ZVVybCIsIl9yZW1vdmVUcmFpbGluZ1NsYXNoIiwiX3JvdXRlTG9hZGVyIiwiUGFnZUxvYWRlciIsImdldFBhZ2VMaXN0IiwicHJvY2VzcyIsImdldENsaWVudEJ1aWxkTWFuaWZlc3QiLCJ0aGVuIiwibWFuaWZlc3QiLCJzb3J0ZWRQYWdlcyIsIndpbmRvdyIsIl9fREVWX1BBR0VTX01BTklGRVNUIiwicGFnZXMiLCJwcm9taXNlZERldlBhZ2VzTWFuaWZlc3QiLCJmZXRjaCIsImFzc2V0UHJlZml4IiwicmVzIiwianNvbiIsImNhdGNoIiwiZXJyIiwiY29uc29sZSIsImxvZyIsIkVycm9yIiwiZ2V0TWlkZGxld2FyZSIsIm1pZGRsZXdhcmVNYXRjaGVycyIsImVudiIsIl9fTkVYVF9NSURETEVXQVJFX01BVENIRVJTIiwiX19NSURETEVXQVJFX01BVENIRVJTIiwidW5kZWZpbmVkIiwiX19ERVZfTUlERExFV0FSRV9NQVRDSEVSUyIsInByb21pc2VkTWlkZGxld2FyZU1hdGNoZXJzIiwiYnVpbGRJZCIsIm1hdGNoZXJzIiwiZ2V0RGF0YUhyZWYiLCJwYXJhbXMiLCJhc1BhdGgiLCJocmVmIiwibG9jYWxlIiwicGF0aG5hbWUiLCJocmVmUGF0aG5hbWUiLCJxdWVyeSIsInNlYXJjaCIsInBhcnNlUmVsYXRpdmVVcmwiLCJhc1BhdGhuYW1lIiwicm91dGUiLCJyZW1vdmVUcmFpbGluZ1NsYXNoIiwiZ2V0SHJlZkZvclNsdWciLCJwYXRoIiwiZGF0YVJvdXRlIiwiYWRkTG9jYWxlIiwiYWRkQmFzZVBhdGgiLCJza2lwSW50ZXJwb2xhdGlvbiIsImlzRHluYW1pY1JvdXRlIiwiaW50ZXJwb2xhdGVBcyIsInJlc3VsdCIsIl9pc1NzZyIsInByb21pc2VkU3NnTWFuaWZlc3QiLCJoYXMiLCJsb2FkUGFnZSIsInJvdXRlTG9hZGVyIiwibG9hZFJvdXRlIiwicGFnZSIsImNvbXBvbmVudCIsIm1vZCIsInN0eWxlU2hlZXRzIiwic3R5bGVzIiwibWFwIiwibyIsInRleHQiLCJjb250ZW50IiwiZXJyb3IiLCJwcmVmZXRjaCIsImNvbnN0cnVjdG9yIiwiY3JlYXRlUm91dGVMb2FkZXIiLCJQcm9taXNlIiwicmVzb2x2ZSIsIl9fU1NHX01BTklGRVNUIiwiX19TU0dfTUFOSUZFU1RfQ0IiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/page-loader.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/performance-relayer.js":
/*!**************************************************************!*\
  !*** ./node_modules/next/dist/client/performance-relayer.js ***!
  \**************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\n// copied to prevent pulling in un-necessary utils\nconst WEB_VITALS = [\n    \"CLS\",\n    \"FCP\",\n    \"FID\",\n    \"INP\",\n    \"LCP\",\n    \"TTFB\"\n];\nconst initialHref = location.href;\nlet isRegistered = false;\nlet userReportHandler;\nfunction onReport(metric) {\n    if (userReportHandler) {\n        userReportHandler(metric);\n    }\n    // This code is not shipped, executed, or present in the client-side\n    // JavaScript bundle unless explicitly enabled in your application.\n    //\n    // When this feature is enabled, we'll make it very clear by printing a\n    // message during the build (`next build`).\n    if (false) { var ref; }\n}\nvar _default = (onPerfEntry)=>{\n    // Update function if it changes:\n    userReportHandler = onPerfEntry;\n    // Only register listeners once:\n    if (isRegistered) {\n        return;\n    }\n    isRegistered = true;\n    const attributions = undefined;\n    for (const webVital of WEB_VITALS){\n        try {\n            let mod;\n            if (false) {}\n            if (!mod) {\n                mod = __webpack_require__(/*! next/dist/compiled/web-vitals */ \"./node_modules/next/dist/compiled/web-vitals/web-vitals.js\");\n            }\n            mod[\"on\".concat(webVital)](onReport);\n        } catch (err) {\n            // Do nothing if the module fails to load\n            console.warn(\"Failed to track \".concat(webVital, \" web-vital\"), err);\n        }\n    }\n};\nexports[\"default\"] = _default;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=performance-relayer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9wZXJmb3JtYW5jZS1yZWxheWVyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGtCQUFlLEdBQUcsS0FBSztBQUN2QixrREFBa0Q7QUFDbEQsTUFBTUcsYUFBYTtJQUNmO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNIO0FBQ0QsTUFBTUMsY0FBY0MsU0FBU0MsSUFBSTtBQUNqQyxJQUFJQyxlQUFlLEtBQUs7QUFDeEIsSUFBSUM7QUFDSixTQUFTQyxTQUFTQyxNQUFNLEVBQUU7SUFDdEIsSUFBSUYsbUJBQW1CO1FBQ25CQSxrQkFBa0JFO0lBQ3RCLENBQUM7SUFDRCxvRUFBb0U7SUFDcEUsbUVBQW1FO0lBQ25FLEVBQUU7SUFDRix1RUFBdUU7SUFDdkUsMkNBQTJDO0lBQzNDLElBQUlDLEtBQzJCLEVBQUUsWUFtQ2hDO0FBQ0w7QUFDQSxJQUFJZ0MsV0FBVyxDQUFDQyxjQUFjO0lBQzFCLGlDQUFpQztJQUNqQ3BDLG9CQUFvQm9DO0lBQ3BCLGdDQUFnQztJQUNoQyxJQUFJckMsY0FBYztRQUNkO0lBQ0osQ0FBQztJQUNEQSxlQUFlLElBQUk7SUFDbkIsTUFBTXNDLGVBQWVsQyxTQUF5QztJQUM5RCxLQUFLLE1BQU1vQyxZQUFZNUMsV0FBVztRQUM5QixJQUFJO1lBQ0EsSUFBSTZDO1lBQ0osSUFBSXJDLEtBQTZDLEVBQUUsRUFJbEQ7WUFDRCxJQUFJLENBQUNxQyxLQUFLO2dCQUNOQSxNQUFNRyxtQkFBT0EsQ0FBQztZQUNsQixDQUFDO1lBQ0RILEdBQUcsQ0FBQyxLQUFjLE9BQVRELFVBQVcsQ0FBQ3RDO1FBQ3pCLEVBQUUsT0FBT2lDLEtBQUs7WUFDVix5Q0FBeUM7WUFDekNGLFFBQVFZLElBQUksQ0FBQyxtQkFBNEIsT0FBVEwsVUFBUyxlQUFhTDtRQUMxRDtJQUNKO0FBQ0o7QUFDQTFDLGtCQUFlLEdBQUcyQztBQUVsQixJQUFJLENBQUMsT0FBTzNDLFFBQVFFLE9BQU8sS0FBSyxjQUFlLE9BQU9GLFFBQVFFLE9BQU8sS0FBSyxZQUFZRixRQUFRRSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9GLFFBQVFFLE9BQU8sQ0FBQ21ELFVBQVUsS0FBSyxhQUFhO0lBQ3JLdkQsT0FBT0MsY0FBYyxDQUFDQyxRQUFRRSxPQUFPLEVBQUUsY0FBYztRQUFFRCxPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT3dELE1BQU0sQ0FBQ3RELFFBQVFFLE9BQU8sRUFBRUY7SUFDL0J1RCxPQUFPdkQsT0FBTyxHQUFHQSxRQUFRRSxPQUFPO0FBQ2xDLENBQUMsQ0FFRCwrQ0FBK0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvcGVyZm9ybWFuY2UtcmVsYXllci5qcz9lZjcxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuLy8gY29waWVkIHRvIHByZXZlbnQgcHVsbGluZyBpbiB1bi1uZWNlc3NhcnkgdXRpbHNcbmNvbnN0IFdFQl9WSVRBTFMgPSBbXG4gICAgJ0NMUycsXG4gICAgJ0ZDUCcsXG4gICAgJ0ZJRCcsXG4gICAgJ0lOUCcsXG4gICAgJ0xDUCcsXG4gICAgJ1RURkInXG5dO1xuY29uc3QgaW5pdGlhbEhyZWYgPSBsb2NhdGlvbi5ocmVmO1xubGV0IGlzUmVnaXN0ZXJlZCA9IGZhbHNlO1xubGV0IHVzZXJSZXBvcnRIYW5kbGVyO1xuZnVuY3Rpb24gb25SZXBvcnQobWV0cmljKSB7XG4gICAgaWYgKHVzZXJSZXBvcnRIYW5kbGVyKSB7XG4gICAgICAgIHVzZXJSZXBvcnRIYW5kbGVyKG1ldHJpYyk7XG4gICAgfVxuICAgIC8vIFRoaXMgY29kZSBpcyBub3Qgc2hpcHBlZCwgZXhlY3V0ZWQsIG9yIHByZXNlbnQgaW4gdGhlIGNsaWVudC1zaWRlXG4gICAgLy8gSmF2YVNjcmlwdCBidW5kbGUgdW5sZXNzIGV4cGxpY2l0bHkgZW5hYmxlZCBpbiB5b3VyIGFwcGxpY2F0aW9uLlxuICAgIC8vXG4gICAgLy8gV2hlbiB0aGlzIGZlYXR1cmUgaXMgZW5hYmxlZCwgd2UnbGwgbWFrZSBpdCB2ZXJ5IGNsZWFyIGJ5IHByaW50aW5nIGFcbiAgICAvLyBtZXNzYWdlIGR1cmluZyB0aGUgYnVpbGQgKGBuZXh0IGJ1aWxkYCkuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgJiYgLy8gVGhpcyBmaWVsZCBpcyBlbXB0eSB1bmxlc3MgeW91IGV4cGxpY2l0bHkgY29uZmlndXJlIGl0OlxuICAgIHByb2Nlc3MuZW52Ll9fTkVYVF9BTkFMWVRJQ1NfSUQpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIGRzbjogcHJvY2Vzcy5lbnYuX19ORVhUX0FOQUxZVElDU19JRCxcbiAgICAgICAgICAgIGlkOiBtZXRyaWMuaWQsXG4gICAgICAgICAgICBwYWdlOiAocmVmID0gd2luZG93Ll9fTkVYVF9EQVRBX18pID09IG51bGwgPyB2b2lkIDAgOiByZWYucGFnZSxcbiAgICAgICAgICAgIGhyZWY6IGluaXRpYWxIcmVmLFxuICAgICAgICAgICAgZXZlbnRfbmFtZTogbWV0cmljLm5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogbWV0cmljLnZhbHVlLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBzcGVlZDogJ2Nvbm5lY3Rpb24nIGluIG5hdmlnYXRvciAmJiBuYXZpZ2F0b3JbJ2Nvbm5lY3Rpb24nXSAmJiAnZWZmZWN0aXZlVHlwZScgaW4gbmF2aWdhdG9yWydjb25uZWN0aW9uJ10gPyBuYXZpZ2F0b3JbJ2Nvbm5lY3Rpb24nXVsnZWZmZWN0aXZlVHlwZSddIDogJydcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtcbiAgICAgICAgICAgIG5ldyBVUkxTZWFyY2hQYXJhbXMoYm9keSkudG9TdHJpbmcoKVxuICAgICAgICBdLCB7XG4gICAgICAgICAgICAvLyBUaGlzIGNvbnRlbnQgdHlwZSBpcyBuZWNlc3NhcnkgZm9yIGBzZW5kQmVhY29uYDpcbiAgICAgICAgICAgIHR5cGU6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB2aXRhbHNVcmwgPSAnaHR0cHM6Ly92aXRhbHMudmVyY2VsLWluc2lnaHRzLmNvbS92MS92aXRhbHMnO1xuICAgICAgICAvLyBOYXZpZ2F0b3IgaGFzIHRvIGJlIGJvdW5kIHRvIGVuc3VyZSBpdCBkb2VzIG5vdCBlcnJvciBpbiBzb21lIGJyb3dzZXJzXG4gICAgICAgIC8vIGh0dHBzOi8veGd3YW5nLm1lL3Bvc3RzL3lvdS1tYXktbm90LWtub3ctYmVhY29uLyNpdC1tYXktdGhyb3ctZXJyb3IlMkMtYmUtc3VyZS10by1jYXRjaFxuICAgICAgICBjb25zdCBzZW5kID0gbmF2aWdhdG9yLnNlbmRCZWFjb24gJiYgbmF2aWdhdG9yLnNlbmRCZWFjb24uYmluZChuYXZpZ2F0b3IpO1xuICAgICAgICBmdW5jdGlvbiBmYWxsYmFja1NlbmQoKSB7XG4gICAgICAgICAgICBmZXRjaCh2aXRhbHNVcmwsIHtcbiAgICAgICAgICAgICAgICBib2R5OiBibG9iLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxzOiAnb21pdCcsXG4gICAgICAgICAgICAgICAga2VlcGFsaXZlOiB0cnVlXG4gICAgICAgICAgICB9KS5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gSWYgc2VuZCBpcyB1bmRlZmluZWQgaXQnbGwgdGhyb3cgYXMgd2VsbC4gVGhpcyByZWR1Y2VzIG91dHB1dCBjb2RlIHNpemUuXG4gICAgICAgICAgICBzZW5kKHZpdGFsc1VybCwgYmxvYikgfHwgZmFsbGJhY2tTZW5kKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZmFsbGJhY2tTZW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG52YXIgX2RlZmF1bHQgPSAob25QZXJmRW50cnkpPT57XG4gICAgLy8gVXBkYXRlIGZ1bmN0aW9uIGlmIGl0IGNoYW5nZXM6XG4gICAgdXNlclJlcG9ydEhhbmRsZXIgPSBvblBlcmZFbnRyeTtcbiAgICAvLyBPbmx5IHJlZ2lzdGVyIGxpc3RlbmVycyBvbmNlOlxuICAgIGlmIChpc1JlZ2lzdGVyZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpc1JlZ2lzdGVyZWQgPSB0cnVlO1xuICAgIGNvbnN0IGF0dHJpYnV0aW9ucyA9IHByb2Nlc3MuZW52Ll9fTkVYVF9XRUJfVklUQUxTX0FUVFJJQlVUSU9OO1xuICAgIGZvciAoY29uc3Qgd2ViVml0YWwgb2YgV0VCX1ZJVEFMUyl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgbW9kO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfV0VCX1ZJVEFMU19BVFRSSUJVVElPTikge1xuICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGF0dHJpYnV0aW9ucy5pbmNsdWRlcyh3ZWJWaXRhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kID0gcmVxdWlyZSgnbmV4dC9kaXN0L2NvbXBpbGVkL3dlYi12aXRhbHMtYXR0cmlidXRpb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW1vZCkge1xuICAgICAgICAgICAgICAgIG1vZCA9IHJlcXVpcmUoJ25leHQvZGlzdC9jb21waWxlZC93ZWItdml0YWxzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb2RbYG9uJHt3ZWJWaXRhbH1gXShvblJlcG9ydCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gRG8gbm90aGluZyBpZiB0aGUgbW9kdWxlIGZhaWxzIHRvIGxvYWRcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIHRyYWNrICR7d2ViVml0YWx9IHdlYi12aXRhbGAsIGVycik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBlcmZvcm1hbmNlLXJlbGF5ZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdCIsIldFQl9WSVRBTFMiLCJpbml0aWFsSHJlZiIsImxvY2F0aW9uIiwiaHJlZiIsImlzUmVnaXN0ZXJlZCIsInVzZXJSZXBvcnRIYW5kbGVyIiwib25SZXBvcnQiLCJtZXRyaWMiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0FOQUxZVElDU19JRCIsInJlZiIsImJvZHkiLCJkc24iLCJpZCIsInBhZ2UiLCJ3aW5kb3ciLCJfX05FWFRfREFUQV9fIiwiZXZlbnRfbmFtZSIsIm5hbWUiLCJ0b1N0cmluZyIsInNwZWVkIiwibmF2aWdhdG9yIiwiYmxvYiIsIkJsb2IiLCJVUkxTZWFyY2hQYXJhbXMiLCJ0eXBlIiwidml0YWxzVXJsIiwic2VuZCIsInNlbmRCZWFjb24iLCJiaW5kIiwiZmFsbGJhY2tTZW5kIiwiZmV0Y2giLCJtZXRob2QiLCJjcmVkZW50aWFscyIsImtlZXBhbGl2ZSIsImNhdGNoIiwiY29uc29sZSIsImVycm9yIiwiZXJyIiwiX2RlZmF1bHQiLCJvblBlcmZFbnRyeSIsImF0dHJpYnV0aW9ucyIsIl9fTkVYVF9XRUJfVklUQUxTX0FUVFJJQlVUSU9OIiwid2ViVml0YWwiLCJtb2QiLCJfX05FWFRfSEFTX1dFQl9WSVRBTFNfQVRUUklCVVRJT04iLCJpbmNsdWRlcyIsInJlcXVpcmUiLCJ3YXJuIiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/performance-relayer.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/portal/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/portal/index.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Portal = void 0;\nvar _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nvar _reactDom = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\nconst Portal = (param)=>{\n    let { children , type  } = param;\n    _s();\n    const [portalNode, setPortalNode] = (0, _react).useState(null);\n    (0, _react).useEffect(()=>{\n        const element = document.createElement(type);\n        document.body.appendChild(element);\n        setPortalNode(element);\n        return ()=>{\n            document.body.removeChild(element);\n        };\n    }, [\n        type\n    ]);\n    return portalNode ? /*#__PURE__*/ (0, _reactDom).createPortal(children, portalNode) : null;\n};\n_s(Portal, \"RFImm+EuWCdF9gTeRNMrIZMTdTE=\");\n_c = Portal;\nexports.Portal = Portal;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=index.js.map\nvar _c;\n$RefreshReg$(_c, \"Portal\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9wb3J0YWwvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGNBQWMsR0FBRyxLQUFLO0FBQ3RCLElBQUlHLFNBQVNDLG1CQUFPQSxDQUFDLDRDQUFPO0FBQzVCLElBQUlDLFlBQVlELG1CQUFPQSxDQUFDLG9EQUFXO0FBQ25DLE1BQU1GLFNBQVMsU0FBd0I7UUFBdkIsRUFBRUksU0FBUSxFQUFHQyxLQUFJLEVBQUc7O0lBQ2hDLE1BQU0sQ0FBQ0MsWUFBWUMsY0FBYyxHQUFHLENBQUMsR0FBR04sTUFBTSxFQUFFTyxRQUFRLENBQUMsSUFBSTtJQUM1RCxJQUFHUCxNQUFNLEVBQUVRLFNBQVMsQ0FBQyxJQUFJO1FBQ3RCLE1BQU1DLFVBQVVDLFNBQVNDLGFBQWEsQ0FBQ1A7UUFDdkNNLFNBQVNFLElBQUksQ0FBQ0MsV0FBVyxDQUFDSjtRQUMxQkgsY0FBY0c7UUFDZCxPQUFPLElBQUk7WUFDUEMsU0FBU0UsSUFBSSxDQUFDRSxXQUFXLENBQUNMO1FBQzlCO0lBQ0osR0FBRztRQUNDTDtLQUNIO0lBQ0QsT0FBT0MsYUFBMkIsV0FBSCxHQUFJLElBQUdILFNBQVMsRUFBRWEsWUFBWSxDQUFDWixVQUFVRSxjQUFjLElBQUk7QUFDOUY7R0FiTU47S0FBQUE7QUFjTkYsY0FBYyxHQUFHRTtBQUVqQixJQUFJLENBQUMsT0FBT0YsUUFBUW1CLE9BQU8sS0FBSyxjQUFlLE9BQU9uQixRQUFRbUIsT0FBTyxLQUFLLFlBQVluQixRQUFRbUIsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPbkIsUUFBUW1CLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDckt0QixPQUFPQyxjQUFjLENBQUNDLFFBQVFtQixPQUFPLEVBQUUsY0FBYztRQUFFbEIsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU91QixNQUFNLENBQUNyQixRQUFRbUIsT0FBTyxFQUFFbkI7SUFDL0JzQixPQUFPdEIsT0FBTyxHQUFHQSxRQUFRbUIsT0FBTztBQUNsQyxDQUFDLENBRUQsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3BvcnRhbC9pbmRleC5qcz8zMWEyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5Qb3J0YWwgPSB2b2lkIDA7XG52YXIgX3JlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xudmFyIF9yZWFjdERvbSA9IHJlcXVpcmUoXCJyZWFjdC1kb21cIik7XG5jb25zdCBQb3J0YWwgPSAoeyBjaGlsZHJlbiAsIHR5cGUgIH0pPT57XG4gICAgY29uc3QgW3BvcnRhbE5vZGUsIHNldFBvcnRhbE5vZGVdID0gKDAsIF9yZWFjdCkudXNlU3RhdGUobnVsbCk7XG4gICAgKDAsIF9yZWFjdCkudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICBzZXRQb3J0YWxOb2RlKGVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICB0eXBlXG4gICAgXSk7XG4gICAgcmV0dXJuIHBvcnRhbE5vZGUgPyAvKiNfX1BVUkVfXyovICgwLCBfcmVhY3REb20pLmNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgcG9ydGFsTm9kZSkgOiBudWxsO1xufTtcbmV4cG9ydHMuUG9ydGFsID0gUG9ydGFsO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJQb3J0YWwiLCJfcmVhY3QiLCJyZXF1aXJlIiwiX3JlYWN0RG9tIiwiY2hpbGRyZW4iLCJ0eXBlIiwicG9ydGFsTm9kZSIsInNldFBvcnRhbE5vZGUiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsImVsZW1lbnQiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJyZW1vdmVDaGlsZCIsImNyZWF0ZVBvcnRhbCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/portal/index.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/remove-base-path.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/remove-base-path.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.removeBasePath = removeBasePath;\nvar _hasBasePath = __webpack_require__(/*! ./has-base-path */ \"./node_modules/next/dist/client/has-base-path.js\");\nconst basePath =  false || \"\";\nfunction removeBasePath(path) {\n    if (false) {}\n    path = path.slice(basePath.length);\n    if (!path.startsWith(\"/\")) path = \"/\".concat(path);\n    return path;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=remove-base-path.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yZW1vdmUtYmFzZS1wYXRoLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELHNCQUFzQixHQUFHRTtBQUN6QixJQUFJQyxlQUFlQyxtQkFBT0EsQ0FBQyx5RUFBaUI7QUFDNUMsTUFBTUMsV0FBV0MsTUFBa0MsSUFBSTtBQUN2RCxTQUFTSixlQUFlTyxJQUFJLEVBQUU7SUFDMUIsSUFBSUgsS0FBMEMsRUFBRSxFQUkvQztJQUNERyxPQUFPQSxLQUFLRyxLQUFLLENBQUNQLFNBQVNRLE1BQU07SUFDakMsSUFBSSxDQUFDSixLQUFLSyxVQUFVLENBQUMsTUFBTUwsT0FBTyxJQUFTLE9BQUxBO0lBQ3RDLE9BQU9BO0FBQ1g7QUFFQSxJQUFJLENBQUMsT0FBT1QsUUFBUWUsT0FBTyxLQUFLLGNBQWUsT0FBT2YsUUFBUWUsT0FBTyxLQUFLLFlBQVlmLFFBQVFlLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2YsUUFBUWUsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS2xCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUWUsT0FBTyxFQUFFLGNBQWM7UUFBRWQsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9tQixNQUFNLENBQUNqQixRQUFRZSxPQUFPLEVBQUVmO0lBQy9Ca0IsT0FBT2xCLE9BQU8sR0FBR0EsUUFBUWUsT0FBTztBQUNsQyxDQUFDLENBRUQsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlbW92ZS1iYXNlLXBhdGguanM/YjRmMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucmVtb3ZlQmFzZVBhdGggPSByZW1vdmVCYXNlUGF0aDtcbnZhciBfaGFzQmFzZVBhdGggPSByZXF1aXJlKFwiLi9oYXMtYmFzZS1wYXRoXCIpO1xuY29uc3QgYmFzZVBhdGggPSBwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIHx8ICcnO1xuZnVuY3Rpb24gcmVtb3ZlQmFzZVBhdGgocGF0aCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfTUFOVUFMX0NMSUVOVF9CQVNFX1BBVEgpIHtcbiAgICAgICAgaWYgKCEoMCwgX2hhc0Jhc2VQYXRoKS5oYXNCYXNlUGF0aChwYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoYmFzZVBhdGgubGVuZ3RoKTtcbiAgICBpZiAoIXBhdGguc3RhcnRzV2l0aCgnLycpKSBwYXRoID0gYC8ke3BhdGh9YDtcbiAgICByZXR1cm4gcGF0aDtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3ZlLWJhc2UtcGF0aC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJyZW1vdmVCYXNlUGF0aCIsIl9oYXNCYXNlUGF0aCIsInJlcXVpcmUiLCJiYXNlUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfUk9VVEVSX0JBU0VQQVRIIiwicGF0aCIsIl9fTkVYVF9NQU5VQUxfQ0xJRU5UX0JBU0VfUEFUSCIsImhhc0Jhc2VQYXRoIiwic2xpY2UiLCJsZW5ndGgiLCJzdGFydHNXaXRoIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/remove-base-path.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/remove-locale.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/client/remove-locale.js ***!
  \********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.removeLocale = removeLocale;\nvar _parsePath = __webpack_require__(/*! ../shared/lib/router/utils/parse-path */ \"./node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\nfunction removeLocale(path, locale) {\n    if (false) {}\n    return path;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=remove-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yZW1vdmUtbG9jYWxlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELG9CQUFvQixHQUFHRTtBQUN2QixJQUFJQyxhQUFhQyxtQkFBT0EsQ0FBQyw2R0FBdUM7QUFDaEUsU0FBU0YsYUFBYUcsSUFBSSxFQUFFQyxNQUFNLEVBQUU7SUFDaEMsSUFBSUMsS0FBK0IsRUFBRSxFQUtwQztJQUNELE9BQU9GO0FBQ1g7QUFFQSxJQUFJLENBQUMsT0FBT0wsUUFBUWtCLE9BQU8sS0FBSyxjQUFlLE9BQU9sQixRQUFRa0IsT0FBTyxLQUFLLFlBQVlsQixRQUFRa0IsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPbEIsUUFBUWtCLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktyQixPQUFPQyxjQUFjLENBQUNDLFFBQVFrQixPQUFPLEVBQUUsY0FBYztRQUFFakIsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9zQixNQUFNLENBQUNwQixRQUFRa0IsT0FBTyxFQUFFbEI7SUFDL0JxQixPQUFPckIsT0FBTyxHQUFHQSxRQUFRa0IsT0FBTztBQUNsQyxDQUFDLENBRUQseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlbW92ZS1sb2NhbGUuanM/NDc1MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucmVtb3ZlTG9jYWxlID0gcmVtb3ZlTG9jYWxlO1xudmFyIF9wYXJzZVBhdGggPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcGFyc2UtcGF0aFwiKTtcbmZ1bmN0aW9uIHJlbW92ZUxvY2FsZShwYXRoLCBsb2NhbGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICBjb25zdCB7IHBhdGhuYW1lICB9ID0gKDAsIF9wYXJzZVBhdGgpLnBhcnNlUGF0aChwYXRoKTtcbiAgICAgICAgY29uc3QgcGF0aExvd2VyID0gcGF0aG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgbG9jYWxlTG93ZXIgPSBsb2NhbGUgPT0gbnVsbCA/IHZvaWQgMCA6IGxvY2FsZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gbG9jYWxlICYmIChwYXRoTG93ZXIuc3RhcnRzV2l0aChgLyR7bG9jYWxlTG93ZXJ9L2ApIHx8IHBhdGhMb3dlciA9PT0gYC8ke2xvY2FsZUxvd2VyfWApID8gYCR7cGF0aG5hbWUubGVuZ3RoID09PSBsb2NhbGUubGVuZ3RoICsgMSA/IGAvYCA6IGBgfSR7cGF0aC5zbGljZShsb2NhbGUubGVuZ3RoICsgMSl9YCA6IHBhdGg7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdmUtbG9jYWxlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInJlbW92ZUxvY2FsZSIsIl9wYXJzZVBhdGgiLCJyZXF1aXJlIiwicGF0aCIsImxvY2FsZSIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfSTE4Tl9TVVBQT1JUIiwicGF0aG5hbWUiLCJwYXJzZVBhdGgiLCJwYXRoTG93ZXIiLCJ0b0xvd2VyQ2FzZSIsImxvY2FsZUxvd2VyIiwic3RhcnRzV2l0aCIsImxlbmd0aCIsInNsaWNlIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/remove-locale.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/request-idle-callback.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/request-idle-callback.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.cancelIdleCallback = exports.requestIdleCallback = void 0;\nconst requestIdleCallback = typeof self !== \"undefined\" && self.requestIdleCallback && self.requestIdleCallback.bind(window) || function(cb) {\n    let start = Date.now();\n    return setTimeout(function() {\n        cb({\n            didTimeout: false,\n            timeRemaining: function() {\n                return Math.max(0, 50 - (Date.now() - start));\n            }\n        });\n    }, 1);\n};\nexports.requestIdleCallback = requestIdleCallback;\nconst cancelIdleCallback = typeof self !== \"undefined\" && self.cancelIdleCallback && self.cancelIdleCallback.bind(window) || function(id) {\n    return clearTimeout(id);\n};\nexports.cancelIdleCallback = cancelIdleCallback;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=request-idle-callback.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yZXF1ZXN0LWlkbGUtY2FsbGJhY2suanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsMEJBQTBCLEdBQUdBLDJCQUEyQixHQUFHLEtBQUs7QUFDaEUsTUFBTUcsc0JBQXNCLE9BQU9DLFNBQVMsZUFBZUEsS0FBS0QsbUJBQW1CLElBQUlDLEtBQUtELG1CQUFtQixDQUFDRSxJQUFJLENBQUNDLFdBQVcsU0FBU0MsRUFBRSxFQUFFO0lBQ3pJLElBQUlDLFFBQVFDLEtBQUtDLEdBQUc7SUFDcEIsT0FBT0MsV0FBVyxXQUFXO1FBQ3pCSixHQUFHO1lBQ0NLLFlBQVksS0FBSztZQUNqQkMsZUFBZSxXQUFXO2dCQUN0QixPQUFPQyxLQUFLQyxHQUFHLENBQUMsR0FBRyxLQUFNTixDQUFBQSxLQUFLQyxHQUFHLEtBQUtGLEtBQUk7WUFDOUM7UUFDSjtJQUNKLEdBQUc7QUFDUDtBQUNBUiwyQkFBMkIsR0FBR0c7QUFDOUIsTUFBTUQscUJBQXFCLE9BQU9FLFNBQVMsZUFBZUEsS0FBS0Ysa0JBQWtCLElBQUlFLEtBQUtGLGtCQUFrQixDQUFDRyxJQUFJLENBQUNDLFdBQVcsU0FBU1UsRUFBRSxFQUFFO0lBQ3RJLE9BQU9DLGFBQWFEO0FBQ3hCO0FBQ0FoQiwwQkFBMEIsR0FBR0U7QUFFN0IsSUFBSSxDQUFDLE9BQU9GLFFBQVFrQixPQUFPLEtBQUssY0FBZSxPQUFPbEIsUUFBUWtCLE9BQU8sS0FBSyxZQUFZbEIsUUFBUWtCLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2xCLFFBQVFrQixPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLckIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRa0IsT0FBTyxFQUFFLGNBQWM7UUFBRWpCLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPc0IsTUFBTSxDQUFDcEIsUUFBUWtCLE9BQU8sRUFBRWxCO0lBQy9CcUIsT0FBT3JCLE9BQU8sR0FBR0EsUUFBUWtCLE9BQU87QUFDbEMsQ0FBQyxDQUVELGlEQUFpRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yZXF1ZXN0LWlkbGUtY2FsbGJhY2suanM/MWUyMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY2FuY2VsSWRsZUNhbGxiYWNrID0gZXhwb3J0cy5yZXF1ZXN0SWRsZUNhbGxiYWNrID0gdm9pZCAwO1xuY29uc3QgcmVxdWVzdElkbGVDYWxsYmFjayA9IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLnJlcXVlc3RJZGxlQ2FsbGJhY2sgJiYgc2VsZi5yZXF1ZXN0SWRsZUNhbGxiYWNrLmJpbmQod2luZG93KSB8fCBmdW5jdGlvbihjYikge1xuICAgIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGNiKHtcbiAgICAgICAgICAgIGRpZFRpbWVvdXQ6IGZhbHNlLFxuICAgICAgICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIDUwIC0gKERhdGUubm93KCkgLSBzdGFydCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LCAxKTtcbn07XG5leHBvcnRzLnJlcXVlc3RJZGxlQ2FsbGJhY2sgPSByZXF1ZXN0SWRsZUNhbGxiYWNrO1xuY29uc3QgY2FuY2VsSWRsZUNhbGxiYWNrID0gdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYuY2FuY2VsSWRsZUNhbGxiYWNrICYmIHNlbGYuY2FuY2VsSWRsZUNhbGxiYWNrLmJpbmQod2luZG93KSB8fCBmdW5jdGlvbihpZCkge1xuICAgIHJldHVybiBjbGVhclRpbWVvdXQoaWQpO1xufTtcbmV4cG9ydHMuY2FuY2VsSWRsZUNhbGxiYWNrID0gY2FuY2VsSWRsZUNhbGxiYWNrO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXF1ZXN0LWlkbGUtY2FsbGJhY2suanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiY2FuY2VsSWRsZUNhbGxiYWNrIiwicmVxdWVzdElkbGVDYWxsYmFjayIsInNlbGYiLCJiaW5kIiwid2luZG93IiwiY2IiLCJzdGFydCIsIkRhdGUiLCJub3ciLCJzZXRUaW1lb3V0IiwiZGlkVGltZW91dCIsInRpbWVSZW1haW5pbmciLCJNYXRoIiwibWF4IiwiaWQiLCJjbGVhclRpbWVvdXQiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/request-idle-callback.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/route-announcer.js":
/*!**********************************************************!*\
  !*** ./node_modules/next/dist/client/route-announcer.js ***!
  \**********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = exports.RouteAnnouncer = void 0;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar _router = __webpack_require__(/*! ./router */ \"./node_modules/next/dist/client/router.js\");\nconst nextjsRouteAnnouncerStyles = {\n    border: 0,\n    clip: \"rect(0 0 0 0)\",\n    height: \"1px\",\n    margin: \"-1px\",\n    overflow: \"hidden\",\n    padding: 0,\n    position: \"absolute\",\n    width: \"1px\",\n    // https://medium.com/@jessebeach/beware-smushed-off-screen-accessible-text-5952a4c2cbfe\n    whiteSpace: \"nowrap\",\n    wordWrap: \"normal\"\n};\nconst RouteAnnouncer = ()=>{\n    _s();\n    const { asPath  } = (0, _router).useRouter();\n    const [routeAnnouncement, setRouteAnnouncement] = _react.default.useState(\"\");\n    // Only announce the path change, but not for the first load because screen\n    // reader will do that automatically.\n    const previouslyLoadedPath = _react.default.useRef(asPath);\n    // Every time the path changes, announce the new page’s title following this\n    // priority: first the document title (from head), otherwise the first h1, or\n    // if none of these exist, then the pathname from the URL. This methodology is\n    // inspired by Marcy Sutton’s accessible client routing user testing. More\n    // information can be found here:\n    // https://www.gatsbyjs.com/blog/2019-07-11-user-testing-accessible-client-routing/\n    _react.default.useEffect(()=>{\n        // If the path hasn't change, we do nothing.\n        if (previouslyLoadedPath.current === asPath) return;\n        previouslyLoadedPath.current = asPath;\n        if (document.title) {\n            setRouteAnnouncement(document.title);\n        } else {\n            const pageHeader = document.querySelector(\"h1\");\n            var ref;\n            const content = (ref = pageHeader == null ? void 0 : pageHeader.innerText) != null ? ref : pageHeader == null ? void 0 : pageHeader.textContent;\n            setRouteAnnouncement(content || asPath);\n        }\n    }, [\n        asPath\n    ]);\n    return /*#__PURE__*/ _react.default.createElement(\"p\", {\n        \"aria-live\": \"assertive\" // Make the announcement immediately.\n        ,\n        id: \"__next-route-announcer__\",\n        role: \"alert\",\n        style: nextjsRouteAnnouncerStyles\n    }, routeAnnouncement);\n};\n_s(RouteAnnouncer, \"XmDOMcfEgRlT21GulgLTmCStecg=\");\n_c = RouteAnnouncer;\nexports.RouteAnnouncer = RouteAnnouncer;\nvar _default = RouteAnnouncer;\nexports[\"default\"] = _default;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=route-announcer.js.map\nvar _c;\n$RefreshReg$(_c, \"RouteAnnouncer\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yb3V0ZS1hbm5vdW5jZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGtCQUFlLEdBQUdBLHNCQUFzQixHQUFHLEtBQUs7QUFDaEQsSUFBSUksMkJBQTJCQyxtSkFBK0Q7QUFDOUYsSUFBSUMsU0FBU0YseUJBQXlCQyxtQkFBT0EsQ0FBQyw0Q0FBTztBQUNyRCxJQUFJRSxVQUFVRixtQkFBT0EsQ0FBQywyREFBVTtBQUNoQyxNQUFNRyw2QkFBNkI7SUFDL0JDLFFBQVE7SUFDUkMsTUFBTTtJQUNOQyxRQUFRO0lBQ1JDLFFBQVE7SUFDUkMsVUFBVTtJQUNWQyxTQUFTO0lBQ1RDLFVBQVU7SUFDVkMsT0FBTztJQUNQLHdGQUF3RjtJQUN4RkMsWUFBWTtJQUNaQyxVQUFVO0FBQ2Q7QUFDQSxNQUFNZixpQkFBaUIsSUFBSTs7SUFDdkIsTUFBTSxFQUFFZ0IsT0FBTSxFQUFHLEdBQUcsQ0FBQyxHQUFHWixPQUFPLEVBQUVhLFNBQVM7SUFDMUMsTUFBTSxDQUFDQyxtQkFBbUJDLHFCQUFxQixHQUFHaEIsT0FBT0osT0FBTyxDQUFDcUIsUUFBUSxDQUFDO0lBQzFFLDJFQUEyRTtJQUMzRSxxQ0FBcUM7SUFDckMsTUFBTUMsdUJBQXVCbEIsT0FBT0osT0FBTyxDQUFDdUIsTUFBTSxDQUFDTjtJQUNuRCw0RUFBNEU7SUFDNUUsNkVBQTZFO0lBQzdFLDhFQUE4RTtJQUM5RSwwRUFBMEU7SUFDMUUsaUNBQWlDO0lBQ2pDLG1GQUFtRjtJQUNuRmIsT0FBT0osT0FBTyxDQUFDd0IsU0FBUyxDQUFDLElBQUk7UUFDekIsNENBQTRDO1FBQzVDLElBQUlGLHFCQUFxQkcsT0FBTyxLQUFLUixRQUFRO1FBQzdDSyxxQkFBcUJHLE9BQU8sR0FBR1I7UUFDL0IsSUFBSVMsU0FBU0MsS0FBSyxFQUFFO1lBQ2hCUCxxQkFBcUJNLFNBQVNDLEtBQUs7UUFDdkMsT0FBTztZQUNILE1BQU1DLGFBQWFGLFNBQVNHLGFBQWEsQ0FBQztZQUMxQyxJQUFJQztZQUNKLE1BQU1DLFVBQVUsQ0FBQ0QsTUFBTUYsY0FBYyxJQUFJLEdBQUcsS0FBSyxJQUFJQSxXQUFXSSxTQUFTLEtBQUssSUFBSSxHQUFHRixNQUFNRixjQUFjLElBQUksR0FBRyxLQUFLLElBQUlBLFdBQVdLLFdBQVc7WUFDL0liLHFCQUFxQlcsV0FBV2Q7UUFDcEMsQ0FBQztJQUNMLEdBQ0E7UUFDSUE7S0FDSDtJQUNELE9BQU8sV0FBVyxHQUFHYixPQUFPSixPQUFPLENBQUNrQyxhQUFhLENBQUMsS0FBSztRQUNuRCxhQUFhLFlBQVkscUNBQXFDOztRQUU5REMsSUFBSTtRQUNKQyxNQUFNO1FBQ05DLE9BQU8vQjtJQUNYLEdBQUdhO0FBQ1A7R0FuQ01sQjtLQUFBQTtBQW9DTkgsc0JBQXNCLEdBQUdHO0FBQ3pCLElBQUlxQyxXQUFXckM7QUFDZkgsa0JBQWUsR0FBR3dDO0FBRWxCLElBQUksQ0FBQyxPQUFPeEMsUUFBUUUsT0FBTyxLQUFLLGNBQWUsT0FBT0YsUUFBUUUsT0FBTyxLQUFLLFlBQVlGLFFBQVFFLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT0YsUUFBUUUsT0FBTyxDQUFDdUMsVUFBVSxLQUFLLGFBQWE7SUFDckszQyxPQUFPQyxjQUFjLENBQUNDLFFBQVFFLE9BQU8sRUFBRSxjQUFjO1FBQUVELE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPNEMsTUFBTSxDQUFDMUMsUUFBUUUsT0FBTyxFQUFFRjtJQUMvQjJDLE9BQU8zQyxPQUFPLEdBQUdBLFFBQVFFLE9BQU87QUFDbEMsQ0FBQyxDQUVELDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yb3V0ZS1hbm5vdW5jZXIuanM/NTgyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuUm91dGVBbm5vdW5jZXIgPSB2b2lkIDA7XG52YXIgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0LmpzXCIpLmRlZmF1bHQ7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX3JvdXRlciA9IHJlcXVpcmUoXCIuL3JvdXRlclwiKTtcbmNvbnN0IG5leHRqc1JvdXRlQW5ub3VuY2VyU3R5bGVzID0ge1xuICAgIGJvcmRlcjogMCxcbiAgICBjbGlwOiAncmVjdCgwIDAgMCAwKScsXG4gICAgaGVpZ2h0OiAnMXB4JyxcbiAgICBtYXJnaW46ICctMXB4JyxcbiAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgcGFkZGluZzogMCxcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB3aWR0aDogJzFweCcsXG4gICAgLy8gaHR0cHM6Ly9tZWRpdW0uY29tL0BqZXNzZWJlYWNoL2Jld2FyZS1zbXVzaGVkLW9mZi1zY3JlZW4tYWNjZXNzaWJsZS10ZXh0LTU5NTJhNGMyY2JmZVxuICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgIHdvcmRXcmFwOiAnbm9ybWFsJ1xufTtcbmNvbnN0IFJvdXRlQW5ub3VuY2VyID0gKCk9PntcbiAgICBjb25zdCB7IGFzUGF0aCAgfSA9ICgwLCBfcm91dGVyKS51c2VSb3V0ZXIoKTtcbiAgICBjb25zdCBbcm91dGVBbm5vdW5jZW1lbnQsIHNldFJvdXRlQW5ub3VuY2VtZW50XSA9IF9yZWFjdC5kZWZhdWx0LnVzZVN0YXRlKCcnKTtcbiAgICAvLyBPbmx5IGFubm91bmNlIHRoZSBwYXRoIGNoYW5nZSwgYnV0IG5vdCBmb3IgdGhlIGZpcnN0IGxvYWQgYmVjYXVzZSBzY3JlZW5cbiAgICAvLyByZWFkZXIgd2lsbCBkbyB0aGF0IGF1dG9tYXRpY2FsbHkuXG4gICAgY29uc3QgcHJldmlvdXNseUxvYWRlZFBhdGggPSBfcmVhY3QuZGVmYXVsdC51c2VSZWYoYXNQYXRoKTtcbiAgICAvLyBFdmVyeSB0aW1lIHRoZSBwYXRoIGNoYW5nZXMsIGFubm91bmNlIHRoZSBuZXcgcGFnZeKAmXMgdGl0bGUgZm9sbG93aW5nIHRoaXNcbiAgICAvLyBwcmlvcml0eTogZmlyc3QgdGhlIGRvY3VtZW50IHRpdGxlIChmcm9tIGhlYWQpLCBvdGhlcndpc2UgdGhlIGZpcnN0IGgxLCBvclxuICAgIC8vIGlmIG5vbmUgb2YgdGhlc2UgZXhpc3QsIHRoZW4gdGhlIHBhdGhuYW1lIGZyb20gdGhlIFVSTC4gVGhpcyBtZXRob2RvbG9neSBpc1xuICAgIC8vIGluc3BpcmVkIGJ5IE1hcmN5IFN1dHRvbuKAmXMgYWNjZXNzaWJsZSBjbGllbnQgcm91dGluZyB1c2VyIHRlc3RpbmcuIE1vcmVcbiAgICAvLyBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaGVyZTpcbiAgICAvLyBodHRwczovL3d3dy5nYXRzYnlqcy5jb20vYmxvZy8yMDE5LTA3LTExLXVzZXItdGVzdGluZy1hY2Nlc3NpYmxlLWNsaWVudC1yb3V0aW5nL1xuICAgIF9yZWFjdC5kZWZhdWx0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICAvLyBJZiB0aGUgcGF0aCBoYXNuJ3QgY2hhbmdlLCB3ZSBkbyBub3RoaW5nLlxuICAgICAgICBpZiAocHJldmlvdXNseUxvYWRlZFBhdGguY3VycmVudCA9PT0gYXNQYXRoKSByZXR1cm47XG4gICAgICAgIHByZXZpb3VzbHlMb2FkZWRQYXRoLmN1cnJlbnQgPSBhc1BhdGg7XG4gICAgICAgIGlmIChkb2N1bWVudC50aXRsZSkge1xuICAgICAgICAgICAgc2V0Um91dGVBbm5vdW5jZW1lbnQoZG9jdW1lbnQudGl0bGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcGFnZUhlYWRlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2gxJyk7XG4gICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IChyZWYgPSBwYWdlSGVhZGVyID09IG51bGwgPyB2b2lkIDAgOiBwYWdlSGVhZGVyLmlubmVyVGV4dCkgIT0gbnVsbCA/IHJlZiA6IHBhZ2VIZWFkZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHBhZ2VIZWFkZXIudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICBzZXRSb3V0ZUFubm91bmNlbWVudChjb250ZW50IHx8IGFzUGF0aCk7XG4gICAgICAgIH1cbiAgICB9LCAvLyBUT0RPOiBzd2l0Y2ggdG8gcGF0aG5hbWUgKyBxdWVyeSBvYmplY3Qgb2YgZHluYW1pYyByb3V0ZSByZXF1aXJlbWVudHNcbiAgICBbXG4gICAgICAgIGFzUGF0aFxuICAgIF0pO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJwXCIsIHtcbiAgICAgICAgXCJhcmlhLWxpdmVcIjogXCJhc3NlcnRpdmVcIiAvLyBNYWtlIHRoZSBhbm5vdW5jZW1lbnQgaW1tZWRpYXRlbHkuXG4gICAgICAgICxcbiAgICAgICAgaWQ6IFwiX19uZXh0LXJvdXRlLWFubm91bmNlcl9fXCIsXG4gICAgICAgIHJvbGU6IFwiYWxlcnRcIixcbiAgICAgICAgc3R5bGU6IG5leHRqc1JvdXRlQW5ub3VuY2VyU3R5bGVzXG4gICAgfSwgcm91dGVBbm5vdW5jZW1lbnQpO1xufTtcbmV4cG9ydHMuUm91dGVBbm5vdW5jZXIgPSBSb3V0ZUFubm91bmNlcjtcbnZhciBfZGVmYXVsdCA9IFJvdXRlQW5ub3VuY2VyO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlLWFubm91bmNlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwiUm91dGVBbm5vdW5jZXIiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJyZXF1aXJlIiwiX3JlYWN0IiwiX3JvdXRlciIsIm5leHRqc1JvdXRlQW5ub3VuY2VyU3R5bGVzIiwiYm9yZGVyIiwiY2xpcCIsImhlaWdodCIsIm1hcmdpbiIsIm92ZXJmbG93IiwicGFkZGluZyIsInBvc2l0aW9uIiwid2lkdGgiLCJ3aGl0ZVNwYWNlIiwid29yZFdyYXAiLCJhc1BhdGgiLCJ1c2VSb3V0ZXIiLCJyb3V0ZUFubm91bmNlbWVudCIsInNldFJvdXRlQW5ub3VuY2VtZW50IiwidXNlU3RhdGUiLCJwcmV2aW91c2x5TG9hZGVkUGF0aCIsInVzZVJlZiIsInVzZUVmZmVjdCIsImN1cnJlbnQiLCJkb2N1bWVudCIsInRpdGxlIiwicGFnZUhlYWRlciIsInF1ZXJ5U2VsZWN0b3IiLCJyZWYiLCJjb250ZW50IiwiaW5uZXJUZXh0IiwidGV4dENvbnRlbnQiLCJjcmVhdGVFbGVtZW50IiwiaWQiLCJyb2xlIiwic3R5bGUiLCJfZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/route-announcer.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/route-loader.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/route-loader.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.markAssetError = markAssetError;\nexports.isAssetError = isAssetError;\nexports.getClientBuildManifest = getClientBuildManifest;\nexports.createRouteLoader = createRouteLoader;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _getAssetPathFromRoute = _interop_require_default(__webpack_require__(/*! ../shared/lib/router/utils/get-asset-path-from-route */ \"./node_modules/next/dist/shared/lib/router/utils/get-asset-path-from-route.js\"));\nvar _trustedTypes = __webpack_require__(/*! ./trusted-types */ \"./node_modules/next/dist/client/trusted-types.js\");\nvar _requestIdleCallback = __webpack_require__(/*! ./request-idle-callback */ \"./node_modules/next/dist/client/request-idle-callback.js\");\n// 3.8s was arbitrarily chosen as it's what https://web.dev/interactive\n// considers as \"Good\" time-to-interactive. We must assume something went\n// wrong beyond this point, and then fall-back to a full page transition to\n// show the user something of value.\nconst MS_MAX_IDLE_DELAY = 3800;\nfunction withFuture(key, map, generator) {\n    let entry = map.get(key);\n    if (entry) {\n        if (\"future\" in entry) {\n            return entry.future;\n        }\n        return Promise.resolve(entry);\n    }\n    let resolver;\n    const prom = new Promise((resolve)=>{\n        resolver = resolve;\n    });\n    map.set(key, entry = {\n        resolve: resolver,\n        future: prom\n    });\n    return generator ? generator() // eslint-disable-next-line no-sequences\n    .then((value)=>(resolver(value), value)).catch((err)=>{\n        map.delete(key);\n        throw err;\n    }) : prom;\n}\nconst ASSET_LOAD_ERROR = Symbol(\"ASSET_LOAD_ERROR\");\nfunction markAssetError(err) {\n    return Object.defineProperty(err, ASSET_LOAD_ERROR, {});\n}\nfunction isAssetError(err) {\n    return err && ASSET_LOAD_ERROR in err;\n}\nfunction hasPrefetch(link) {\n    try {\n        link = document.createElement(\"link\");\n        return(// with relList.support\n        !!window.MSInputMethodContext && !!document.documentMode || link.relList.supports(\"prefetch\"));\n    } catch (e) {\n        return false;\n    }\n}\nconst canPrefetch = hasPrefetch();\nfunction prefetchViaDom(href, as, link) {\n    return new Promise((resolve, reject)=>{\n        const selector = '\\n      link[rel=\"prefetch\"][href^=\"'.concat(href, '\"],\\n      link[rel=\"preload\"][href^=\"').concat(href, '\"],\\n      script[src^=\"').concat(href, '\"]');\n        if (document.querySelector(selector)) {\n            return resolve();\n        }\n        link = document.createElement(\"link\");\n        // The order of property assignment here is intentional:\n        if (as) link.as = as;\n        link.rel = \"prefetch\";\n        link.crossOrigin = undefined;\n        link.onload = resolve;\n        link.onerror = ()=>reject(markAssetError(new Error(\"Failed to prefetch: \".concat(href))));\n        // `href` should always be last:\n        link.href = href;\n        document.head.appendChild(link);\n    });\n}\nfunction appendScript(src, script) {\n    return new Promise((resolve, reject)=>{\n        script = document.createElement(\"script\");\n        // The order of property assignment here is intentional.\n        // 1. Setup success/failure hooks in case the browser synchronously\n        //    executes when `src` is set.\n        script.onload = resolve;\n        script.onerror = ()=>reject(markAssetError(new Error(\"Failed to load script: \".concat(src))));\n        // 2. Configure the cross-origin attribute before setting `src` in case the\n        //    browser begins to fetch.\n        script.crossOrigin = undefined;\n        // 3. Finally, set the source and inject into the DOM in case the child\n        //    must be appended for fetching to start.\n        script.src = src;\n        document.body.appendChild(script);\n    });\n}\n// We wait for pages to be built in dev before we start the route transition\n// timeout to prevent an un-necessary hard navigation in development.\nlet devBuildPromise;\n// Resolve a promise that times out after given amount of milliseconds.\nfunction resolvePromiseWithTimeout(p, ms, err) {\n    return new Promise((resolve, reject)=>{\n        let cancelled = false;\n        p.then((r)=>{\n            // Resolved, cancel the timeout\n            cancelled = true;\n            resolve(r);\n        }).catch(reject);\n        // We wrap these checks separately for better dead-code elimination in\n        // production bundles.\n        if (true) {\n            (devBuildPromise || Promise.resolve()).then(()=>{\n                (0, _requestIdleCallback).requestIdleCallback(()=>setTimeout(()=>{\n                        if (!cancelled) {\n                            reject(err);\n                        }\n                    }, ms));\n            });\n        }\n        if (false) {}\n    });\n}\nfunction getClientBuildManifest() {\n    if (self.__BUILD_MANIFEST) {\n        return Promise.resolve(self.__BUILD_MANIFEST);\n    }\n    const onBuildManifest = new Promise((resolve)=>{\n        // Mandatory because this is not concurrent safe:\n        const cb = self.__BUILD_MANIFEST_CB;\n        self.__BUILD_MANIFEST_CB = ()=>{\n            resolve(self.__BUILD_MANIFEST);\n            cb && cb();\n        };\n    });\n    return resolvePromiseWithTimeout(onBuildManifest, MS_MAX_IDLE_DELAY, markAssetError(new Error(\"Failed to load client build manifest\")));\n}\nfunction getFilesForRoute(assetPrefix, route) {\n    if (true) {\n        const scriptUrl = assetPrefix + \"/_next/static/chunks/pages\" + encodeURI((0, _getAssetPathFromRoute).default(route, \".js\"));\n        return Promise.resolve({\n            scripts: [\n                (0, _trustedTypes).__unsafeCreateTrustedScriptURL(scriptUrl)\n            ],\n            // Styles are handled by `style-loader` in development:\n            css: []\n        });\n    }\n    return getClientBuildManifest().then((manifest)=>{\n        if (!(route in manifest)) {\n            throw markAssetError(new Error(\"Failed to lookup route: \".concat(route)));\n        }\n        const allFiles = manifest[route].map((entry)=>assetPrefix + \"/_next/\" + encodeURI(entry));\n        return {\n            scripts: allFiles.filter((v)=>v.endsWith(\".js\")).map((v)=>(0, _trustedTypes).__unsafeCreateTrustedScriptURL(v)),\n            css: allFiles.filter((v)=>v.endsWith(\".css\"))\n        };\n    });\n}\nfunction createRouteLoader(assetPrefix) {\n    const entrypoints = new Map();\n    const loadedScripts = new Map();\n    const styleSheets = new Map();\n    const routes = new Map();\n    function maybeExecuteScript(src) {\n        // With HMR we might need to \"reload\" scripts when they are\n        // disposed and readded. Executing scripts twice has no functional\n        // differences\n        if (false) {} else {\n            return appendScript(src);\n        }\n    }\n    function fetchStyleSheet(href) {\n        let prom = styleSheets.get(href);\n        if (prom) {\n            return prom;\n        }\n        styleSheets.set(href, prom = fetch(href).then((res)=>{\n            if (!res.ok) {\n                throw new Error(\"Failed to load stylesheet: \".concat(href));\n            }\n            return res.text().then((text)=>({\n                    href: href,\n                    content: text\n                }));\n        }).catch((err)=>{\n            throw markAssetError(err);\n        }));\n        return prom;\n    }\n    return {\n        whenEntrypoint (route) {\n            return withFuture(route, entrypoints);\n        },\n        onEntrypoint (route, execute) {\n            (execute ? Promise.resolve().then(()=>execute()).then((exports1)=>({\n                    component: exports1 && exports1.default || exports1,\n                    exports: exports1\n                }), (err)=>({\n                    error: err\n                })) : Promise.resolve(undefined)).then((input)=>{\n                const old = entrypoints.get(route);\n                if (old && \"resolve\" in old) {\n                    if (input) {\n                        entrypoints.set(route, input);\n                        old.resolve(input);\n                    }\n                } else {\n                    if (input) {\n                        entrypoints.set(route, input);\n                    } else {\n                        entrypoints.delete(route);\n                    }\n                    // when this entrypoint has been resolved before\n                    // the route is outdated and we want to invalidate\n                    // this cache entry\n                    routes.delete(route);\n                }\n            });\n        },\n        loadRoute (route, prefetch) {\n            return withFuture(route, routes, ()=>{\n                let devBuildPromiseResolve;\n                if (true) {\n                    devBuildPromise = new Promise((resolve)=>{\n                        devBuildPromiseResolve = resolve;\n                    });\n                }\n                return resolvePromiseWithTimeout(getFilesForRoute(assetPrefix, route).then((param)=>{\n                    let { scripts , css  } = param;\n                    return Promise.all([\n                        entrypoints.has(route) ? [] : Promise.all(scripts.map(maybeExecuteScript)),\n                        Promise.all(css.map(fetchStyleSheet))\n                    ]);\n                }).then((res)=>{\n                    return this.whenEntrypoint(route).then((entrypoint)=>({\n                            entrypoint,\n                            styles: res[1]\n                        }));\n                }), MS_MAX_IDLE_DELAY, markAssetError(new Error(\"Route did not complete loading: \".concat(route)))).then((param)=>{\n                    let { entrypoint , styles  } = param;\n                    const res = Object.assign({\n                        styles: styles\n                    }, entrypoint);\n                    return \"error\" in entrypoint ? entrypoint : res;\n                }).catch((err)=>{\n                    if (prefetch) {\n                        // we don't want to cache errors during prefetch\n                        throw err;\n                    }\n                    return {\n                        error: err\n                    };\n                }).finally(()=>{\n                    return devBuildPromiseResolve == null ? void 0 : devBuildPromiseResolve();\n                });\n            });\n        },\n        prefetch (route) {\n            // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n            // License: Apache 2.0\n            let cn;\n            if (cn = navigator.connection) {\n                // Don't prefetch if using 2G or if Save-Data is enabled.\n                if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();\n            }\n            return getFilesForRoute(assetPrefix, route).then((output)=>Promise.all(canPrefetch ? output.scripts.map((script)=>prefetchViaDom(script.toString(), \"script\")) : [])).then(()=>{\n                (0, _requestIdleCallback).requestIdleCallback(()=>this.loadRoute(route, true).catch(()=>{}));\n            }).catch(()=>{});\n        }\n    };\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=route-loader.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yb3V0ZS1sb2FkZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsc0JBQXNCLEdBQUdFO0FBQ3pCRixvQkFBb0IsR0FBR0c7QUFDdkJILDhCQUE4QixHQUFHSTtBQUNqQ0oseUJBQXlCLEdBQUdLO0FBQzVCLElBQUlDLDJCQUEyQkMsbUpBQStEO0FBQzlGLElBQUlFLHlCQUF5QkgseUJBQXlCQyxtQkFBT0EsQ0FBQywySUFBc0Q7QUFDcEgsSUFBSUcsZ0JBQWdCSCxtQkFBT0EsQ0FBQyx5RUFBaUI7QUFDN0MsSUFBSUksdUJBQXVCSixtQkFBT0EsQ0FBQyx5RkFBeUI7QUFDNUQsdUVBQXVFO0FBQ3ZFLHlFQUF5RTtBQUN6RSwyRUFBMkU7QUFDM0Usb0NBQW9DO0FBQ3BDLE1BQU1LLG9CQUFvQjtBQUMxQixTQUFTQyxXQUFXQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsU0FBUyxFQUFFO0lBQ3JDLElBQUlDLFFBQVFGLElBQUlHLEdBQUcsQ0FBQ0o7SUFDcEIsSUFBSUcsT0FBTztRQUNQLElBQUksWUFBWUEsT0FBTztZQUNuQixPQUFPQSxNQUFNRSxNQUFNO1FBQ3ZCLENBQUM7UUFDRCxPQUFPQyxRQUFRQyxPQUFPLENBQUNKO0lBQzNCLENBQUM7SUFDRCxJQUFJSztJQUNKLE1BQU1DLE9BQU8sSUFBSUgsUUFBUSxDQUFDQyxVQUFVO1FBQ2hDQyxXQUFXRDtJQUNmO0lBQ0FOLElBQUlTLEdBQUcsQ0FBQ1YsS0FBS0csUUFBUTtRQUNqQkksU0FBU0M7UUFDVEgsUUFBUUk7SUFDWjtJQUNBLE9BQU9QLFlBQVlBLFlBQVcsd0NBQXdDO0tBQ3JFUyxJQUFJLENBQUMsQ0FBQ3hCLFFBQVNxQixDQUFBQSxTQUFTckIsUUFBUUEsS0FBSyxHQUFHeUIsS0FBSyxDQUFDLENBQUNDLE1BQU07UUFDbERaLElBQUlhLE1BQU0sQ0FBQ2Q7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QXNIO1lBQ3RILHNCQUFzQjtZQUN0QixJQUFJeUM7WUFDSixJQUFJQSxLQUFLQyxVQUFVQyxVQUFVLEVBQUU7Z0JBQzNCLHlEQUF5RDtnQkFDekQsSUFBSUYsR0FBR0csUUFBUSxJQUFJLEtBQUtDLElBQUksQ0FBQ0osR0FBR0ssYUFBYSxHQUFHLE9BQU92RyxRQUFRQyxPQUFPO1lBQzFFLENBQUM7WUFDRCxPQUFPc0QsaUJBQWlCQyxhQUFhQyxPQUFPcEQsSUFBSSxDQUFDLENBQUNtRyxTQUFTeEcsUUFBUTRGLEdBQUcsQ0FBQ3ZFLGNBQWNtRixPQUFPNUMsT0FBTyxDQUFDakUsR0FBRyxDQUFDLENBQUM2QyxTQUFTbEIsZUFBZWtCLE9BQU9rQyxRQUFRLElBQUksYUFBYSxFQUFFLEdBQUdyRSxJQUFJLENBQUMsSUFBSTtnQkFDMUssSUFBR2Qsb0JBQW9CLEVBQUV5RCxtQkFBbUIsQ0FBQyxJQUFJLElBQUksQ0FBQ3lDLFNBQVMsQ0FBQ2hDLE9BQU8sSUFBSSxFQUFFbkQsS0FBSyxDQUFDLElBQUksQ0FBQztZQUM3RixHQUFHQSxLQUFLLENBQ1IsSUFBSSxDQUFDO1FBQ1Q7SUFDSjtBQUNKO0FBRUEsSUFBSSxDQUFDLE9BQU8xQixRQUFRUSxPQUFPLEtBQUssY0FBZSxPQUFPUixRQUFRUSxPQUFPLEtBQUssWUFBWVIsUUFBUVEsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPUixRQUFRUSxPQUFPLENBQUNxSCxVQUFVLEtBQUssYUFBYTtJQUNySy9ILE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUVEsT0FBTyxFQUFFLGNBQWM7UUFBRVAsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9zSCxNQUFNLENBQUNwSCxRQUFRUSxPQUFPLEVBQUVSO0lBQy9COEgsT0FBTzlILE9BQU8sR0FBR0EsUUFBUVEsT0FBTztBQUNsQyxDQUFDLENBRUQsd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JvdXRlLWxvYWRlci5qcz9lYTM0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5tYXJrQXNzZXRFcnJvciA9IG1hcmtBc3NldEVycm9yO1xuZXhwb3J0cy5pc0Fzc2V0RXJyb3IgPSBpc0Fzc2V0RXJyb3I7XG5leHBvcnRzLmdldENsaWVudEJ1aWxkTWFuaWZlc3QgPSBnZXRDbGllbnRCdWlsZE1hbmlmZXN0O1xuZXhwb3J0cy5jcmVhdGVSb3V0ZUxvYWRlciA9IGNyZWF0ZVJvdXRlTG9hZGVyO1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5qc1wiKS5kZWZhdWx0O1xudmFyIF9nZXRBc3NldFBhdGhGcm9tUm91dGUgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2dldC1hc3NldC1wYXRoLWZyb20tcm91dGVcIikpO1xudmFyIF90cnVzdGVkVHlwZXMgPSByZXF1aXJlKFwiLi90cnVzdGVkLXR5cGVzXCIpO1xudmFyIF9yZXF1ZXN0SWRsZUNhbGxiYWNrID0gcmVxdWlyZShcIi4vcmVxdWVzdC1pZGxlLWNhbGxiYWNrXCIpO1xuLy8gMy44cyB3YXMgYXJiaXRyYXJpbHkgY2hvc2VuIGFzIGl0J3Mgd2hhdCBodHRwczovL3dlYi5kZXYvaW50ZXJhY3RpdmVcbi8vIGNvbnNpZGVycyBhcyBcIkdvb2RcIiB0aW1lLXRvLWludGVyYWN0aXZlLiBXZSBtdXN0IGFzc3VtZSBzb21ldGhpbmcgd2VudFxuLy8gd3JvbmcgYmV5b25kIHRoaXMgcG9pbnQsIGFuZCB0aGVuIGZhbGwtYmFjayB0byBhIGZ1bGwgcGFnZSB0cmFuc2l0aW9uIHRvXG4vLyBzaG93IHRoZSB1c2VyIHNvbWV0aGluZyBvZiB2YWx1ZS5cbmNvbnN0IE1TX01BWF9JRExFX0RFTEFZID0gMzgwMDtcbmZ1bmN0aW9uIHdpdGhGdXR1cmUoa2V5LCBtYXAsIGdlbmVyYXRvcikge1xuICAgIGxldCBlbnRyeSA9IG1hcC5nZXQoa2V5KTtcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgaWYgKCdmdXR1cmUnIGluIGVudHJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gZW50cnkuZnV0dXJlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZW50cnkpO1xuICAgIH1cbiAgICBsZXQgcmVzb2x2ZXI7XG4gICAgY29uc3QgcHJvbSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKT0+e1xuICAgICAgICByZXNvbHZlciA9IHJlc29sdmU7XG4gICAgfSk7XG4gICAgbWFwLnNldChrZXksIGVudHJ5ID0ge1xuICAgICAgICByZXNvbHZlOiByZXNvbHZlcixcbiAgICAgICAgZnV0dXJlOiBwcm9tXG4gICAgfSk7XG4gICAgcmV0dXJuIGdlbmVyYXRvciA/IGdlbmVyYXRvcigpLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlcXVlbmNlc1xuICAgIC50aGVuKCh2YWx1ZSk9PihyZXNvbHZlcih2YWx1ZSksIHZhbHVlKSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgbWFwLmRlbGV0ZShrZXkpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfSkgOiBwcm9tO1xufVxuY29uc3QgQVNTRVRfTE9BRF9FUlJPUiA9IFN5bWJvbCgnQVNTRVRfTE9BRF9FUlJPUicpO1xuZnVuY3Rpb24gbWFya0Fzc2V0RXJyb3IoZXJyKSB7XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnIsIEFTU0VUX0xPQURfRVJST1IsIHt9KTtcbn1cbmZ1bmN0aW9uIGlzQXNzZXRFcnJvcihlcnIpIHtcbiAgICByZXR1cm4gZXJyICYmIEFTU0VUX0xPQURfRVJST1IgaW4gZXJyO1xufVxuZnVuY3Rpb24gaGFzUHJlZmV0Y2gobGluaykge1xuICAgIHRyeSB7XG4gICAgICAgIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG4gICAgICAgIHJldHVybigvLyBkZXRlY3QgSUUxMSBzaW5jZSBpdCBzdXBwb3J0cyBwcmVmZXRjaCBidXQgaXNuJ3QgZGV0ZWN0ZWRcbiAgICAgICAgLy8gd2l0aCByZWxMaXN0LnN1cHBvcnRcbiAgICAgICAgKCEhd2luZG93Lk1TSW5wdXRNZXRob2RDb250ZXh0ICYmICEhZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSB8fCBsaW5rLnJlbExpc3Quc3VwcG9ydHMoJ3ByZWZldGNoJykpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmNvbnN0IGNhblByZWZldGNoID0gaGFzUHJlZmV0Y2goKTtcbmZ1bmN0aW9uIHByZWZldGNoVmlhRG9tKGhyZWYsIGFzLCBsaW5rKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gYFxuICAgICAgbGlua1tyZWw9XCJwcmVmZXRjaFwiXVtocmVmXj1cIiR7aHJlZn1cIl0sXG4gICAgICBsaW5rW3JlbD1cInByZWxvYWRcIl1baHJlZl49XCIke2hyZWZ9XCJdLFxuICAgICAgc2NyaXB0W3NyY149XCIke2hyZWZ9XCJdYDtcbiAgICAgICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG4gICAgICAgIC8vIFRoZSBvcmRlciBvZiBwcm9wZXJ0eSBhc3NpZ25tZW50IGhlcmUgaXMgaW50ZW50aW9uYWw6XG4gICAgICAgIGlmIChhcykgbGluay5hcyA9IGFzO1xuICAgICAgICBsaW5rLnJlbCA9IGBwcmVmZXRjaGA7XG4gICAgICAgIGxpbmsuY3Jvc3NPcmlnaW4gPSBwcm9jZXNzLmVudi5fX05FWFRfQ1JPU1NfT1JJR0lOO1xuICAgICAgICBsaW5rLm9ubG9hZCA9IHJlc29sdmU7XG4gICAgICAgIGxpbmsub25lcnJvciA9ICgpPT5yZWplY3QobWFya0Fzc2V0RXJyb3IobmV3IEVycm9yKGBGYWlsZWQgdG8gcHJlZmV0Y2g6ICR7aHJlZn1gKSkpO1xuICAgICAgICAvLyBgaHJlZmAgc2hvdWxkIGFsd2F5cyBiZSBsYXN0OlxuICAgICAgICBsaW5rLmhyZWYgPSBocmVmO1xuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGxpbmspO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gYXBwZW5kU2NyaXB0KHNyYywgc2NyaXB0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICAvLyBUaGUgb3JkZXIgb2YgcHJvcGVydHkgYXNzaWdubWVudCBoZXJlIGlzIGludGVudGlvbmFsLlxuICAgICAgICAvLyAxLiBTZXR1cCBzdWNjZXNzL2ZhaWx1cmUgaG9va3MgaW4gY2FzZSB0aGUgYnJvd3NlciBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vICAgIGV4ZWN1dGVzIHdoZW4gYHNyY2AgaXMgc2V0LlxuICAgICAgICBzY3JpcHQub25sb2FkID0gcmVzb2x2ZTtcbiAgICAgICAgc2NyaXB0Lm9uZXJyb3IgPSAoKT0+cmVqZWN0KG1hcmtBc3NldEVycm9yKG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgc2NyaXB0OiAke3NyY31gKSkpO1xuICAgICAgICAvLyAyLiBDb25maWd1cmUgdGhlIGNyb3NzLW9yaWdpbiBhdHRyaWJ1dGUgYmVmb3JlIHNldHRpbmcgYHNyY2AgaW4gY2FzZSB0aGVcbiAgICAgICAgLy8gICAgYnJvd3NlciBiZWdpbnMgdG8gZmV0Y2guXG4gICAgICAgIHNjcmlwdC5jcm9zc09yaWdpbiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9DUk9TU19PUklHSU47XG4gICAgICAgIC8vIDMuIEZpbmFsbHksIHNldCB0aGUgc291cmNlIGFuZCBpbmplY3QgaW50byB0aGUgRE9NIGluIGNhc2UgdGhlIGNoaWxkXG4gICAgICAgIC8vICAgIG11c3QgYmUgYXBwZW5kZWQgZm9yIGZldGNoaW5nIHRvIHN0YXJ0LlxuICAgICAgICBzY3JpcHQuc3JjID0gc3JjO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgfSk7XG59XG4vLyBXZSB3YWl0IGZvciBwYWdlcyB0byBiZSBidWlsdCBpbiBkZXYgYmVmb3JlIHdlIHN0YXJ0IHRoZSByb3V0ZSB0cmFuc2l0aW9uXG4vLyB0aW1lb3V0IHRvIHByZXZlbnQgYW4gdW4tbmVjZXNzYXJ5IGhhcmQgbmF2aWdhdGlvbiBpbiBkZXZlbG9wbWVudC5cbmxldCBkZXZCdWlsZFByb21pc2U7XG4vLyBSZXNvbHZlIGEgcHJvbWlzZSB0aGF0IHRpbWVzIG91dCBhZnRlciBnaXZlbiBhbW91bnQgb2YgbWlsbGlzZWNvbmRzLlxuZnVuY3Rpb24gcmVzb2x2ZVByb21pc2VXaXRoVGltZW91dChwLCBtcywgZXJyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgcC50aGVuKChyKT0+e1xuICAgICAgICAgICAgLy8gUmVzb2x2ZWQsIGNhbmNlbCB0aGUgdGltZW91dFxuICAgICAgICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc29sdmUocik7XG4gICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XG4gICAgICAgIC8vIFdlIHdyYXAgdGhlc2UgY2hlY2tzIHNlcGFyYXRlbHkgZm9yIGJldHRlciBkZWFkLWNvZGUgZWxpbWluYXRpb24gaW5cbiAgICAgICAgLy8gcHJvZHVjdGlvbiBidW5kbGVzLlxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIChkZXZCdWlsZFByb21pc2UgfHwgUHJvbWlzZS5yZXNvbHZlKCkpLnRoZW4oKCk9PntcbiAgICAgICAgICAgICAgICAoMCwgX3JlcXVlc3RJZGxlQ2FsbGJhY2spLnJlcXVlc3RJZGxlQ2FsbGJhY2soKCk9PnNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIG1zKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgICgwLCBfcmVxdWVzdElkbGVDYWxsYmFjaykucmVxdWVzdElkbGVDYWxsYmFjaygoKT0+c2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBtcykpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRDbGllbnRCdWlsZE1hbmlmZXN0KCkge1xuICAgIGlmIChzZWxmLl9fQlVJTERfTUFOSUZFU1QpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzZWxmLl9fQlVJTERfTUFOSUZFU1QpO1xuICAgIH1cbiAgICBjb25zdCBvbkJ1aWxkTWFuaWZlc3QgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSk9PntcbiAgICAgICAgLy8gTWFuZGF0b3J5IGJlY2F1c2UgdGhpcyBpcyBub3QgY29uY3VycmVudCBzYWZlOlxuICAgICAgICBjb25zdCBjYiA9IHNlbGYuX19CVUlMRF9NQU5JRkVTVF9DQjtcbiAgICAgICAgc2VsZi5fX0JVSUxEX01BTklGRVNUX0NCID0gKCk9PntcbiAgICAgICAgICAgIHJlc29sdmUoc2VsZi5fX0JVSUxEX01BTklGRVNUKTtcbiAgICAgICAgICAgIGNiICYmIGNiKCk7XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc29sdmVQcm9taXNlV2l0aFRpbWVvdXQob25CdWlsZE1hbmlmZXN0LCBNU19NQVhfSURMRV9ERUxBWSwgbWFya0Fzc2V0RXJyb3IobmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBjbGllbnQgYnVpbGQgbWFuaWZlc3QnKSkpO1xufVxuZnVuY3Rpb24gZ2V0RmlsZXNGb3JSb3V0ZShhc3NldFByZWZpeCwgcm91dGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgY29uc3Qgc2NyaXB0VXJsID0gYXNzZXRQcmVmaXggKyAnL19uZXh0L3N0YXRpYy9jaHVua3MvcGFnZXMnICsgZW5jb2RlVVJJKCgwLCBfZ2V0QXNzZXRQYXRoRnJvbVJvdXRlKS5kZWZhdWx0KHJvdXRlLCAnLmpzJykpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgIHNjcmlwdHM6IFtcbiAgICAgICAgICAgICAgICAoMCwgX3RydXN0ZWRUeXBlcykuX191bnNhZmVDcmVhdGVUcnVzdGVkU2NyaXB0VVJMKHNjcmlwdFVybClcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAvLyBTdHlsZXMgYXJlIGhhbmRsZWQgYnkgYHN0eWxlLWxvYWRlcmAgaW4gZGV2ZWxvcG1lbnQ6XG4gICAgICAgICAgICBjc3M6IFtdXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpLnRoZW4oKG1hbmlmZXN0KT0+e1xuICAgICAgICBpZiAoIShyb3V0ZSBpbiBtYW5pZmVzdCkpIHtcbiAgICAgICAgICAgIHRocm93IG1hcmtBc3NldEVycm9yKG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvb2t1cCByb3V0ZTogJHtyb3V0ZX1gKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsRmlsZXMgPSBtYW5pZmVzdFtyb3V0ZV0ubWFwKChlbnRyeSk9PmFzc2V0UHJlZml4ICsgJy9fbmV4dC8nICsgZW5jb2RlVVJJKGVudHJ5KSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzY3JpcHRzOiBhbGxGaWxlcy5maWx0ZXIoKHYpPT52LmVuZHNXaXRoKCcuanMnKSkubWFwKCh2KT0+KDAsIF90cnVzdGVkVHlwZXMpLl9fdW5zYWZlQ3JlYXRlVHJ1c3RlZFNjcmlwdFVSTCh2KSksXG4gICAgICAgICAgICBjc3M6IGFsbEZpbGVzLmZpbHRlcigodik9PnYuZW5kc1dpdGgoJy5jc3MnKSlcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlTG9hZGVyKGFzc2V0UHJlZml4KSB7XG4gICAgY29uc3QgZW50cnlwb2ludHMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgbG9hZGVkU2NyaXB0cyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBzdHlsZVNoZWV0cyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCByb3V0ZXMgPSBuZXcgTWFwKCk7XG4gICAgZnVuY3Rpb24gbWF5YmVFeGVjdXRlU2NyaXB0KHNyYykge1xuICAgICAgICAvLyBXaXRoIEhNUiB3ZSBtaWdodCBuZWVkIHRvIFwicmVsb2FkXCIgc2NyaXB0cyB3aGVuIHRoZXkgYXJlXG4gICAgICAgIC8vIGRpc3Bvc2VkIGFuZCByZWFkZGVkLiBFeGVjdXRpbmcgc2NyaXB0cyB0d2ljZSBoYXMgbm8gZnVuY3Rpb25hbFxuICAgICAgICAvLyBkaWZmZXJlbmNlc1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIGxldCBwcm9tID0gbG9hZGVkU2NyaXB0cy5nZXQoc3JjLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgaWYgKHByb20pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNraXAgZXhlY3V0aW5nIHNjcmlwdCBpZiBpdCdzIGFscmVhZHkgaW4gdGhlIERPTTpcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBzY3JpcHRbc3JjXj1cIiR7c3JjfVwiXWApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9hZGVkU2NyaXB0cy5zZXQoc3JjLnRvU3RyaW5nKCksIHByb20gPSBhcHBlbmRTY3JpcHQoc3JjKSk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhcHBlbmRTY3JpcHQoc3JjKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmZXRjaFN0eWxlU2hlZXQoaHJlZikge1xuICAgICAgICBsZXQgcHJvbSA9IHN0eWxlU2hlZXRzLmdldChocmVmKTtcbiAgICAgICAgaWYgKHByb20pIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9tO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlU2hlZXRzLnNldChocmVmLCBwcm9tID0gZmV0Y2goaHJlZikudGhlbigocmVzKT0+e1xuICAgICAgICAgICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHN0eWxlc2hlZXQ6ICR7aHJlZn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXMudGV4dCgpLnRoZW4oKHRleHQpPT4oe1xuICAgICAgICAgICAgICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiB0ZXh0XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgdGhyb3cgbWFya0Fzc2V0RXJyb3IoZXJyKTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gcHJvbTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2hlbkVudHJ5cG9pbnQgKHJvdXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gd2l0aEZ1dHVyZShyb3V0ZSwgZW50cnlwb2ludHMpO1xuICAgICAgICB9LFxuICAgICAgICBvbkVudHJ5cG9pbnQgKHJvdXRlLCBleGVjdXRlKSB7XG4gICAgICAgICAgICAoZXhlY3V0ZSA/IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9PmV4ZWN1dGUoKSkudGhlbigoZXhwb3J0cyk9Pih7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogZXhwb3J0cyAmJiBleHBvcnRzLmRlZmF1bHQgfHwgZXhwb3J0cyxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogZXhwb3J0c1xuICAgICAgICAgICAgICAgIH0pLCAoZXJyKT0+KHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgICAgICAgIH0pKSA6IFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpKS50aGVuKChpbnB1dCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBvbGQgPSBlbnRyeXBvaW50cy5nZXQocm91dGUpO1xuICAgICAgICAgICAgICAgIGlmIChvbGQgJiYgJ3Jlc29sdmUnIGluIG9sZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5cG9pbnRzLnNldChyb3V0ZSwgaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2xkLnJlc29sdmUoaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeXBvaW50cy5zZXQocm91dGUsIGlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5cG9pbnRzLmRlbGV0ZShyb3V0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB0aGlzIGVudHJ5cG9pbnQgaGFzIGJlZW4gcmVzb2x2ZWQgYmVmb3JlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSByb3V0ZSBpcyBvdXRkYXRlZCBhbmQgd2Ugd2FudCB0byBpbnZhbGlkYXRlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY2FjaGUgZW50cnlcbiAgICAgICAgICAgICAgICAgICAgcm91dGVzLmRlbGV0ZShyb3V0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGxvYWRSb3V0ZSAocm91dGUsIHByZWZldGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gd2l0aEZ1dHVyZShyb3V0ZSwgcm91dGVzLCAoKT0+e1xuICAgICAgICAgICAgICAgIGxldCBkZXZCdWlsZFByb21pc2VSZXNvbHZlO1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgICAgICAgICBkZXZCdWlsZFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldkJ1aWxkUHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVQcm9taXNlV2l0aFRpbWVvdXQoZ2V0RmlsZXNGb3JSb3V0ZShhc3NldFByZWZpeCwgcm91dGUpLnRoZW4oKHsgc2NyaXB0cyAsIGNzcyAgfSk9PntcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5cG9pbnRzLmhhcyhyb3V0ZSkgPyBbXSA6IFByb21pc2UuYWxsKHNjcmlwdHMubWFwKG1heWJlRXhlY3V0ZVNjcmlwdCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwoY3NzLm1hcChmZXRjaFN0eWxlU2hlZXQpKSwgXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH0pLnRoZW4oKHJlcyk9PntcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud2hlbkVudHJ5cG9pbnQocm91dGUpLnRoZW4oKGVudHJ5cG9pbnQpPT4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5cG9pbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiByZXNbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9KSwgTVNfTUFYX0lETEVfREVMQVksIG1hcmtBc3NldEVycm9yKG5ldyBFcnJvcihgUm91dGUgZGlkIG5vdCBjb21wbGV0ZSBsb2FkaW5nOiAke3JvdXRlfWApKSkudGhlbigoeyBlbnRyeXBvaW50ICwgc3R5bGVzICB9KT0+e1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlczogc3R5bGVzXG4gICAgICAgICAgICAgICAgICAgIH0sIGVudHJ5cG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2Vycm9yJyBpbiBlbnRyeXBvaW50ID8gZW50cnlwb2ludCA6IHJlcztcbiAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJlZmV0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gY2FjaGUgZXJyb3JzIGR1cmluZyBwcmVmZXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSkuZmluYWxseSgoKT0+e1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGV2QnVpbGRQcm9taXNlUmVzb2x2ZSA9PSBudWxsID8gdm9pZCAwIDogZGV2QnVpbGRQcm9taXNlUmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHByZWZldGNoIChyb3V0ZSkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZUxhYnMvcXVpY2tsaW5rL2Jsb2IvNDUzYTY2MWZhMWZhOTQwZTJkMmUwNDQ0NTIzOThlMzhjNjdhOThmYi9zcmMvaW5kZXgubWpzI0wxMTUtTDExOFxuICAgICAgICAgICAgLy8gTGljZW5zZTogQXBhY2hlIDIuMFxuICAgICAgICAgICAgbGV0IGNuO1xuICAgICAgICAgICAgaWYgKGNuID0gbmF2aWdhdG9yLmNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBwcmVmZXRjaCBpZiB1c2luZyAyRyBvciBpZiBTYXZlLURhdGEgaXMgZW5hYmxlZC5cbiAgICAgICAgICAgICAgICBpZiAoY24uc2F2ZURhdGEgfHwgLzJnLy50ZXN0KGNuLmVmZmVjdGl2ZVR5cGUpKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2V0RmlsZXNGb3JSb3V0ZShhc3NldFByZWZpeCwgcm91dGUpLnRoZW4oKG91dHB1dCk9PlByb21pc2UuYWxsKGNhblByZWZldGNoID8gb3V0cHV0LnNjcmlwdHMubWFwKChzY3JpcHQpPT5wcmVmZXRjaFZpYURvbShzY3JpcHQudG9TdHJpbmcoKSwgJ3NjcmlwdCcpKSA6IFtdKSkudGhlbigoKT0+e1xuICAgICAgICAgICAgICAgICgwLCBfcmVxdWVzdElkbGVDYWxsYmFjaykucmVxdWVzdElkbGVDYWxsYmFjaygoKT0+dGhpcy5sb2FkUm91dGUocm91dGUsIHRydWUpLmNhdGNoKCgpPT57fSkpO1xuICAgICAgICAgICAgfSkuY2F0Y2goLy8gc3dhbGxvdyBwcmVmZXRjaCBlcnJvcnNcbiAgICAgICAgICAgICgpPT57fSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZS1sb2FkZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibWFya0Fzc2V0RXJyb3IiLCJpc0Fzc2V0RXJyb3IiLCJnZXRDbGllbnRCdWlsZE1hbmlmZXN0IiwiY3JlYXRlUm91dGVMb2FkZXIiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJyZXF1aXJlIiwiZGVmYXVsdCIsIl9nZXRBc3NldFBhdGhGcm9tUm91dGUiLCJfdHJ1c3RlZFR5cGVzIiwiX3JlcXVlc3RJZGxlQ2FsbGJhY2siLCJNU19NQVhfSURMRV9ERUxBWSIsIndpdGhGdXR1cmUiLCJrZXkiLCJtYXAiLCJnZW5lcmF0b3IiLCJlbnRyeSIsImdldCIsImZ1dHVyZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVzb2x2ZXIiLCJwcm9tIiwic2V0IiwidGhlbiIsImNhdGNoIiwiZXJyIiwiZGVsZXRlIiwiQVNTRVRfTE9BRF9FUlJPUiIsIlN5bWJvbCIsImhhc1ByZWZldGNoIiwibGluayIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIndpbmRvdyIsIk1TSW5wdXRNZXRob2RDb250ZXh0IiwiZG9jdW1lbnRNb2RlIiwicmVsTGlzdCIsInN1cHBvcnRzIiwiZSIsImNhblByZWZldGNoIiwicHJlZmV0Y2hWaWFEb20iLCJocmVmIiwiYXMiLCJyZWplY3QiLCJzZWxlY3RvciIsInF1ZXJ5U2VsZWN0b3IiLCJyZWwiLCJjcm9zc09yaWdpbiIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfQ1JPU1NfT1JJR0lOIiwib25sb2FkIiwib25lcnJvciIsIkVycm9yIiwiaGVhZCIsImFwcGVuZENoaWxkIiwiYXBwZW5kU2NyaXB0Iiwic3JjIiwic2NyaXB0IiwiYm9keSIsImRldkJ1aWxkUHJvbWlzZSIsInJlc29sdmVQcm9taXNlV2l0aFRpbWVvdXQiLCJwIiwibXMiLCJjYW5jZWxsZWQiLCJyIiwicmVxdWVzdElkbGVDYWxsYmFjayIsInNldFRpbWVvdXQiLCJzZWxmIiwiX19CVUlMRF9NQU5JRkVTVCIsIm9uQnVpbGRNYW5pZmVzdCIsImNiIiwiX19CVUlMRF9NQU5JRkVTVF9DQiIsImdldEZpbGVzRm9yUm91dGUiLCJhc3NldFByZWZpeCIsInJvdXRlIiwic2NyaXB0VXJsIiwiZW5jb2RlVVJJIiwic2NyaXB0cyIsIl9fdW5zYWZlQ3JlYXRlVHJ1c3RlZFNjcmlwdFVSTCIsImNzcyIsIm1hbmlmZXN0IiwiYWxsRmlsZXMiLCJmaWx0ZXIiLCJ2IiwiZW5kc1dpdGgiLCJlbnRyeXBvaW50cyIsIk1hcCIsImxvYWRlZFNjcmlwdHMiLCJzdHlsZVNoZWV0cyIsInJvdXRlcyIsIm1heWJlRXhlY3V0ZVNjcmlwdCIsInRvU3RyaW5nIiwiZmV0Y2hTdHlsZVNoZWV0IiwiZmV0Y2giLCJyZXMiLCJvayIsInRleHQiLCJjb250ZW50Iiwid2hlbkVudHJ5cG9pbnQiLCJvbkVudHJ5cG9pbnQiLCJleGVjdXRlIiwiY29tcG9uZW50IiwiZXJyb3IiLCJ1bmRlZmluZWQiLCJpbnB1dCIsIm9sZCIsImxvYWRSb3V0ZSIsInByZWZldGNoIiwiZGV2QnVpbGRQcm9taXNlUmVzb2x2ZSIsImFsbCIsImhhcyIsImVudHJ5cG9pbnQiLCJzdHlsZXMiLCJhc3NpZ24iLCJmaW5hbGx5IiwiY24iLCJuYXZpZ2F0b3IiLCJjb25uZWN0aW9uIiwic2F2ZURhdGEiLCJ0ZXN0IiwiZWZmZWN0aXZlVHlwZSIsIm91dHB1dCIsIl9fZXNNb2R1bGUiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/route-loader.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/router.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/client/router.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"Router\", ({\n    enumerable: true,\n    get: function() {\n        return _router.default;\n    }\n}));\nObject.defineProperty(exports, \"withRouter\", ({\n    enumerable: true,\n    get: function() {\n        return _withRouter.default;\n    }\n}));\nexports.useRouter = useRouter;\nexports.createRouter = createRouter;\nexports.makePublicRouterInstance = makePublicRouterInstance;\nexports[\"default\"] = void 0;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar _router = _interop_require_default(__webpack_require__(/*! ../shared/lib/router/router */ \"./node_modules/next/dist/shared/lib/router